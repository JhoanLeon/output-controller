CCS PCM C Compiler, Version 5.015, 5967               26-ago.-22 00:12

               Filename:   D:\Proyectos\output_controller\firmware\main.lst

               ROM used:   389 words (2%)
                           Largest free fragment is 2048
               RAM used:   21 (2%) at main() level
                           39 (4%) worst case
               Stack used: 2 locations (0 in main + 2 for interrupts)
               Stack size: 16

*
0000:  MOVLP  00
0001:  GOTO   126
0002:  NOP
*
0004:  CLRF   03
0005:  MOVLP  00
0006:  MOVLB  00
0007:  MOVF   77,W
0008:  MOVWF  20
0009:  MOVF   78,W
000A:  MOVWF  21
000B:  MOVF   79,W
000C:  MOVWF  22
000D:  MOVF   7A,W
000E:  MOVWF  23
000F:  CLRF   05
0010:  MOVLW  91
0011:  MOVWF  04
0012:  BTFSS  00.1
0013:  GOTO   016
0014:  BTFSC  11.1
0015:  GOTO   01F
0016:  MOVF   20,W
0017:  MOVWF  77
0018:  MOVF   21,W
0019:  MOVWF  78
001A:  MOVF   22,W
001B:  MOVWF  79
001C:  MOVF   23,W
001D:  MOVWF  7A
001E:  RETFIE
001F:  MOVLP  00
0020:  GOTO   05B
.................... #include <main.h> 
.................... #include <16F1939.h> 
.................... //////////// Standard Header file for the PIC16F1939 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F1939 
0021:  CLRF   78
0022:  CLRF   79
0023:  CLRF   77
0024:  CLRF   7A
0025:  MOVF   33,W
0026:  BTFSS  03.2
0027:  GOTO   02B
0028:  MOVF   32,W
0029:  BTFSC  03.2
002A:  GOTO   045
002B:  MOVLW  10
002C:  MOVWF  34
002D:  BCF    03.0
002E:  RLF    30,F
002F:  RLF    31,F
0030:  RLF    77,F
0031:  RLF    7A,F
0032:  MOVF   33,W
0033:  SUBWF  7A,W
0034:  BTFSS  03.2
0035:  GOTO   038
0036:  MOVF   32,W
0037:  SUBWF  77,W
0038:  BTFSS  03.0
0039:  GOTO   041
003A:  MOVF   32,W
003B:  SUBWF  77,F
003C:  BTFSS  03.0
003D:  DECF   7A,F
003E:  MOVF   33,W
003F:  SUBWF  7A,F
0040:  BSF    03.0
0041:  RLF    78,F
0042:  RLF    79,F
0043:  DECFSZ 34,F
0044:  GOTO   02D
0045:  RETURN
0046:  MOVLW  10
0047:  MOVWF  36
0048:  CLRF   77
0049:  CLRF   7A
004A:  RRF    33,F
004B:  RRF    32,F
004C:  BTFSS  03.0
004D:  GOTO   054
004E:  MOVF   34,W
004F:  ADDWF  77,F
0050:  BTFSC  03.0
0051:  INCF   7A,F
0052:  MOVF   35,W
0053:  ADDWF  7A,F
0054:  RRF    7A,F
0055:  RRF    77,F
0056:  RRF    79,F
0057:  RRF    78,F
0058:  DECFSZ 36,F
0059:  GOTO   04A
005A:  RETURN
....................  
.................... #list 
....................  
.................... #device ADC=16 
....................  
.................... #FUSES NOWDT                    // no Watch Dog Timer 
.................... #FUSES NOBROWNOUT               // no brownout reset 
.................... #FUSES NOLVP                    // no low voltage programming, B3(PIC16) or B5(PIC18) used for I/O 
....................  
.................... #use delay(crystal=20000000)  // external crystal clock 
....................  
.................... // I/O pin configurations 
.................... #use STANDARD_IO( B ) 
.................... #use FIXED_IO( B_outputs=PIN_B4,PIN_B5 ) 
.................... #use STANDARD_IO( D ) 
.................... #use FIXED_IO( D_outputs=PIN_D3,PIN_D1 ) 
....................  
.................... // Pin definitions 
.................... #define USER_LED     PIN_B4 
.................... #define COMMS_LED    PIN_B5 
.................... #define CS_PIN       PIN_D3  
....................  
.................... #define PWM1_PIN     PIN_C2 
.................... #define PWM2_PIN     PIN_C1 
.................... #define PWM3_PIN     PIN_E0 
.................... #define PWM4_PIN     PIN_D1 
....................  
....................  
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=PORT1) 
.................... #use SPI (MASTER, SPI1, BAUD=5000000, MODE=2, BITS=8, STREAM=SPI_1, MSB_FIRST) 
....................  
....................  
.................... unsigned int16 pwm_counter = 0; 
.................... unsigned int16 desired_pwm_period = 6579; // xxs 
.................... unsigned int16 desired_dutycycle_pwm1 = 0; // 0-100% 
.................... unsigned int16 desired_dutycycle_pwm2 = 50; // 0-100% 
.................... unsigned int16 desired_dutycycle_pwm3 = 75; // 0-100% 
.................... unsigned int16 desired_dutycycle_pwm4 = 100; // 0-100% 
....................  
....................  
.................... #INT_TIMER2 
.................... /* 
.................... * ISR function to generate PWM timebase 
.................... */ 
.................... void timer_2_timebase(void) 
.................... { 
....................    output_toggle(CS_PIN); 
005B:  MOVLW  F5
005C:  MOVLB  01
005D:  MOVWF  0F
005E:  MOVLW  08
005F:  MOVLB  02
0060:  XORWF  0F,F
....................     
....................    // set period 
....................    if (pwm_counter == desired_pwm_period) 
0061:  MOVLB  00
0062:  MOVF   26,W
0063:  SUBWF  24,W
0064:  BTFSS  03.2
0065:  GOTO   06D
0066:  MOVF   27,W
0067:  SUBWF  25,W
0068:  BTFSS  03.2
0069:  GOTO   06D
....................    { 
....................       // reset the counter to get the desired period 
....................       pwm_counter = 0; 
006A:  CLRF   25
006B:  CLRF   24
....................    } 
006C:  GOTO   071
....................    else 
....................    { 
....................       // count timebase 
....................       pwm_counter += 1; 
006D:  MOVLW  01
006E:  ADDWF  24,F
006F:  MOVLW  00
0070:  ADDWFC 25,F
....................    } 
....................     
....................    // set pwm outputs 
....................    if (pwm_counter < (desired_pwm_period/100)*desired_dutycycle_pwm1) 
0071:  MOVF   27,W
0072:  MOVWF  31
0073:  MOVF   26,W
0074:  MOVWF  30
0075:  CLRF   33
0076:  MOVLW  64
0077:  MOVWF  32
0078:  CALL   021
0079:  MOVF   79,W
007A:  MOVWF  31
007B:  MOVF   78,W
007C:  MOVWF  30
007D:  MOVF   31,W
007E:  MOVWF  33
007F:  MOVF   30,W
0080:  MOVWF  32
0081:  MOVF   29,W
0082:  MOVWF  35
0083:  MOVF   28,W
0084:  MOVWF  34
0085:  CALL   046
0086:  MOVF   79,W
0087:  MOVWF  7A
0088:  MOVF   25,W
0089:  SUBWF  7A,W
008A:  BTFSS  03.0
008B:  GOTO   098
008C:  BTFSS  03.2
008D:  GOTO   092
008E:  MOVF   78,W
008F:  SUBWF  24,W
0090:  BTFSC  03.0
0091:  GOTO   098
....................    { 
....................       // activate in high pwm1 output 
....................       output_high(PWM1_PIN); 
0092:  MOVLB  01
0093:  BCF    0E.2
0094:  MOVLB  02
0095:  BSF    0E.2
....................    } 
0096:  GOTO   09C
0097:  MOVLB  00
....................    else 
....................    { 
....................       output_low(PWM1_PIN); 
0098:  MOVLB  01
0099:  BCF    0E.2
009A:  MOVLB  02
009B:  BCF    0E.2
....................    } 
....................     
....................    if (pwm_counter < (desired_pwm_period/100)*desired_dutycycle_pwm2) 
009C:  MOVLB  00
009D:  MOVF   27,W
009E:  MOVWF  31
009F:  MOVF   26,W
00A0:  MOVWF  30
00A1:  CLRF   33
00A2:  MOVLW  64
00A3:  MOVWF  32
00A4:  CALL   021
00A5:  MOVF   79,W
00A6:  MOVWF  31
00A7:  MOVF   78,W
00A8:  MOVWF  30
00A9:  MOVF   31,W
00AA:  MOVWF  33
00AB:  MOVF   30,W
00AC:  MOVWF  32
00AD:  MOVF   2B,W
00AE:  MOVWF  35
00AF:  MOVF   2A,W
00B0:  MOVWF  34
00B1:  CALL   046
00B2:  MOVF   79,W
00B3:  MOVWF  7A
00B4:  MOVF   25,W
00B5:  SUBWF  7A,W
00B6:  BTFSS  03.0
00B7:  GOTO   0C4
00B8:  BTFSS  03.2
00B9:  GOTO   0BE
00BA:  MOVF   78,W
00BB:  SUBWF  24,W
00BC:  BTFSC  03.0
00BD:  GOTO   0C4
....................    { 
....................       // activate in high pwm2 output 
....................       output_high(PWM2_PIN); 
00BE:  MOVLB  01
00BF:  BCF    0E.1
00C0:  MOVLB  02
00C1:  BSF    0E.1
....................    } 
00C2:  GOTO   0C8
00C3:  MOVLB  00
....................    else 
....................    { 
....................       output_low(PWM2_PIN); 
00C4:  MOVLB  01
00C5:  BCF    0E.1
00C6:  MOVLB  02
00C7:  BCF    0E.1
....................    } 
....................     
....................    if (pwm_counter < (desired_pwm_period/100)*desired_dutycycle_pwm3) 
00C8:  MOVLB  00
00C9:  MOVF   27,W
00CA:  MOVWF  31
00CB:  MOVF   26,W
00CC:  MOVWF  30
00CD:  CLRF   33
00CE:  MOVLW  64
00CF:  MOVWF  32
00D0:  CALL   021
00D1:  MOVF   79,W
00D2:  MOVWF  31
00D3:  MOVF   78,W
00D4:  MOVWF  30
00D5:  MOVF   31,W
00D6:  MOVWF  33
00D7:  MOVF   30,W
00D8:  MOVWF  32
00D9:  MOVF   2D,W
00DA:  MOVWF  35
00DB:  MOVF   2C,W
00DC:  MOVWF  34
00DD:  CALL   046
00DE:  MOVF   79,W
00DF:  MOVWF  7A
00E0:  MOVF   25,W
00E1:  SUBWF  7A,W
00E2:  BTFSS  03.0
00E3:  GOTO   0F0
00E4:  BTFSS  03.2
00E5:  GOTO   0EA
00E6:  MOVF   78,W
00E7:  SUBWF  24,W
00E8:  BTFSC  03.0
00E9:  GOTO   0F0
....................    { 
....................       // activate in high pwm3 output 
....................       output_high(PWM3_PIN); 
00EA:  MOVLB  01
00EB:  BCF    10.0
00EC:  MOVLB  02
00ED:  BSF    10.0
....................    } 
00EE:  GOTO   0F4
00EF:  MOVLB  00
....................    else 
....................    { 
....................       output_low(PWM3_PIN); 
00F0:  MOVLB  01
00F1:  BCF    10.0
00F2:  MOVLB  02
00F3:  BCF    10.0
....................    } 
....................     
....................    if (pwm_counter < (desired_pwm_period/100)*desired_dutycycle_pwm4) 
00F4:  MOVLB  00
00F5:  MOVF   27,W
00F6:  MOVWF  31
00F7:  MOVF   26,W
00F8:  MOVWF  30
00F9:  CLRF   33
00FA:  MOVLW  64
00FB:  MOVWF  32
00FC:  CALL   021
00FD:  MOVF   79,W
00FE:  MOVWF  31
00FF:  MOVF   78,W
0100:  MOVWF  30
0101:  MOVF   31,W
0102:  MOVWF  33
0103:  MOVF   30,W
0104:  MOVWF  32
0105:  MOVF   2F,W
0106:  MOVWF  35
0107:  MOVF   2E,W
0108:  MOVWF  34
0109:  CALL   046
010A:  MOVF   79,W
010B:  MOVWF  7A
010C:  MOVF   25,W
010D:  SUBWF  7A,W
010E:  BTFSS  03.0
010F:  GOTO   11D
0110:  BTFSS  03.2
0111:  GOTO   116
0112:  MOVF   78,W
0113:  SUBWF  24,W
0114:  BTFSC  03.0
0115:  GOTO   11D
....................    { 
....................       // activate in high pwm4 output 
....................       output_high(PWM4_PIN); 
0116:  MOVLW  F5
0117:  MOVLB  01
0118:  MOVWF  0F
0119:  MOVLB  02
011A:  BSF    0F.1
....................    } 
011B:  GOTO   122
011C:  MOVLB  00
....................    else 
....................    { 
....................       output_low(PWM4_PIN); 
011D:  MOVLW  F5
011E:  MOVLB  01
011F:  MOVWF  0F
0120:  MOVLB  02
0121:  BCF    0F.1
....................    } 
0122:  MOVLB  00
0123:  BCF    11.1
0124:  MOVLP  00
0125:  GOTO   016
.................... } 
....................  
....................  
.................... void main() 
0126:  MOVLB  03
0127:  BSF    1F.3
0128:  MOVLW  08
0129:  MOVWF  1B
012A:  MOVLW  02
012B:  MOVWF  1C
012C:  MOVLW  A6
012D:  MOVWF  1E
012E:  MOVLW  90
012F:  MOVWF  1D
0130:  MOVLB  04
0131:  BCF    15.5
0132:  MOVLW  40
0133:  MOVWF  14
0134:  MOVLW  0B
0135:  MOVWF  12
0136:  MOVLW  3A
0137:  MOVWF  15
0138:  MOVLB  01
0139:  BCF    0E.5
013A:  BSF    0E.4
013B:  BCF    0E.3
013C:  MOVLB  00
013D:  CLRF   25
013E:  CLRF   24
013F:  MOVLW  19
0140:  MOVWF  27
0141:  MOVLW  B3
0142:  MOVWF  26
0143:  CLRF   29
0144:  CLRF   28
0145:  CLRF   2B
0146:  MOVLW  32
0147:  MOVWF  2A
0148:  CLRF   2D
0149:  MOVLW  4B
014A:  MOVWF  2C
014B:  CLRF   2F
014C:  MOVLW  64
014D:  MOVWF  2E
014E:  MOVLB  0F
014F:  CLRF   11
0150:  CLRF   12
0151:  CLRF   18
0152:  CLRF   19
0153:  CLRF   1A
0154:  MOVLB  03
0155:  CLRF   0C
0156:  CLRF   0D
0157:  CLRF   0F
0158:  CLRF   10
0159:  MOVLB  02
015A:  CLRF   12
015B:  CLRF   11
015C:  CLRF   14
015D:  CLRF   13
.................... { 
....................    // Set initial state of IO pins 
....................    output_low(USER_LED); // start with led turn off 
015E:  MOVLW  CF
015F:  TRIS   6
0160:  BCF    0D.4
....................    output_low(COMMS_LED); // start with led turn off 
0161:  TRIS   6
0162:  BCF    0D.5
....................    output_high(CS_PIN); // start in high to disable the slave 
0163:  MOVLW  F5
0164:  MOVLB  01
0165:  MOVWF  0F
0166:  MOVLB  02
0167:  BSF    0F.3
....................     
....................    // Set initial state of PWM pins 
....................    output_low(PWM1_PIN); 
0168:  MOVLB  01
0169:  BCF    0E.2
016A:  MOVLB  02
016B:  BCF    0E.2
....................    output_low(PWM2_PIN); 
016C:  MOVLB  01
016D:  BCF    0E.1
016E:  MOVLB  02
016F:  BCF    0E.1
....................    output_low(PWM3_PIN); 
0170:  MOVLB  01
0171:  BCF    10.0
0172:  MOVLB  02
0173:  BCF    10.0
....................    output_low(PWM4_PIN); 
0174:  MOVLB  01
0175:  MOVWF  0F
0176:  MOVLB  02
0177:  BCF    0F.1
....................     
....................    // Configure TIM2 to PWM timebase 
....................    setup_timer_2(T2_DIV_BY_1,76,1);      // 15,2 us overflow, 15,2 us interrupt 
0178:  MOVLW  00
0179:  MOVWF  78
017A:  IORLW  04
017B:  MOVLB  00
017C:  MOVWF  1C
017D:  MOVLW  4C
017E:  MOVWF  1B
....................     
....................    enable_interrupts(INT_RDA); // UART interrupt 
017F:  MOVLB  01
0180:  BSF    11.5
....................    enable_interrupts(INT_TIMER2); // timer 2 interrupt 
0181:  BSF    11.1
....................    enable_interrupts(GLOBAL); 
0182:  MOVLW  C0
0183:  IORWF  0B,F
....................  
....................    // Configure/set initial 0V at DAC output channels 
....................  
....................    while(TRUE) 
....................    { 
0184:  GOTO   184
.................... //!      output_low(USER_LED); 
.................... //!      output_high(COMMS_LED); 
.................... //!      delay_ms(500); 
.................... //!      output_high(USER_LED); 
.................... //!      output_low(COMMS_LED); 
.................... //!      delay_ms(500); 
.................... //!      output_toggle(CS_PIN); 
....................    } 
.................... } 
0185:  SLEEP

Configuration Fuses:
   Word  1: 39C2   HS NOWDT PUT MCLR NOPROTECT NOCPD NOBROWNOUT NOCLKOUT IESO FCMEN
   Word  2: 1EFF   NOWRT NOVCAP PLL_SW STVREN BORV19 NODEBUG NOLVP
