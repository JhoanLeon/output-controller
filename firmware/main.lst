CCS PCM C Compiler, Version 5.015, 5967               26-ago.-22 22:05

               Filename:   D:\Proyectos\output_controller\firmware\main.lst

               ROM used:   3564 words (22%)
                           Largest free fragment is 2048
               RAM used:   181 (18%) at main() level
                           214 (21%) worst case
               Stack used: 5 locations (3 in main + 2 for interrupts)
               Stack size: 16

*
0000:  MOVLP  08
0001:  GOTO   3AF
0002:  NOP
*
0004:  CLRF   03
0005:  MOVLP  00
0006:  MOVLB  00
0007:  MOVF   77,W
0008:  MOVWF  20
0009:  MOVF   78,W
000A:  MOVWF  21
000B:  MOVF   79,W
000C:  MOVWF  22
000D:  MOVF   7A,W
000E:  MOVWF  23
000F:  MOVLB  03
0010:  MOVF   11,W
0011:  MOVLB  00
0012:  MOVWF  24
0013:  MOVLB  03
0014:  MOVF   12,W
0015:  MOVLB  00
0016:  MOVWF  25
0017:  MOVLB  03
0018:  MOVF   13,W
0019:  MOVLB  00
001A:  MOVWF  26
001B:  MOVLB  03
001C:  MOVF   14,W
001D:  MOVLB  00
001E:  MOVWF  27
001F:  CLRF   05
0020:  MOVLW  91
0021:  MOVWF  04
0022:  BTFSS  00.1
0023:  GOTO   026
0024:  BTFSC  11.1
0025:  GOTO   046
0026:  CLRF   05
0027:  MOVLW  91
0028:  MOVWF  04
0029:  BTFSS  00.5
002A:  GOTO   02D
002B:  BTFSC  11.5
002C:  GOTO   048
002D:  MOVF   20,W
002E:  MOVWF  77
002F:  MOVF   21,W
0030:  MOVWF  78
0031:  MOVF   22,W
0032:  MOVWF  79
0033:  MOVF   23,W
0034:  MOVWF  7A
0035:  MOVF   24,W
0036:  MOVLB  03
0037:  MOVWF  11
0038:  MOVLB  00
0039:  MOVF   25,W
003A:  MOVLB  03
003B:  MOVWF  12
003C:  MOVLB  00
003D:  MOVF   26,W
003E:  MOVLB  03
003F:  MOVWF  13
0040:  MOVLB  00
0041:  MOVF   27,W
0042:  MOVLB  03
0043:  MOVWF  14
0044:  RETFIE
0045:  MOVLB  00
0046:  MOVLP  00
0047:  GOTO   088
0048:  MOVLP  00
0049:  GOTO   1C6
.................... #include <main.h> 
.................... #include <16F1939.h> 
.................... //////////// Standard Header file for the PIC16F1939 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F1939 
004A:  CLRF   78
004B:  CLRF   79
004C:  CLRF   77
004D:  CLRF   7A
004E:  MOVLB  02
004F:  MOVF   42,W
0050:  BTFSS  03.2
0051:  GOTO   055
0052:  MOVF   41,W
0053:  BTFSC  03.2
0054:  GOTO   06F
0055:  MOVLW  10
0056:  MOVWF  43
0057:  BCF    03.0
0058:  RLF    3F,F
0059:  RLF    40,F
005A:  RLF    77,F
005B:  RLF    7A,F
005C:  MOVF   42,W
005D:  SUBWF  7A,W
005E:  BTFSS  03.2
005F:  GOTO   062
0060:  MOVF   41,W
0061:  SUBWF  77,W
0062:  BTFSS  03.0
0063:  GOTO   06B
0064:  MOVF   41,W
0065:  SUBWF  77,F
0066:  BTFSS  03.0
0067:  DECF   7A,F
0068:  MOVF   42,W
0069:  SUBWF  7A,F
006A:  BSF    03.0
006B:  RLF    78,F
006C:  RLF    79,F
006D:  DECFSZ 43,F
006E:  GOTO   057
006F:  MOVLB  00
0070:  RETURN
0071:  MOVLW  10
0072:  MOVLB  02
0073:  MOVWF  45
0074:  CLRF   77
0075:  CLRF   7A
0076:  RRF    42,F
0077:  RRF    41,F
0078:  BTFSS  03.0
0079:  GOTO   080
007A:  MOVF   43,W
007B:  ADDWF  77,F
007C:  BTFSC  03.0
007D:  INCF   7A,F
007E:  MOVF   44,W
007F:  ADDWF  7A,F
0080:  RRF    7A,F
0081:  RRF    77,F
0082:  RRF    79,F
0083:  RRF    78,F
0084:  DECFSZ 45,F
0085:  GOTO   076
0086:  MOVLB  00
0087:  RETURN
*
0174:  MOVF   0B,W
0175:  BCF    0B.7
0176:  MOVLB  03
0177:  BSF    15.7
0178:  BSF    15.0
0179:  NOP
017A:  NOP
017B:  BTFSC  09.7
017C:  BSF    0B.7
017D:  MOVF   13,W
017E:  ANDLW  7F
017F:  BTFSC  03.2
0180:  GOTO   1C4
0181:  MOVLB  02
0182:  MOVWF  3F
0183:  MOVLB  03
0184:  MOVF   11,W
0185:  MOVLB  02
0186:  MOVWF  40
0187:  MOVLB  03
0188:  MOVF   12,W
0189:  MOVLB  02
018A:  MOVWF  41
018B:  MOVF   3F,W
018C:  MOVLB  00
018D:  BTFSS  11.4
018E:  GOTO   18D
018F:  MOVLB  03
0190:  MOVWF  1A
0191:  MOVLB  02
0192:  MOVF   40,W
0193:  MOVLB  03
0194:  MOVWF  11
0195:  MOVLB  02
0196:  MOVF   41,W
0197:  MOVLB  03
0198:  MOVWF  12
0199:  MOVF   0B,W
019A:  BCF    0B.7
019B:  BSF    15.7
019C:  BSF    15.0
019D:  NOP
019E:  NOP
019F:  BTFSC  09.7
01A0:  BSF    0B.7
01A1:  RLF    13,W
01A2:  RLF    14,W
01A3:  ANDLW  7F
01A4:  BTFSC  03.2
01A5:  GOTO   1C4
01A6:  MOVLB  02
01A7:  MOVWF  3F
01A8:  MOVLB  03
01A9:  MOVF   11,W
01AA:  MOVLB  02
01AB:  MOVWF  40
01AC:  MOVLB  03
01AD:  MOVF   12,W
01AE:  MOVLB  02
01AF:  MOVWF  41
01B0:  MOVF   3F,W
01B1:  MOVLB  00
01B2:  BTFSS  11.4
01B3:  GOTO   1B2
01B4:  MOVLB  03
01B5:  MOVWF  1A
01B6:  MOVLB  02
01B7:  MOVF   40,W
01B8:  MOVLB  03
01B9:  MOVWF  11
01BA:  MOVLB  02
01BB:  MOVF   41,W
01BC:  MOVLB  03
01BD:  MOVWF  12
01BE:  INCF   11,F
01BF:  BTFSC  03.2
01C0:  INCF   12,F
01C1:  MOVLB  00
01C2:  GOTO   174
01C3:  MOVLB  03
01C4:  MOVLB  00
01C5:  RETURN
*
021E:  DATA 45,29
021F:  DATA D2,27
0220:  DATA D2,06
0221:  DATA 0A,00
0222:  DATA 45,29
0223:  DATA D2,27
0224:  DATA D2,06
0225:  DATA 0A,00
0226:  DATA 45,29
0227:  DATA D2,27
0228:  DATA D2,06
0229:  DATA 0A,00
022A:  DATA 2B,28
022B:  DATA D7,26
022C:  DATA C4,2A
022D:  DATA D4,2C
022E:  DATA BA,18
022F:  DATA AC,12
0230:  DATA D8,12
0231:  DATA 58,16
0232:  DATA 32,16
0233:  DATA 25,2C
0234:  DATA 25,2C
0235:  DATA 0D,05
0236:  DATA 00,00
0237:  DATA CF,25
0238:  DATA 0D,05
0239:  DATA 00,01
023A:  DATA AB,20
023B:  DATA CE,27
023C:  DATA 55,2A
023D:  DATA 31,1D
023E:  DATA 25,2C
023F:  DATA 25,2C
0240:  DATA 0D,05
0241:  DATA 00,01
0242:  DATA AB,20
0243:  DATA CE,27
0244:  DATA 55,2A
0245:  DATA 32,1D
0246:  DATA 25,2C
0247:  DATA 25,2C
0248:  DATA 0D,05
0249:  DATA 00,01
024A:  DATA 45,29
024B:  DATA D2,27
024C:  DATA D2,06
024D:  DATA 0A,00
024E:  DATA 45,29
024F:  DATA D2,27
0250:  DATA D2,06
0251:  DATA 0A,00
0252:  DATA CF,25
0253:  DATA 0D,05
0254:  DATA 00,01
0255:  DATA 45,29
0256:  DATA D2,27
0257:  DATA D2,06
0258:  DATA 0A,00
0259:  DATA 2B,28
025A:  DATA D7,26
025B:  DATA D0,22
025C:  DATA D2,24
025D:  DATA 4F,22
025E:  DATA BA,12
025F:  DATA D8,12
0260:  DATA D8,06
0261:  DATA 0A,00
0262:  DATA CF,25
0263:  DATA 0D,05
0264:  DATA 00,01
0265:  DATA 2B,28
0266:  DATA D7,26
0267:  DATA D0,22
0268:  DATA D2,24
0269:  DATA 4F,22
026A:  DATA BA,12
026B:  DATA D8,12
026C:  DATA D8,06
026D:  DATA 0A,00
026E:  DATA CF,25
026F:  DATA 0D,05
0270:  DATA 00,01
0271:  DATA 45,29
0272:  DATA D2,27
0273:  DATA D2,06
0274:  DATA 0A,00
0275:  DATA 2B,28
0276:  DATA D7,26
0277:  DATA C4,2A
0278:  DATA D4,2C
0279:  DATA BA,18
027A:  DATA AC,12
027B:  DATA D8,12
027C:  DATA 58,16
027D:  DATA 32,16
027E:  DATA 25,2C
027F:  DATA 25,2C
0280:  DATA AC,19
0281:  DATA AC,12
0282:  DATA D8,12
0283:  DATA 58,16
0284:  DATA 34,16
0285:  DATA 25,2C
0286:  DATA 25,2C
0287:  DATA 0D,05
0288:  DATA 00,01
0289:  DATA CF,25
028A:  DATA 0D,05
028B:  DATA 00,01
028C:  DATA 2B,28
028D:  DATA D7,26
028E:  DATA C4,2A
028F:  DATA D4,2C
0290:  DATA 31,1D
0291:  DATA 25,2C
0292:  DATA 25,2C
0293:  DATA 0D,05
0294:  DATA 00,01
0295:  DATA 2B,28
0296:  DATA D7,26
0297:  DATA C4,2A
0298:  DATA D4,2C
0299:  DATA 32,1D
029A:  DATA 25,2C
029B:  DATA 25,2C
029C:  DATA 0D,05
029D:  DATA 00,01
029E:  DATA 2B,28
029F:  DATA D7,26
02A0:  DATA C4,2A
02A1:  DATA D4,2C
02A2:  DATA 33,1D
02A3:  DATA 25,2C
02A4:  DATA 25,2C
02A5:  DATA 0D,05
02A6:  DATA 00,01
02A7:  DATA 2B,28
02A8:  DATA D7,26
02A9:  DATA C4,2A
02AA:  DATA D4,2C
02AB:  DATA 34,1D
02AC:  DATA 25,2C
02AD:  DATA 25,2C
02AE:  DATA 0D,05
02AF:  DATA 00,01
02B0:  DATA 45,29
02B1:  DATA D2,27
02B2:  DATA D2,06
02B3:  DATA 0A,00
02B4:  DATA 45,29
02B5:  DATA D2,27
02B6:  DATA D2,06
02B7:  DATA 0A,00
02B8:  DATA CF,25
02B9:  DATA 0D,05
02BA:  DATA 00,01
02BB:  DATA 45,29
02BC:  DATA D2,27
02BD:  DATA D2,06
02BE:  DATA 0A,00
02BF:  DATA D6,32
02C0:  DATA F2,39
02C1:  DATA E9,37
02C2:  DATA 6E,1D
02C3:  DATA A0,18
02C4:  DATA 2E,18
02C5:  DATA 0D,05
02C6:  DATA 00,01
02C7:  DATA C4,30
02C8:  DATA F4,32
02C9:  DATA 3A,10
02CA:  DATA 32,1B
02CB:  DATA 2F,18
02CC:  DATA B8,17
02CD:  DATA 32,18
02CE:  DATA 32,19
02CF:  DATA 0D,05
02D0:  DATA 00,01
02D1:  DATA CF,25
02D2:  DATA 0D,05
02D3:  DATA 00,00
02D4:  DATA 41,2A
02D5:  DATA 20,10
02D6:  DATA C3,37
02D7:  DATA ED,30
02D8:  DATA 6E,32
02D9:  DATA 6F,10
02DA:  DATA E4,32
02DB:  DATA 20,38
02DC:  DATA F2,3A
02DD:  DATA 65,31
02DE:  DATA E1,06
02DF:  DATA 0A,00
02E0:  DATA 41,2A
02E1:  DATA AB,20
02E2:  DATA CE,27
02E3:  DATA 55,2A
02E4:  DATA 20,10
02E5:  DATA D0,30
02E6:  DATA F2,30
02E7:  DATA A0,32
02E8:  DATA 73,3A
02E9:  DATA 61,31
02EA:  DATA EC,32
02EB:  DATA E3,32
02EC:  DATA 72,10
02ED:  DATA F3,30
02EE:  DATA EC,34
02EF:  DATA E4,30
02F0:  DATA 73,10
02F1:  DATA 61,37
02F2:  DATA 61,36
02F3:  DATA EF,33
02F4:  DATA E1,39
02F5:  DATA 0D,05
02F6:  DATA 00,01
02F7:  DATA 41,2A
02F8:  DATA 2B,28
02F9:  DATA D7,26
02FA:  DATA D0,22
02FB:  DATA D2,24
02FC:  DATA 4F,22
02FD:  DATA 20,10
02FE:  DATA D0,30
02FF:  DATA F2,30
0300:  DATA A0,32
0301:  DATA 73,3A
0302:  DATA 61,31
0303:  DATA EC,32
0304:  DATA E3,32
0305:  DATA 72,10
0306:  DATA F0,32
0307:  DATA F2,34
0308:  DATA 6F,32
0309:  DATA 6F,10
030A:  DATA E4,32
030B:  DATA A0,31
030C:  DATA 61,37
030D:  DATA 61,36
030E:  DATA E5,39
030F:  DATA 20,28
0310:  DATA D7,26
0311:  DATA 0D,05
0312:  DATA 00,01
0313:  DATA 41,2A
0314:  DATA 2B,28
0315:  DATA D7,26
0316:  DATA C4,2A
0317:  DATA D4,2C
0318:  DATA 20,10
0319:  DATA D0,30
031A:  DATA F2,30
031B:  DATA A0,32
031C:  DATA 73,3A
031D:  DATA 61,31
031E:  DATA EC,32
031F:  DATA E3,32
0320:  DATA 72,10
0321:  DATA E3,34
0322:  DATA 63,36
0323:  DATA 6F,10
0324:  DATA E4,32
0325:  DATA 20,3A
0326:  DATA F2,30
0327:  DATA E2,30
0328:  DATA EA,37
0329:  DATA 20,32
032A:  DATA 65,10
032B:  DATA E3,30
032C:  DATA EE,30
032D:  DATA EC,32
032E:  DATA 73,10
032F:  DATA D0,2B
0330:  DATA CD,06
0331:  DATA 0A,00
0332:  DATA 41,2A
0333:  DATA AB,20
0334:  DATA C2,27
0335:  DATA 55,2A
0336:  DATA 20,10
0337:  DATA D0,30
0338:  DATA F2,30
0339:  DATA A0,36
033A:  DATA EF,39
033B:  DATA 74,39
033C:  DATA 61,39
033D:  DATA A0,34
033E:  DATA 6E,33
033F:  DATA 6F,39
0340:  DATA ED,30
0341:  DATA E3,34
0342:  DATA 6F,37
0343:  DATA 20,32
0344:  DATA 65,36
0345:  DATA 20,38
0346:  DATA F2,37
0347:  DATA E4,3A
0348:  DATA 63,3A
0349:  DATA EF,06
034A:  DATA 0A,00
034B:  DATA 41,2A
034C:  DATA 2B,24
034D:  DATA 45,26
034E:  DATA 50,10
034F:  DATA 20,28
0350:  DATA 61,39
0351:  DATA 61,10
0352:  DATA ED,37
0353:  DATA 73,3A
0354:  DATA F2,30
0355:  DATA 72,10
0356:  DATA EC,34
0357:  DATA 73,3A
0358:  DATA 61,10
0359:  DATA E4,32
035A:  DATA A0,31
035B:  DATA EF,36
035C:  DATA 61,37
035D:  DATA E4,37
035E:  DATA F3,06
035F:  DATA 0A,00
0360:  DATA CF,25
0361:  DATA 0D,05
0362:  DATA 00,00
0363:  DATA D2,22
0364:  DATA 41,22
0365:  DATA D9,06
0366:  DATA 0A,00
0367:  DATA CF,25
0368:  DATA 0D,05
0369:  DATA 00,01
036A:  DATA 45,29
036B:  DATA D2,27
036C:  DATA D2,06
036D:  DATA 0A,00
036E:  DATA 45,29
036F:  DATA D2,27
0370:  DATA D2,06
0371:  DATA 0A,00
*
03B3:  MOVF   0B,W
03B4:  BCF    0B.7
03B5:  MOVLB  03
03B6:  BSF    15.7
03B7:  BSF    15.0
03B8:  NOP
03B9:  NOP
03BA:  BTFSC  09.7
03BB:  BSF    0B.7
03BC:  BTFSC  03.0
03BD:  GOTO   3E8
03BE:  MOVF   13,W
03BF:  ANDLW  7F
03C0:  MOVLB  02
03C1:  MOVWF  35
03C2:  MOVLB  03
03C3:  MOVF   11,W
03C4:  MOVLB  02
03C5:  MOVWF  36
03C6:  MOVLB  03
03C7:  MOVF   12,W
03C8:  MOVLB  02
03C9:  MOVWF  37
03CA:  MOVF   35,W
03CB:  MOVLB  00
03CC:  BTFSS  11.4
03CD:  GOTO   3CC
03CE:  MOVLB  03
03CF:  MOVWF  1A
03D0:  MOVLB  02
03D1:  MOVF   36,W
03D2:  MOVLB  03
03D3:  MOVWF  11
03D4:  MOVLB  02
03D5:  MOVF   37,W
03D6:  MOVLB  03
03D7:  MOVWF  12
03D8:  MOVF   0B,W
03D9:  BCF    0B.7
03DA:  BSF    15.7
03DB:  BSF    15.0
03DC:  NOP
03DD:  NOP
03DE:  BTFSC  09.7
03DF:  BSF    0B.7
03E0:  MOVLB  02
03E1:  DECFSZ 34,F
03E2:  GOTO   3E4
03E3:  GOTO   3E6
03E4:  MOVLB  03
03E5:  GOTO   3E8
03E6:  GOTO   40D
03E7:  MOVLB  03
03E8:  RLF    13,W
03E9:  RLF    14,W
03EA:  ANDLW  7F
03EB:  MOVLB  02
03EC:  MOVWF  35
03ED:  MOVLB  03
03EE:  MOVF   11,W
03EF:  MOVLB  02
03F0:  MOVWF  36
03F1:  MOVLB  03
03F2:  MOVF   12,W
03F3:  MOVLB  02
03F4:  MOVWF  37
03F5:  MOVF   35,W
03F6:  MOVLB  00
03F7:  BTFSS  11.4
03F8:  GOTO   3F7
03F9:  MOVLB  03
03FA:  MOVWF  1A
03FB:  MOVLB  02
03FC:  MOVF   36,W
03FD:  MOVLB  03
03FE:  MOVWF  11
03FF:  MOVLB  02
0400:  MOVF   37,W
0401:  MOVLB  03
0402:  MOVWF  12
0403:  INCF   11,F
0404:  BTFSC  03.2
0405:  INCF   12,F
0406:  BCF    03.0
0407:  MOVLB  02
0408:  DECFSZ 34,F
0409:  GOTO   40B
040A:  GOTO   40D
040B:  MOVLB  00
040C:  GOTO   3B3
040D:  MOVLB  00
040E:  RETURN
040F:  MOVLB  02
0410:  BTFSC  35.7
0411:  GOTO   426
0412:  MOVLW  0F
0413:  MOVWF  77
0414:  SWAPF  34,W
0415:  ANDWF  77,F
0416:  MOVLW  0A
0417:  SUBWF  77,W
0418:  BTFSC  03.0
0419:  GOTO   41D
041A:  MOVLW  30
041B:  ADDWF  77,F
041C:  GOTO   41F
041D:  MOVF   35,W
041E:  ADDWF  77,F
041F:  MOVF   77,W
0420:  MOVLB  00
0421:  BTFSS  11.4
0422:  GOTO   421
0423:  MOVLB  03
0424:  MOVWF  1A
0425:  MOVLB  02
0426:  MOVLW  0F
0427:  ANDWF  34,F
0428:  MOVLW  0A
0429:  SUBWF  34,W
042A:  BTFSC  03.0
042B:  GOTO   42E
042C:  MOVLW  30
042D:  GOTO   430
042E:  BCF    35.7
042F:  MOVF   35,W
0430:  ADDWF  34,F
0431:  MOVF   34,W
0432:  MOVLB  00
0433:  BTFSS  11.4
0434:  GOTO   433
0435:  MOVLB  03
0436:  MOVWF  1A
0437:  MOVLB  00
0438:  RETURN
*
04CF:  BCF    0A.0
04D0:  BCF    0A.1
04D1:  BSF    0A.2
04D2:  ADDWF  02,F
04D3:  GOTO   448
04D4:  GOTO   44D
04D5:  GOTO   452
04D6:  GOTO   457
04D7:  GOTO   45C
04D8:  GOTO   461
04D9:  GOTO   466
04DA:  GOTO   46B
04DB:  GOTO   470
04DC:  GOTO   493
04DD:  GOTO   493
04DE:  GOTO   493
04DF:  GOTO   493
04E0:  GOTO   493
04E1:  GOTO   493
04E2:  GOTO   493
04E3:  GOTO   475
04E4:  GOTO   47A
04E5:  GOTO   47F
04E6:  GOTO   484
04E7:  GOTO   489
04E8:  GOTO   48E
04E9:  BCF    0A.0
04EA:  BCF    0A.1
04EB:  BSF    0A.2
04EC:  ADDWF  02,F
04ED:  GOTO   49B
04EE:  GOTO   4A0
04EF:  GOTO   4A5
04F0:  GOTO   4AA
....................  
.................... #list 
....................  
.................... #device ADC=16 
....................  
.................... #FUSES NOWDT                    // no Watch Dog Timer 
.................... #FUSES NOBROWNOUT               // no brownout reset 
.................... #FUSES NOLVP                    // no low voltage programming, B3(PIC16) or B5(PIC18) used for I/O 
....................  
.................... #use delay(crystal=20000000)  // external crystal clock 
....................  
.................... // I/O pin configurations 
.................... #use STANDARD_IO( B ) 
.................... #use FIXED_IO( B_outputs=PIN_B4,PIN_B5 ) 
.................... #use STANDARD_IO( D ) 
.................... #use FIXED_IO( D_outputs=PIN_D3,PIN_D1 ) 
....................  
.................... // Pin definitions 
.................... #define USER_LED     PIN_B4 
.................... #define COMMS_LED    PIN_B5 
.................... #define CS_PIN       PIN_D3  
....................  
.................... #define PWM1_PIN     PIN_C2 
.................... #define PWM2_PIN     PIN_C1 
.................... #define PWM3_PIN     PIN_E0 
.................... #define PWM4_PIN     PIN_D1 
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
0372:  MOVLB  02
0373:  MOVF   2E,W
0374:  MOVWF  7A
0375:  MOVF   2D,W
0376:  MOVWF  04
0377:  MOVF   7A,W
0378:  MOVWF  05
0379:  MOVF   00,W
037A:  MOVWF  31
037B:  MOVF   30,W
037C:  MOVWF  7A
037D:  MOVF   2F,W
037E:  MOVWF  04
037F:  MOVF   7A,W
0380:  MOVWF  05
0381:  MOVF   00,W
0382:  SUBWF  31,W
0383:  BTFSS  03.2
0384:  GOTO   39B
....................       if (*s1 == '\0') 
0385:  MOVF   2E,W
0386:  MOVWF  7A
0387:  MOVF   2D,W
0388:  MOVWF  04
0389:  MOVF   7A,W
038A:  MOVWF  05
038B:  MOVF   00,F
038C:  BTFSS  03.2
038D:  GOTO   391
....................          return(0); 
038E:  MOVLW  00
038F:  MOVWF  78
0390:  GOTO   3B1
0391:  MOVF   2E,W
0392:  MOVWF  7A
0393:  MOVF   2D,W
0394:  INCF   2D,F
0395:  BTFSC  03.2
0396:  INCF   2E,F
0397:  INCF   2F,F
0398:  BTFSC  03.2
0399:  INCF   30,F
039A:  GOTO   373
....................    return((*s1 < *s2) ? -1: 1); 
039B:  MOVF   2E,W
039C:  MOVWF  7A
039D:  MOVF   2D,W
039E:  MOVWF  04
039F:  MOVF   2E,W
03A0:  MOVWF  05
03A1:  MOVF   00,W
03A2:  MOVWF  31
03A3:  MOVF   30,W
03A4:  MOVWF  7A
03A5:  MOVF   2F,W
03A6:  MOVWF  04
03A7:  MOVF   30,W
03A8:  MOVWF  05
03A9:  MOVF   00,W
03AA:  SUBWF  31,W
03AB:  BTFSC  03.0
03AC:  GOTO   3AF
03AD:  MOVLW  FF
03AE:  GOTO   3B0
03AF:  MOVLW  01
03B0:  MOVWF  78
03B1:  MOVLB  00
03B2:  RETURN
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... //#define __DEBUG__ 
....................  
.................... // Configuration of communication peripherals 
.................... #use rs232(baud=9600,xmit=PIN_C6,rcv=PIN_C7,bits=8,parity=N) 
.................... #use SPI (MASTER, SPI1, BAUD=5000000, MODE=2, BITS=8, STREAM=SPI_1, MSB_FIRST) 
....................  
.................... // Define variables 
.................... unsigned int16 desired_anout1_value = 0x00; // 0x0000 - 0x03FF 
.................... unsigned int16 desired_anout2_value = 0x00; // 0x0000 - 0x03FF 
....................  
.................... unsigned int8 spi_dac_command_H = 0x00; //  CH1:1Y(0001-Y) / CH2:5Y(0101-Y) 
.................... unsigned int8 spi_dac_command_L = 0x00; //  YY(Y-HH00) 
....................  
.................... unsigned int16 pwm_counter = 0; // counter of timer2 timebase 
.................... unsigned int16 desired_pwm_period = 1316; // 0.02s - 50Hz 
....................  
.................... unsigned int16 desired_dutycycle_pwm1 = 0; // 0-100% 
.................... unsigned int16 desired_dutycycle_pwm2 = 0; // 0-100% 
.................... unsigned int16 desired_dutycycle_pwm3 = 0; // 0-100% 
.................... unsigned int16 desired_dutycycle_pwm4 = 0; // 0-100% 
....................  
.................... // Variables to UART communications 
.................... unsigned char char_received = 0; // variable to save chars received by UART 
....................  
.................... unsigned char rx_msg[20] = {0}; // buffer to receive UART messages 
.................... unsigned int8 index_rx_msg = 0; // index to manage the rx_msg buffer 
....................  
.................... unsigned char identifier_msg[10] = {0}; // buffer to receive UART messages 
.................... unsigned int8 index_identifier_msg = 0; // index to manage the identifier_msg buffer 
....................  
.................... unsigned int8 index_reader = 0; // to read received commands 
....................  
.................... char value_msg[5] = {0}; // buffer to save <value> messages 
.................... unsigned int8 index_value_msg = 0; // index to manage the value_msg buffer 
....................  
.................... char desired_pwm_channel = 0; // variable to save the desired pwm channel in the command 
.................... char desired_anout_channel = 0; // variable to save the desired anout channel in the command 
....................  
.................... // StateMachine to UART Protocol 
.................... enum UART_STATES 
.................... { 
....................    ST_WAIT = 0, 
....................    ST_A = 1, 
....................    ST_MSG = 2 
.................... } uart_state; 
....................  
.................... // UART commands identifiers 
.................... char CMD_1[10] = "ANOUT"; 
.................... char CMD_1_1[10] = "anout"; 
.................... char CMD_2[10] = "PWMPERIOD"; 
.................... char CMD_2_2[10] = "pwmperiod";   
.................... char CMD_3[10] = "PWMDUTY"; 
.................... char CMD_3_3[10] = "pwmduty"; 
.................... char CMD_4[10] = "ABOUT"; 
.................... char CMD_4_4[10] = "about"; 
.................... char CMD_5[10] = "HELP"; 
.................... char CMD_5_5[10] = "help"; 
....................  
.................... // Flags to manage events 
.................... volatile int8 NEW_MSG_RECEIVED_FLAG = false; 
....................  
....................  
.................... #INT_TIMER2 
.................... /* 
.................... * ISR Function to generate PWM timebase 
.................... */ 
.................... void ISR_Timer_2(void) 
.................... {    
....................    // set pwm period 
....................    if (pwm_counter == desired_pwm_period) 
*
0088:  MOVF   33,W
0089:  SUBWF  31,W
008A:  BTFSS  03.2
008B:  GOTO   093
008C:  MOVF   34,W
008D:  SUBWF  32,W
008E:  BTFSS  03.2
008F:  GOTO   093
....................    { 
....................       // reset the counter to get the desired period 
....................       pwm_counter = 0; 
0090:  CLRF   32
0091:  CLRF   31
....................    } 
0092:  GOTO   097
....................    else 
....................    { 
....................       // count timebase 
....................       pwm_counter += 1; 
0093:  MOVLW  01
0094:  ADDWF  31,F
0095:  MOVLW  00
0096:  ADDWFC 32,F
....................    } 
....................     
....................    // set pwm outputs 
....................    if (pwm_counter < (desired_pwm_period/100)*desired_dutycycle_pwm1) 
0097:  MOVF   34,W
0098:  MOVLB  02
0099:  MOVWF  40
009A:  MOVLB  00
009B:  MOVF   33,W
009C:  MOVLB  02
009D:  MOVWF  3F
009E:  CLRF   42
009F:  MOVLW  64
00A0:  MOVWF  41
00A1:  MOVLB  00
00A2:  CALL   04A
00A3:  MOVF   79,W
00A4:  MOVLB  02
00A5:  MOVWF  40
00A6:  MOVF   78,W
00A7:  MOVWF  3F
00A8:  MOVF   40,W
00A9:  MOVWF  42
00AA:  MOVF   3F,W
00AB:  MOVWF  41
00AC:  MOVLB  00
00AD:  MOVF   36,W
00AE:  MOVLB  02
00AF:  MOVWF  44
00B0:  MOVLB  00
00B1:  MOVF   35,W
00B2:  MOVLB  02
00B3:  MOVWF  43
00B4:  MOVLB  00
00B5:  CALL   071
00B6:  MOVF   79,W
00B7:  MOVWF  7A
00B8:  MOVF   32,W
00B9:  SUBWF  7A,W
00BA:  BTFSS  03.0
00BB:  GOTO   0C8
00BC:  BTFSS  03.2
00BD:  GOTO   0C2
00BE:  MOVF   78,W
00BF:  SUBWF  31,W
00C0:  BTFSC  03.0
00C1:  GOTO   0C8
....................    { 
....................       // activate pwm1 output 
....................       output_high(PWM1_PIN); 
00C2:  MOVLB  01
00C3:  BCF    0E.2
00C4:  MOVLB  02
00C5:  BSF    0E.2
....................    } 
00C6:  GOTO   0CC
00C7:  MOVLB  00
....................    else 
....................    { 
....................       output_low(PWM1_PIN); 
00C8:  MOVLB  01
00C9:  BCF    0E.2
00CA:  MOVLB  02
00CB:  BCF    0E.2
....................    } 
....................     
....................    if (pwm_counter < (desired_pwm_period/100)*desired_dutycycle_pwm2) 
00CC:  MOVLB  00
00CD:  MOVF   34,W
00CE:  MOVLB  02
00CF:  MOVWF  40
00D0:  MOVLB  00
00D1:  MOVF   33,W
00D2:  MOVLB  02
00D3:  MOVWF  3F
00D4:  CLRF   42
00D5:  MOVLW  64
00D6:  MOVWF  41
00D7:  MOVLB  00
00D8:  CALL   04A
00D9:  MOVF   79,W
00DA:  MOVLB  02
00DB:  MOVWF  40
00DC:  MOVF   78,W
00DD:  MOVWF  3F
00DE:  MOVF   40,W
00DF:  MOVWF  42
00E0:  MOVF   3F,W
00E1:  MOVWF  41
00E2:  MOVLB  00
00E3:  MOVF   38,W
00E4:  MOVLB  02
00E5:  MOVWF  44
00E6:  MOVLB  00
00E7:  MOVF   37,W
00E8:  MOVLB  02
00E9:  MOVWF  43
00EA:  MOVLB  00
00EB:  CALL   071
00EC:  MOVF   79,W
00ED:  MOVWF  7A
00EE:  MOVF   32,W
00EF:  SUBWF  7A,W
00F0:  BTFSS  03.0
00F1:  GOTO   0FE
00F2:  BTFSS  03.2
00F3:  GOTO   0F8
00F4:  MOVF   78,W
00F5:  SUBWF  31,W
00F6:  BTFSC  03.0
00F7:  GOTO   0FE
....................    { 
....................       // activate pwm2 output 
....................       output_high(PWM2_PIN); 
00F8:  MOVLB  01
00F9:  BCF    0E.1
00FA:  MOVLB  02
00FB:  BSF    0E.1
....................    } 
00FC:  GOTO   102
00FD:  MOVLB  00
....................    else 
....................    { 
....................       output_low(PWM2_PIN); 
00FE:  MOVLB  01
00FF:  BCF    0E.1
0100:  MOVLB  02
0101:  BCF    0E.1
....................    } 
....................     
....................    if (pwm_counter < (desired_pwm_period/100)*desired_dutycycle_pwm3) 
0102:  MOVLB  00
0103:  MOVF   34,W
0104:  MOVLB  02
0105:  MOVWF  40
0106:  MOVLB  00
0107:  MOVF   33,W
0108:  MOVLB  02
0109:  MOVWF  3F
010A:  CLRF   42
010B:  MOVLW  64
010C:  MOVWF  41
010D:  MOVLB  00
010E:  CALL   04A
010F:  MOVF   79,W
0110:  MOVLB  02
0111:  MOVWF  40
0112:  MOVF   78,W
0113:  MOVWF  3F
0114:  MOVF   40,W
0115:  MOVWF  42
0116:  MOVF   3F,W
0117:  MOVWF  41
0118:  MOVLB  00
0119:  MOVF   3A,W
011A:  MOVLB  02
011B:  MOVWF  44
011C:  MOVLB  00
011D:  MOVF   39,W
011E:  MOVLB  02
011F:  MOVWF  43
0120:  MOVLB  00
0121:  CALL   071
0122:  MOVF   79,W
0123:  MOVWF  7A
0124:  MOVF   32,W
0125:  SUBWF  7A,W
0126:  BTFSS  03.0
0127:  GOTO   134
0128:  BTFSS  03.2
0129:  GOTO   12E
012A:  MOVF   78,W
012B:  SUBWF  31,W
012C:  BTFSC  03.0
012D:  GOTO   134
....................    { 
....................       // activate pwm3 output 
....................       output_high(PWM3_PIN); 
012E:  MOVLB  01
012F:  BCF    10.0
0130:  MOVLB  02
0131:  BSF    10.0
....................    } 
0132:  GOTO   138
0133:  MOVLB  00
....................    else 
....................    { 
....................       output_low(PWM3_PIN); 
0134:  MOVLB  01
0135:  BCF    10.0
0136:  MOVLB  02
0137:  BCF    10.0
....................    } 
....................     
....................    if (pwm_counter < (desired_pwm_period/100)*desired_dutycycle_pwm4) 
0138:  MOVLB  00
0139:  MOVF   34,W
013A:  MOVLB  02
013B:  MOVWF  40
013C:  MOVLB  00
013D:  MOVF   33,W
013E:  MOVLB  02
013F:  MOVWF  3F
0140:  CLRF   42
0141:  MOVLW  64
0142:  MOVWF  41
0143:  MOVLB  00
0144:  CALL   04A
0145:  MOVF   79,W
0146:  MOVLB  02
0147:  MOVWF  40
0148:  MOVF   78,W
0149:  MOVWF  3F
014A:  MOVF   40,W
014B:  MOVWF  42
014C:  MOVF   3F,W
014D:  MOVWF  41
014E:  MOVLB  00
014F:  MOVF   3C,W
0150:  MOVLB  02
0151:  MOVWF  44
0152:  MOVLB  00
0153:  MOVF   3B,W
0154:  MOVLB  02
0155:  MOVWF  43
0156:  MOVLB  00
0157:  CALL   071
0158:  MOVF   79,W
0159:  MOVWF  7A
015A:  MOVF   32,W
015B:  SUBWF  7A,W
015C:  BTFSS  03.0
015D:  GOTO   16B
015E:  BTFSS  03.2
015F:  GOTO   164
0160:  MOVF   78,W
0161:  SUBWF  31,W
0162:  BTFSC  03.0
0163:  GOTO   16B
....................    { 
....................       // activate pwm4 output 
....................       output_high(PWM4_PIN); 
0164:  MOVLW  F5
0165:  MOVLB  01
0166:  MOVWF  0F
0167:  MOVLB  02
0168:  BSF    0F.1
....................    } 
0169:  GOTO   170
016A:  MOVLB  00
....................    else 
....................    { 
....................       output_low(PWM4_PIN); 
016B:  MOVLW  F5
016C:  MOVLB  01
016D:  MOVWF  0F
016E:  MOVLB  02
016F:  BCF    0F.1
....................    } 
.................... } 
....................  
....................  
0170:  MOVLB  00
0171:  BCF    11.1
0172:  MOVLP  00
0173:  GOTO   02D
.................... #INT_RDA 
.................... /* 
.................... * ISR Function to read UART messages 
.................... */ 
.................... void ISR_Receive_UART(void) 
.................... { 
....................    char_received = getc(); // read the received byte 
*
01C6:  BTFSS  11.5
01C7:  GOTO   1C6
01C8:  MOVLB  03
01C9:  MOVF   19,W
01CA:  MOVLB  00
01CB:  MOVWF  3D
....................     
....................    switch(uart_state) 
01CC:  MOVF   67,W
01CD:  BTFSC  03.2
01CE:  GOTO   1D6
01CF:  XORLW  01
01D0:  BTFSC  03.2
01D1:  GOTO   1EA
01D2:  XORLW  03
01D3:  BTFSC  03.2
01D4:  GOTO   1FE
01D5:  GOTO   214
....................    { 
....................       case ST_WAIT: // wait for AT command 
....................       { 
....................          if ( (char_received == 'A') || (char_received == 'a') ) 
01D6:  MOVF   3D,W
01D7:  SUBLW  41
01D8:  BTFSC  03.2
01D9:  GOTO   1DE
01DA:  MOVF   3D,W
01DB:  SUBLW  61
01DC:  BTFSS  03.2
01DD:  GOTO   1E1
....................          { 
....................             // next state 
....................             uart_state = ST_A; 
01DE:  MOVLW  01
01DF:  MOVWF  67
....................          } 
01E0:  GOTO   1E9
....................          else 
....................          { 
....................             // send error and continue in wait state 
....................             printf("ERROR\r\n"); 
01E1:  MOVLW  1E
01E2:  MOVLB  03
01E3:  MOVWF  11
01E4:  MOVLW  02
01E5:  MOVWF  12
01E6:  MOVLB  00
01E7:  CALL   174
....................             uart_state = ST_WAIT; 
01E8:  CLRF   67
....................          } 
....................           
....................          break; 
01E9:  GOTO   21B
....................       }; 
....................        
....................       case ST_A: // wait for AT command 
....................       { 
....................          if (char_received == 'T' || char_received == 't') 
01EA:  MOVF   3D,W
01EB:  SUBLW  54
01EC:  BTFSC  03.2
01ED:  GOTO   1F2
01EE:  MOVF   3D,W
01EF:  SUBLW  74
01F0:  BTFSS  03.2
01F1:  GOTO   1F5
....................          { 
....................             // next state 
....................             uart_state = ST_MSG; 
01F2:  MOVLW  02
01F3:  MOVWF  67
....................          } 
01F4:  GOTO   1FD
....................          else 
....................          { 
....................             // send error and return to wait state 
....................             printf("ERROR\r\n"); 
01F5:  MOVLW  22
01F6:  MOVLB  03
01F7:  MOVWF  11
01F8:  MOVLW  02
01F9:  MOVWF  12
01FA:  MOVLB  00
01FB:  CALL   174
....................             uart_state = ST_WAIT; 
01FC:  CLRF   67
....................          } 
....................           
....................          break; 
01FD:  GOTO   21B
....................       }; 
....................        
....................       case ST_MSG: 
....................       { 
....................          if (char_received == '\n') 
01FE:  MOVF   3D,W
01FF:  SUBLW  0A
0200:  BTFSS  03.2
0201:  GOTO   206
....................          { 
....................             // end of message flag 
....................             NEW_MSG_RECEIVED_FLAG = true; 
0202:  MOVLW  01
0203:  MOVWF  70
....................             // next state 
....................             uart_state = ST_WAIT;  
0204:  CLRF   67
....................          } 
0205:  GOTO   213
....................          else 
....................          { 
....................             // add character to buffer 
....................             rx_msg[index_rx_msg] = char_received; 
0206:  MOVLW  1E
0207:  ADDWF  52,W
0208:  MOVWF  04
0209:  MOVLW  20
020A:  MOVWF  05
020B:  BTFSC  03.0
020C:  INCF   05,F
020D:  MOVF   3D,W
020E:  MOVWF  00
....................             index_rx_msg += 1; 
020F:  MOVLW  01
0210:  ADDWF  52,F
....................             // next state 
....................             uart_state = ST_MSG;  
0211:  MOVLW  02
0212:  MOVWF  67
....................          } 
....................           
....................          break; 
0213:  GOTO   21B
....................       }; 
....................        
....................       default: 
....................       { 
....................          printf("ERROR\r\n"); 
0214:  MOVLW  26
0215:  MOVLB  03
0216:  MOVWF  11
0217:  MOVLW  02
0218:  MOVWF  12
0219:  MOVLB  00
021A:  CALL   174
....................          break; 
....................       }; 
....................    } 
021B:  BCF    11.5
021C:  MOVLP  00
021D:  GOTO   02D
.................... } 
....................  
....................  
.................... /* 
.................... * Function to calculate decimal numbers from hex char format 
.................... */ 
.................... int32 char_hex_to_dec(char car, int pos) 
*
0439:  MOVLB  02
043A:  CLRF   35
043B:  CLRF   34
043C:  CLRF   37
043D:  CLRF   36
043E:  CLRF   39
043F:  CLRF   38
.................... { 
....................    unsigned int16 ans = 0; 
....................    unsigned int16 base = 0; 
....................    unsigned int16 exp = 0; 
....................     
....................    switch (car) 
0440:  MOVLW  31
0441:  SUBWF  32,W
0442:  ADDLW  EA
0443:  BTFSC  03.0
0444:  GOTO   494
0445:  ADDLW  16
0446:  MOVLB  00
0447:  GOTO   4CF
....................    { 
....................       case '1': base = 1; 
0448:  MOVLB  02
0449:  CLRF   37
044A:  MOVLW  01
044B:  MOVWF  36
....................       break; 
044C:  GOTO   494
....................        
....................       case '2': base = 2; 
044D:  MOVLB  02
044E:  CLRF   37
044F:  MOVLW  02
0450:  MOVWF  36
....................       break; 
0451:  GOTO   494
....................        
....................       case '3': base = 3; 
0452:  MOVLB  02
0453:  CLRF   37
0454:  MOVLW  03
0455:  MOVWF  36
....................       break; 
0456:  GOTO   494
....................        
....................       case '4': base = 4; 
0457:  MOVLB  02
0458:  CLRF   37
0459:  MOVLW  04
045A:  MOVWF  36
....................       break; 
045B:  GOTO   494
....................        
....................       case '5': base = 5; 
045C:  MOVLB  02
045D:  CLRF   37
045E:  MOVLW  05
045F:  MOVWF  36
....................       break; 
0460:  GOTO   494
....................        
....................       case '6': base = 6; 
0461:  MOVLB  02
0462:  CLRF   37
0463:  MOVLW  06
0464:  MOVWF  36
....................       break; 
0465:  GOTO   494
....................        
....................       case '7': base = 7; 
0466:  MOVLB  02
0467:  CLRF   37
0468:  MOVLW  07
0469:  MOVWF  36
....................       break; 
046A:  GOTO   494
....................        
....................       case '8': base = 8; 
046B:  MOVLB  02
046C:  CLRF   37
046D:  MOVLW  08
046E:  MOVWF  36
....................       break; 
046F:  GOTO   494
....................        
....................       case '9': base = 9; 
0470:  MOVLB  02
0471:  CLRF   37
0472:  MOVLW  09
0473:  MOVWF  36
....................       break; 
0474:  GOTO   494
....................        
....................       case 'A': base = 10; 
0475:  MOVLB  02
0476:  CLRF   37
0477:  MOVLW  0A
0478:  MOVWF  36
....................       break; 
0479:  GOTO   494
....................        
....................       case 'B': base = 11; 
047A:  MOVLB  02
047B:  CLRF   37
047C:  MOVLW  0B
047D:  MOVWF  36
....................       break; 
047E:  GOTO   494
....................        
....................       case 'C': base = 12; 
047F:  MOVLB  02
0480:  CLRF   37
0481:  MOVLW  0C
0482:  MOVWF  36
....................       break; 
0483:  GOTO   494
....................        
....................       case 'D': base = 13; 
0484:  MOVLB  02
0485:  CLRF   37
0486:  MOVLW  0D
0487:  MOVWF  36
....................       break; 
0488:  GOTO   494
....................        
....................       case 'E': base = 14; 
0489:  MOVLB  02
048A:  CLRF   37
048B:  MOVLW  0E
048C:  MOVWF  36
....................       break; 
048D:  GOTO   494
....................        
....................       case 'F': base = 15; 
048E:  MOVLB  02
048F:  CLRF   37
0490:  MOVLW  0F
0491:  MOVWF  36
....................       break; 
0492:  GOTO   494
0493:  MOVLB  02
....................    } 
....................     
....................    switch (pos) 
0494:  MOVF   33,W
0495:  ADDLW  FC
0496:  BTFSC  03.0
0497:  GOTO   4B0
0498:  ADDLW  04
0499:  MOVLB  00
049A:  GOTO   4E9
....................    { 
....................       case 0: exp = 1; 
049B:  MOVLB  02
049C:  CLRF   39
049D:  MOVLW  01
049E:  MOVWF  38
....................       break; 
049F:  GOTO   4B0
....................        
....................       case 1: exp = 16; 
04A0:  MOVLB  02
04A1:  CLRF   39
04A2:  MOVLW  10
04A3:  MOVWF  38
....................       break; 
04A4:  GOTO   4B0
....................        
....................       case 2: exp = 256; 
04A5:  MOVLW  01
04A6:  MOVLB  02
04A7:  MOVWF  39
04A8:  CLRF   38
....................       break; 
04A9:  GOTO   4B0
....................        
....................       case 3: exp = 4096; 
04AA:  MOVLW  10
04AB:  MOVLB  02
04AC:  MOVWF  39
04AD:  CLRF   38
....................       break; 
04AE:  GOTO   4B0
04AF:  MOVLB  02
....................    } 
04B0:  MOVLB  00
04B1:  CLRF   28
04B2:  BTFSC  0B.7
04B3:  BSF    28.7
04B4:  BCF    0B.7
....................     
....................    ans = base*exp; 
04B5:  MOVLB  02
04B6:  MOVF   37,W
04B7:  MOVWF  42
04B8:  MOVF   36,W
04B9:  MOVWF  41
04BA:  MOVF   39,W
04BB:  MOVWF  44
04BC:  MOVF   38,W
04BD:  MOVWF  43
04BE:  MOVLB  00
04BF:  CALL   071
04C0:  BTFSC  28.7
04C1:  BSF    0B.7
04C2:  MOVF   79,W
04C3:  MOVLB  02
04C4:  MOVWF  35
04C5:  MOVF   78,W
04C6:  MOVWF  34
....................     
....................    return ans; 
04C7:  MOVF   34,W
04C8:  MOVWF  77
04C9:  MOVF   35,W
04CA:  MOVWF  78
04CB:  CLRF   79
04CC:  CLRF   7A
04CD:  MOVLB  00
04CE:  RETURN
.................... } 
....................  
....................  
.................... /* 
.................... * Function to manage SPI communication with DAC 
.................... */ 
.................... void Update_DAC_Output(int channel, unsigned int16 value) 
.................... { 
....................    output_low(CS_PIN); // to enable slave 
*
04F1:  MOVLW  F5
04F2:  MOVLB  01
04F3:  MOVWF  0F
04F4:  MOVLB  02
04F5:  BCF    0F.3
....................     
....................    if (channel == 1) 
04F6:  DECFSZ 30,W
04F7:  GOTO   524
....................    { 
....................       // to channel 1 
....................       spi_dac_command_H = 0x10 | (value >> 12)&0x0F; //  CH1:1Y(0001-Y) / CH2:5Y(0101-Y) 
04F8:  SWAPF  32,W
04F9:  MOVWF  33
04FA:  CLRF   34
04FB:  MOVLW  0F
04FC:  ANDWF  33,F
04FD:  MOVF   33,W
04FE:  ANDLW  0F
04FF:  MOVWF  77
0500:  CLRF   7A
0501:  MOVF   77,W
0502:  IORLW  10
0503:  MOVLB  00
0504:  MOVWF  2F
....................       spi_dac_command_L = (value << 2) & 0xFF; //  YY(Y-HH00) 
0505:  MOVLB  02
0506:  RLF    31,W
0507:  MOVWF  33
0508:  RLF    32,W
0509:  MOVWF  34
050A:  RLF    33,F
050B:  RLF    34,F
050C:  MOVLW  FC
050D:  ANDWF  33,F
050E:  MOVF   33,W
050F:  MOVLB  00
0510:  MOVWF  30
....................       spi_write(spi_dac_command_H); 
0511:  MOVLB  04
0512:  MOVF   11,W
0513:  MOVLB  00
0514:  MOVF   2F,W
0515:  MOVLB  04
0516:  MOVWF  11
0517:  RRF    14,W
0518:  BTFSS  03.0
0519:  GOTO   517
....................       spi_write(spi_dac_command_H); 
051A:  MOVF   11,W
051B:  MOVLB  00
051C:  MOVF   2F,W
051D:  MOVLB  04
051E:  MOVWF  11
051F:  RRF    14,W
0520:  BTFSS  03.0
0521:  GOTO   51F
....................    } 
0522:  GOTO   54E
0523:  MOVLB  02
....................    else // channel 2 
....................    { 
....................       // to channel 2 
....................       spi_dac_command_H = 0x50 | (value >> 12)&0x0F; //  CH1:1Y(0001-Y) / CH2:5Y(0101-Y) 
0524:  SWAPF  32,W
0525:  MOVWF  33
0526:  CLRF   34
0527:  MOVLW  0F
0528:  ANDWF  33,F
0529:  MOVF   33,W
052A:  ANDLW  0F
052B:  MOVWF  77
052C:  CLRF   7A
052D:  MOVF   77,W
052E:  IORLW  50
052F:  MOVLB  00
0530:  MOVWF  2F
....................       spi_dac_command_L = (value << 2) & 0xFF; //  YY(Y-HH00) 
0531:  MOVLB  02
0532:  RLF    31,W
0533:  MOVWF  33
0534:  RLF    32,W
0535:  MOVWF  34
0536:  RLF    33,F
0537:  RLF    34,F
0538:  MOVLW  FC
0539:  ANDWF  33,F
053A:  MOVF   33,W
053B:  MOVLB  00
053C:  MOVWF  30
....................       spi_write(spi_dac_command_H); 
053D:  MOVLB  04
053E:  MOVF   11,W
053F:  MOVLB  00
0540:  MOVF   2F,W
0541:  MOVLB  04
0542:  MOVWF  11
0543:  RRF    14,W
0544:  BTFSS  03.0
0545:  GOTO   543
....................       spi_write(spi_dac_command_H); 
0546:  MOVF   11,W
0547:  MOVLB  00
0548:  MOVF   2F,W
0549:  MOVLB  04
054A:  MOVWF  11
054B:  RRF    14,W
054C:  BTFSS  03.0
054D:  GOTO   54B
....................    } 
....................     
....................    output_high(CS_PIN); // to finish spi transaction 
054E:  MOVLW  F5
054F:  MOVLB  01
0550:  MOVWF  0F
0551:  MOVLB  02
0552:  BSF    0F.3
0553:  MOVLB  00
0554:  RETURN
.................... } 
....................  
....................  
.................... /* 
.................... * Function to manage ANOUT command 
.................... */ 
.................... void Manage_ANOUT_Command(void) 
0555:  MOVLB  02
0556:  CLRF   2D
.................... { 
....................    int8 i = 0; // general purpose index 
....................     
....................    if (rx_msg[index_reader] == '?') // case 2 of ANOUT command 
0557:  MOVLW  1E
0558:  MOVLB  00
0559:  ADDWF  5E,W
055A:  MOVWF  04
055B:  MOVLW  20
055C:  MOVWF  05
055D:  BTFSC  03.0
055E:  INCF   05,F
055F:  MOVF   00,W
0560:  SUBLW  3F
0561:  BTFSS  03.2
0562:  GOTO   5BC
....................    { 
....................       // answer the command 
....................       printf("+PWMDUTY:1,%X%X,2,%X%X\r\n", (int)(desired_anout1_value>>8), (int)(desired_anout1_value),  
....................                                            (int)(desired_anout2_value>>8), (int)(desired_anout2_value)); 
0563:  MOVF   2C,W
0564:  CLRF   7A
0565:  MOVLB  02
0566:  MOVWF  30
0567:  MOVLB  00
0568:  MOVF   2E,W
0569:  CLRF   7A
056A:  MOVLB  02
056B:  MOVWF  31
056C:  MOVLW  2A
056D:  MOVLB  03
056E:  MOVWF  11
056F:  MOVLW  02
0570:  MOVWF  12
0571:  BCF    03.0
0572:  MOVLW  0B
0573:  MOVLB  02
0574:  MOVWF  34
0575:  MOVLB  00
0576:  CALL   3B3
0577:  MOVLB  02
0578:  MOVF   30,W
0579:  MOVWF  34
057A:  MOVLW  37
057B:  MOVWF  35
057C:  MOVLB  00
057D:  CALL   40F
057E:  MOVF   2B,W
057F:  MOVLB  02
0580:  MOVWF  34
0581:  MOVLW  37
0582:  MOVWF  35
0583:  MOVLB  00
0584:  CALL   40F
0585:  MOVLW  2C
0586:  BTFSS  11.4
0587:  GOTO   586
0588:  MOVLB  03
0589:  MOVWF  1A
058A:  MOVLW  32
058B:  MOVLB  00
058C:  BTFSS  11.4
058D:  GOTO   58C
058E:  MOVLB  03
058F:  MOVWF  1A
0590:  MOVLW  2C
0591:  MOVLB  00
0592:  BTFSS  11.4
0593:  GOTO   592
0594:  MOVLB  03
0595:  MOVWF  1A
0596:  MOVLB  02
0597:  MOVF   31,W
0598:  MOVWF  34
0599:  MOVLW  37
059A:  MOVWF  35
059B:  MOVLB  00
059C:  CALL   40F
059D:  MOVF   2D,W
059E:  MOVLB  02
059F:  MOVWF  34
05A0:  MOVLW  37
05A1:  MOVWF  35
05A2:  MOVLB  00
05A3:  CALL   40F
05A4:  MOVLW  0D
05A5:  BTFSS  11.4
05A6:  GOTO   5A5
05A7:  MOVLB  03
05A8:  MOVWF  1A
05A9:  MOVLW  0A
05AA:  MOVLB  00
05AB:  BTFSS  11.4
05AC:  GOTO   5AB
05AD:  MOVLB  03
05AE:  MOVWF  1A
....................       printf("OK\r\n"); 
05AF:  MOVLW  37
05B0:  MOVWF  11
05B1:  MOVLW  02
05B2:  MOVWF  12
05B3:  MOVLB  00
05B4:  CLRF   28
05B5:  BTFSC  0B.7
05B6:  BSF    28.7
05B7:  BCF    0B.7
05B8:  CALL   174
05B9:  BTFSC  28.7
05BA:  BSF    0B.7
....................    } 
05BB:  GOTO   70E
....................    else if ((rx_msg[index_reader] == '=') && (rx_msg[index_reader+2] == '?')) // case 3 of ANOUT command 
05BC:  MOVLW  1E
05BD:  ADDWF  5E,W
05BE:  MOVWF  04
05BF:  MOVLW  20
05C0:  MOVWF  05
05C1:  BTFSC  03.0
05C2:  INCF   05,F
05C3:  MOVF   00,W
05C4:  SUBLW  3D
05C5:  BTFSS  03.2
05C6:  GOTO   649
05C7:  MOVLW  02
05C8:  ADDWF  5E,W
05C9:  ADDLW  1E
05CA:  MOVWF  04
05CB:  MOVLW  20
05CC:  MOVWF  05
05CD:  BTFSC  03.0
05CE:  INCF   05,F
05CF:  MOVF   00,W
05D0:  SUBLW  3F
05D1:  BTFSS  03.2
05D2:  GOTO   649
....................    { 
....................       // read the channel 
....................       desired_anout_channel = rx_msg[index_reader+1]; 
05D3:  MOVLW  01
05D4:  ADDWF  5E,W
05D5:  ADDLW  1E
05D6:  MOVWF  04
05D7:  MOVLW  20
05D8:  MOVWF  05
05D9:  BTFSC  03.0
05DA:  INCF   05,F
05DB:  MOVF   00,W
05DC:  MOVWF  66
....................        
....................       // answer the command 
....................       if (desired_anout_channel == '1') 
05DD:  MOVF   66,W
05DE:  SUBLW  31
05DF:  BTFSS  03.2
05E0:  GOTO   60B
....................       { 
....................          printf("+ANOUT1:%X%X\r\n", (int)(desired_anout1_value>>8), (int)(desired_anout1_value)); 
05E1:  MOVF   2C,W
05E2:  CLRF   7A
05E3:  MOVLB  02
05E4:  MOVWF  30
05E5:  MOVLW  3A
05E6:  MOVLB  03
05E7:  MOVWF  11
05E8:  MOVLW  02
05E9:  MOVWF  12
05EA:  BCF    03.0
05EB:  MOVLW  08
05EC:  MOVLB  02
05ED:  MOVWF  34
05EE:  MOVLB  00
05EF:  CALL   3B3
05F0:  MOVLB  02
05F1:  MOVF   30,W
05F2:  MOVWF  34
05F3:  MOVLW  37
05F4:  MOVWF  35
05F5:  MOVLB  00
05F6:  CALL   40F
05F7:  MOVF   2B,W
05F8:  MOVLB  02
05F9:  MOVWF  34
05FA:  MOVLW  37
05FB:  MOVWF  35
05FC:  MOVLB  00
05FD:  CALL   40F
05FE:  MOVLW  0D
05FF:  BTFSS  11.4
0600:  GOTO   5FF
0601:  MOVLB  03
0602:  MOVWF  1A
0603:  MOVLW  0A
0604:  MOVLB  00
0605:  BTFSS  11.4
0606:  GOTO   605
0607:  MOVLB  03
0608:  MOVWF  1A
....................       } 
0609:  GOTO   647
060A:  MOVLB  00
....................       else if (desired_anout_channel == '2') 
060B:  MOVF   66,W
060C:  SUBLW  32
060D:  BTFSS  03.2
060E:  GOTO   639
....................       { 
....................          printf("+ANOUT2:%X%X\r\n", (int)(desired_anout2_value>>8), (int)(desired_anout2_value)); 
060F:  MOVF   2E,W
0610:  CLRF   7A
0611:  MOVLB  02
0612:  MOVWF  30
0613:  MOVLW  42
0614:  MOVLB  03
0615:  MOVWF  11
0616:  MOVLW  02
0617:  MOVWF  12
0618:  BCF    03.0
0619:  MOVLW  08
061A:  MOVLB  02
061B:  MOVWF  34
061C:  MOVLB  00
061D:  CALL   3B3
061E:  MOVLB  02
061F:  MOVF   30,W
0620:  MOVWF  34
0621:  MOVLW  37
0622:  MOVWF  35
0623:  MOVLB  00
0624:  CALL   40F
0625:  MOVF   2D,W
0626:  MOVLB  02
0627:  MOVWF  34
0628:  MOVLW  37
0629:  MOVWF  35
062A:  MOVLB  00
062B:  CALL   40F
062C:  MOVLW  0D
062D:  BTFSS  11.4
062E:  GOTO   62D
062F:  MOVLB  03
0630:  MOVWF  1A
0631:  MOVLW  0A
0632:  MOVLB  00
0633:  BTFSS  11.4
0634:  GOTO   633
0635:  MOVLB  03
0636:  MOVWF  1A
....................       } 
0637:  GOTO   647
0638:  MOVLB  00
....................       else 
....................       { 
....................          // the command is not recognized 
....................          printf("ERROR\r\n"); 
0639:  MOVLW  4A
063A:  MOVLB  03
063B:  MOVWF  11
063C:  MOVLW  02
063D:  MOVWF  12
063E:  MOVLB  00
063F:  CLRF   28
0640:  BTFSC  0B.7
0641:  BSF    28.7
0642:  BCF    0B.7
0643:  CALL   174
0644:  BTFSC  28.7
0645:  BSF    0B.7
0646:  MOVLB  03
....................       } 
....................    } 
0647:  GOTO   70F
0648:  MOVLB  00
....................    else if (rx_msg[index_reader] == '=') // case 1 of ANOUT command 
0649:  MOVLW  1E
064A:  ADDWF  5E,W
064B:  MOVWF  04
064C:  MOVLW  20
064D:  MOVWF  05
064E:  BTFSC  03.0
064F:  INCF   05,F
0650:  MOVF   00,W
0651:  SUBLW  3D
0652:  BTFSS  03.2
0653:  GOTO   701
....................    { 
....................       // read the channel 
....................       desired_anout_channel = rx_msg[index_reader+1]; 
0654:  MOVLW  01
0655:  ADDWF  5E,W
0656:  ADDLW  1E
0657:  MOVWF  04
0658:  MOVLW  20
0659:  MOVWF  05
065A:  BTFSC  03.0
065B:  INCF   05,F
065C:  MOVF   00,W
065D:  MOVWF  66
....................        
....................       // read the value 
....................       for (i = index_reader+3; i < index_rx_msg; i++) 
065E:  MOVLW  03
065F:  ADDWF  5E,W
0660:  MOVLB  02
0661:  MOVWF  2D
0662:  MOVLB  00
0663:  MOVF   52,W
0664:  MOVLB  02
0665:  SUBWF  2D,W
0666:  BTFSC  03.0
0667:  GOTO   68A
....................       { 
....................          // add character to value buffer 
....................          value_msg[index_value_msg] = rx_msg[i]; 
0668:  MOVLW  3F
0669:  MOVLB  00
066A:  ADDWF  64,W
066B:  MOVWF  78
066C:  MOVLW  20
066D:  MOVWF  7A
066E:  BTFSC  03.0
066F:  INCF   7A,F
0670:  MOVF   78,W
0671:  MOVLB  02
0672:  MOVWF  30
0673:  MOVF   7A,W
0674:  MOVWF  31
0675:  MOVLW  1E
0676:  ADDWF  2D,W
0677:  MOVWF  04
0678:  MOVLW  20
0679:  MOVWF  05
067A:  BTFSC  03.0
067B:  INCF   05,F
067C:  MOVF   00,W
067D:  MOVWF  32
067E:  MOVF   31,W
067F:  MOVWF  05
0680:  MOVF   30,W
0681:  MOVWF  04
0682:  MOVF   32,W
0683:  MOVWF  00
....................          index_value_msg += 1; 
0684:  MOVLW  01
0685:  MOVLB  00
0686:  ADDWF  64,F
0687:  MOVLB  02
0688:  INCF   2D,F
0689:  GOTO   662
....................       } 
....................        
....................       // end of value (read buffer to get the number) 
....................       unsigned int16 temp_desired_anout = 0; 
068A:  CLRF   2F
068B:  CLRF   2E
....................       for (i = 0; i < index_value_msg; i++) 
068C:  CLRF   2D
068D:  MOVLB  00
068E:  MOVF   64,W
068F:  MOVLB  02
0690:  SUBWF  2D,W
0691:  BTFSC  03.0
0692:  GOTO   6B1
....................       { 
....................          temp_desired_anout += char_hex_to_dec(value_msg[i],index_value_msg-2-i); 
0693:  MOVLW  3F
0694:  ADDWF  2D,W
0695:  MOVWF  04
0696:  MOVLW  20
0697:  MOVWF  05
0698:  BTFSC  03.0
0699:  INCF   05,F
069A:  MOVF   00,W
069B:  MOVWF  30
069C:  MOVLW  02
069D:  MOVLB  00
069E:  SUBWF  64,W
069F:  MOVWF  78
06A0:  MOVLB  02
06A1:  MOVF   2D,W
06A2:  SUBWF  78,W
06A3:  MOVWF  31
06A4:  MOVF   30,W
06A5:  MOVWF  32
06A6:  MOVF   31,W
06A7:  MOVWF  33
06A8:  MOVLB  00
06A9:  CALL   439
06AA:  MOVF   77,W
06AB:  MOVLB  02
06AC:  ADDWF  2E,F
06AD:  MOVF   78,W
06AE:  ADDWFC 2F,F
06AF:  INCF   2D,F
06B0:  GOTO   68D
....................       } 
....................        
....................       // answer the command 
....................       if (desired_anout_channel == '1') 
06B1:  MOVLB  00
06B2:  MOVF   66,W
06B3:  SUBLW  31
06B4:  BTFSS  03.2
06B5:  GOTO   6CC
....................       { 
....................          desired_anout1_value = temp_desired_anout; // assig final value of ANOUT 
06B6:  MOVLB  02
06B7:  MOVF   2F,W
06B8:  MOVLB  00
06B9:  MOVWF  2C
06BA:  MOVLB  02
06BB:  MOVF   2E,W
06BC:  MOVLB  00
06BD:  MOVWF  2B
....................          Update_DAC_Output(1, desired_anout1_value); 
06BE:  MOVLW  01
06BF:  MOVLB  02
06C0:  MOVWF  30
06C1:  MOVLB  00
06C2:  MOVF   2C,W
06C3:  MOVLB  02
06C4:  MOVWF  32
06C5:  MOVLB  00
06C6:  MOVF   2B,W
06C7:  MOVLB  02
06C8:  MOVWF  31
06C9:  MOVLB  00
06CA:  CALL   4F1
....................       } 
06CB:  GOTO   6F3
....................       else if (desired_anout_channel == '2') 
06CC:  MOVF   66,W
06CD:  SUBLW  32
06CE:  BTFSS  03.2
06CF:  GOTO   6E6
....................       { 
....................          desired_anout2_value = temp_desired_anout; // assig final value of ANOUT 
06D0:  MOVLB  02
06D1:  MOVF   2F,W
06D2:  MOVLB  00
06D3:  MOVWF  2E
06D4:  MOVLB  02
06D5:  MOVF   2E,W
06D6:  MOVLB  00
06D7:  MOVWF  2D
....................          Update_DAC_Output(2, desired_anout2_value); 
06D8:  MOVLW  02
06D9:  MOVLB  02
06DA:  MOVWF  30
06DB:  MOVLB  00
06DC:  MOVF   2E,W
06DD:  MOVLB  02
06DE:  MOVWF  32
06DF:  MOVLB  00
06E0:  MOVF   2D,W
06E1:  MOVLB  02
06E2:  MOVWF  31
06E3:  MOVLB  00
06E4:  CALL   4F1
....................       } 
06E5:  GOTO   6F3
....................       else 
....................       { 
....................          // the command is not recognized 
....................          printf("ERROR\r\n"); 
06E6:  MOVLW  4E
06E7:  MOVLB  03
06E8:  MOVWF  11
06E9:  MOVLW  02
06EA:  MOVWF  12
06EB:  MOVLB  00
06EC:  CLRF   28
06ED:  BTFSC  0B.7
06EE:  BSF    28.7
06EF:  BCF    0B.7
06F0:  CALL   174
06F1:  BTFSC  28.7
06F2:  BSF    0B.7
....................       } 
....................        
....................       printf("OK\r\n"); 
06F3:  MOVLW  52
06F4:  MOVLB  03
06F5:  MOVWF  11
06F6:  MOVLW  02
06F7:  MOVWF  12
06F8:  MOVLB  00
06F9:  CLRF   28
06FA:  BTFSC  0B.7
06FB:  BSF    28.7
06FC:  BCF    0B.7
06FD:  CALL   174
06FE:  BTFSC  28.7
06FF:  BSF    0B.7
....................    } 
0700:  GOTO   70E
....................    else 
....................    { 
....................       // the command is not recognized 
....................       printf("ERROR\r\n"); 
0701:  MOVLW  55
0702:  MOVLB  03
0703:  MOVWF  11
0704:  MOVLW  02
0705:  MOVWF  12
0706:  MOVLB  00
0707:  CLRF   28
0708:  BTFSC  0B.7
0709:  BSF    28.7
070A:  BCF    0B.7
070B:  CALL   174
070C:  BTFSC  28.7
070D:  BSF    0B.7
070E:  MOVLB  03
....................    }    
070F:  MOVLP  08
0710:  MOVLB  00
0711:  GOTO   564 (RETURN)
.................... } 
....................  
....................  
.................... /* 
.................... * Function to manage PWMPERIOD command 
.................... */ 
.................... void Manage_PWMPERIOD_Command(void) 
*
0800:  MOVLB  02
0801:  CLRF   2D
.................... { 
....................    int8 i = 0; // general purpose index 
....................  
....................    if (rx_msg[index_reader] == '?') // case 2 of PWMPERIOD command 
0802:  MOVLW  1E
0803:  MOVLB  00
0804:  ADDWF  5E,W
0805:  MOVWF  04
0806:  MOVLW  20
0807:  MOVWF  05
0808:  BTFSC  03.0
0809:  INCF   05,F
080A:  MOVF   00,W
080B:  SUBLW  3F
080C:  BTFSS  03.2
080D:  GOTO   04B
....................    { 
....................       // answer the command 
....................       printf("+PWMPERIOD:%X%X\r\n", (int)(desired_pwm_period>>8), (int)(desired_pwm_period)); 
080E:  MOVF   34,W
080F:  CLRF   7A
0810:  MOVLB  02
0811:  MOVWF  30
0812:  MOVLW  59
0813:  MOVLB  03
0814:  MOVWF  11
0815:  MOVLW  02
0816:  MOVWF  12
0817:  BCF    03.0
0818:  MOVLW  0B
0819:  MOVLB  02
081A:  MOVWF  34
081B:  MOVLP  00
081C:  MOVLB  00
081D:  CALL   3B3
081E:  MOVLP  08
081F:  MOVLB  02
0820:  MOVF   30,W
0821:  MOVWF  34
0822:  MOVLW  37
0823:  MOVWF  35
0824:  MOVLP  00
0825:  MOVLB  00
0826:  CALL   40F
0827:  MOVLP  08
0828:  MOVF   33,W
0829:  MOVLB  02
082A:  MOVWF  34
082B:  MOVLW  37
082C:  MOVWF  35
082D:  MOVLP  00
082E:  MOVLB  00
082F:  CALL   40F
0830:  MOVLP  08
0831:  MOVLW  0D
0832:  BTFSS  11.4
0833:  GOTO   032
0834:  MOVLB  03
0835:  MOVWF  1A
0836:  MOVLW  0A
0837:  MOVLB  00
0838:  BTFSS  11.4
0839:  GOTO   038
083A:  MOVLB  03
083B:  MOVWF  1A
....................       printf("OK\r\n"); 
083C:  MOVLW  62
083D:  MOVWF  11
083E:  MOVLW  02
083F:  MOVWF  12
0840:  MOVLB  00
0841:  CLRF   28
0842:  BTFSC  0B.7
0843:  BSF    28.7
0844:  BCF    0B.7
0845:  MOVLP  00
0846:  CALL   174
0847:  MOVLP  08
0848:  BTFSC  28.7
0849:  BSF    0B.7
....................    } 
084A:  GOTO   114
....................    else if ((rx_msg[index_reader] == '=') && (rx_msg[index_reader+1] == '?')) // case 3 of PWMPERIOD command 
084B:  MOVLW  1E
084C:  ADDWF  5E,W
084D:  MOVWF  04
084E:  MOVLW  20
084F:  MOVWF  05
0850:  BTFSC  03.0
0851:  INCF   05,F
0852:  MOVF   00,W
0853:  SUBLW  3D
0854:  BTFSS  03.2
0855:  GOTO   092
0856:  MOVLW  01
0857:  ADDWF  5E,W
0858:  ADDLW  1E
0859:  MOVWF  04
085A:  MOVLW  20
085B:  MOVWF  05
085C:  BTFSC  03.0
085D:  INCF   05,F
085E:  MOVF   00,W
085F:  SUBLW  3F
0860:  BTFSS  03.2
0861:  GOTO   092
....................    { 
....................       // answer the command 
....................       printf("+PWMPERIOD:%X%X\r\n", (int)(desired_pwm_period>>8), (int)(desired_pwm_period)); 
0862:  MOVF   34,W
0863:  CLRF   7A
0864:  MOVLB  02
0865:  MOVWF  30
0866:  MOVLW  65
0867:  MOVLB  03
0868:  MOVWF  11
0869:  MOVLW  02
086A:  MOVWF  12
086B:  BCF    03.0
086C:  MOVLW  0B
086D:  MOVLB  02
086E:  MOVWF  34
086F:  MOVLP  00
0870:  MOVLB  00
0871:  CALL   3B3
0872:  MOVLP  08
0873:  MOVLB  02
0874:  MOVF   30,W
0875:  MOVWF  34
0876:  MOVLW  37
0877:  MOVWF  35
0878:  MOVLP  00
0879:  MOVLB  00
087A:  CALL   40F
087B:  MOVLP  08
087C:  MOVF   33,W
087D:  MOVLB  02
087E:  MOVWF  34
087F:  MOVLW  37
0880:  MOVWF  35
0881:  MOVLP  00
0882:  MOVLB  00
0883:  CALL   40F
0884:  MOVLP  08
0885:  MOVLW  0D
0886:  BTFSS  11.4
0887:  GOTO   086
0888:  MOVLB  03
0889:  MOVWF  1A
088A:  MOVLW  0A
088B:  MOVLB  00
088C:  BTFSS  11.4
088D:  GOTO   08C
088E:  MOVLB  03
088F:  MOVWF  1A
....................    } 
0890:  GOTO   115
0891:  MOVLB  00
....................    else if (rx_msg[index_reader] == '=') // case 1 of PWMPERIOD command 
0892:  MOVLW  1E
0893:  ADDWF  5E,W
0894:  MOVWF  04
0895:  MOVLW  20
0896:  MOVWF  05
0897:  BTFSC  03.0
0898:  INCF   05,F
0899:  MOVF   00,W
089A:  SUBLW  3D
089B:  BTFSS  03.2
089C:  GOTO   105
....................    { 
....................       // read the value 
....................       for (i = index_reader+1; i < index_rx_msg; i++) 
089D:  MOVLW  01
089E:  ADDWF  5E,W
089F:  MOVLB  02
08A0:  MOVWF  2D
08A1:  MOVLB  00
08A2:  MOVF   52,W
08A3:  MOVLB  02
08A4:  SUBWF  2D,W
08A5:  BTFSC  03.0
08A6:  GOTO   0C5
....................       { 
....................          // add character to value buffer 
....................          value_msg[index_value_msg] = rx_msg[i]; 
08A7:  MOVLW  3F
08A8:  MOVLB  00
08A9:  ADDWF  64,W
08AA:  MOVLB  02
08AB:  MOVWF  30
08AC:  MOVLW  20
08AD:  MOVWF  31
08AE:  BTFSC  03.0
08AF:  INCF   31,F
08B0:  MOVLW  1E
08B1:  ADDWF  2D,W
08B2:  MOVWF  04
08B3:  MOVLW  20
08B4:  MOVWF  05
08B5:  BTFSC  03.0
08B6:  INCF   05,F
08B7:  MOVF   00,W
08B8:  MOVWF  32
08B9:  MOVF   31,W
08BA:  MOVWF  05
08BB:  MOVF   30,W
08BC:  MOVWF  04
08BD:  MOVF   32,W
08BE:  MOVWF  00
....................          index_value_msg += 1; 
08BF:  MOVLW  01
08C0:  MOVLB  00
08C1:  ADDWF  64,F
08C2:  MOVLB  02
08C3:  INCF   2D,F
08C4:  GOTO   0A1
....................       } 
....................        
....................       // end of value (read buffer to get the number) 
....................       unsigned int16 temp_desired_pwm_period = 0; 
08C5:  CLRF   2F
08C6:  CLRF   2E
....................       for (i = 0; i < index_value_msg; i++) 
08C7:  CLRF   2D
08C8:  MOVLB  00
08C9:  MOVF   64,W
08CA:  MOVLB  02
08CB:  SUBWF  2D,W
08CC:  BTFSC  03.0
08CD:  GOTO   0EE
....................       { 
....................          temp_desired_pwm_period += char_hex_to_dec(value_msg[i],index_value_msg-2-i); 
08CE:  MOVLW  3F
08CF:  ADDWF  2D,W
08D0:  MOVWF  04
08D1:  MOVLW  20
08D2:  MOVWF  05
08D3:  BTFSC  03.0
08D4:  INCF   05,F
08D5:  MOVF   00,W
08D6:  MOVWF  30
08D7:  MOVLW  02
08D8:  MOVLB  00
08D9:  SUBWF  64,W
08DA:  MOVWF  78
08DB:  MOVLB  02
08DC:  MOVF   2D,W
08DD:  SUBWF  78,W
08DE:  MOVWF  31
08DF:  MOVF   30,W
08E0:  MOVWF  32
08E1:  MOVF   31,W
08E2:  MOVWF  33
08E3:  MOVLP  00
08E4:  MOVLB  00
08E5:  CALL   439
08E6:  MOVLP  08
08E7:  MOVF   77,W
08E8:  MOVLB  02
08E9:  ADDWF  2E,F
08EA:  MOVF   78,W
08EB:  ADDWFC 2F,F
08EC:  INCF   2D,F
08ED:  GOTO   0C8
....................       } 
....................       desired_pwm_period = temp_desired_pwm_period; // assig final value of PWM period 
08EE:  MOVF   2F,W
08EF:  MOVLB  00
08F0:  MOVWF  34
08F1:  MOVLB  02
08F2:  MOVF   2E,W
08F3:  MOVLB  00
08F4:  MOVWF  33
....................       printf("OK\r\n"); 
08F5:  MOVLW  6E
08F6:  MOVLB  03
08F7:  MOVWF  11
08F8:  MOVLW  02
08F9:  MOVWF  12
08FA:  MOVLB  00
08FB:  CLRF   28
08FC:  BTFSC  0B.7
08FD:  BSF    28.7
08FE:  BCF    0B.7
08FF:  MOVLP  00
0900:  CALL   174
0901:  MOVLP  08
0902:  BTFSC  28.7
0903:  BSF    0B.7
....................    } 
0904:  GOTO   114
....................    else 
....................    { 
....................       // the command is not recognized 
....................       printf("ERROR\r\n"); 
0905:  MOVLW  71
0906:  MOVLB  03
0907:  MOVWF  11
0908:  MOVLW  02
0909:  MOVWF  12
090A:  MOVLB  00
090B:  CLRF   28
090C:  BTFSC  0B.7
090D:  BSF    28.7
090E:  BCF    0B.7
090F:  MOVLP  00
0910:  CALL   174
0911:  MOVLP  08
0912:  BTFSC  28.7
0913:  BSF    0B.7
0914:  MOVLB  03
....................    } 
0915:  MOVLP  08
0916:  MOVLB  00
0917:  GOTO   587 (RETURN)
.................... } 
....................  
....................  
.................... /* 
.................... * Function to manage PWMDUTY command 
.................... */ 
.................... void Manage_PWMDUTY_Command(void) 
0918:  MOVLB  02
0919:  CLRF   2D
.................... { 
....................    int8 i = 0; // general purpose index 
....................  
....................    if (rx_msg[index_reader] == '?') // case 2 of PWMDUTY command 
091A:  MOVLW  1E
091B:  MOVLB  00
091C:  ADDWF  5E,W
091D:  MOVWF  04
091E:  MOVLW  20
091F:  MOVWF  05
0920:  BTFSC  03.0
0921:  INCF   05,F
0922:  MOVF   00,W
0923:  SUBLW  3F
0924:  BTFSS  03.2
0925:  GOTO   1DB
....................    { 
....................       // answer the command 
....................       printf("+PWMDUTY:1,%X%X,2,%X%X,3,%X%X,4,%X%X\r\n", (int)(desired_dutycycle_pwm1>>8), (int)(desired_dutycycle_pwm1),  
....................                                                          (int)(desired_dutycycle_pwm2>>8), (int)(desired_dutycycle_pwm2), 
....................                                                          (int)(desired_dutycycle_pwm3>>8), (int)(desired_dutycycle_pwm3), 
....................                                                          (int)(desired_dutycycle_pwm4>>8), (int)(desired_dutycycle_pwm4)); 
0926:  MOVF   36,W
0927:  CLRF   7A
0928:  MOVLB  02
0929:  MOVWF  30
092A:  MOVLB  00
092B:  MOVF   38,W
092C:  CLRF   7A
092D:  MOVLB  02
092E:  MOVWF  31
092F:  MOVLB  00
0930:  MOVF   3A,W
0931:  CLRF   7A
0932:  MOVLB  02
0933:  MOVWF  32
0934:  MOVLB  00
0935:  MOVF   3C,W
0936:  CLRF   7A
0937:  MOVLB  02
0938:  MOVWF  33
0939:  MOVLW  75
093A:  MOVLB  03
093B:  MOVWF  11
093C:  MOVLW  02
093D:  MOVWF  12
093E:  BCF    03.0
093F:  MOVLW  0B
0940:  MOVLB  02
0941:  MOVWF  34
0942:  MOVLP  00
0943:  MOVLB  00
0944:  CALL   3B3
0945:  MOVLP  08
0946:  MOVLB  02
0947:  MOVF   30,W
0948:  MOVWF  34
0949:  MOVLW  37
094A:  MOVWF  35
094B:  MOVLP  00
094C:  MOVLB  00
094D:  CALL   40F
094E:  MOVLP  08
094F:  MOVF   35,W
0950:  MOVLB  02
0951:  MOVWF  34
0952:  MOVLW  37
0953:  MOVWF  35
0954:  MOVLP  00
0955:  MOVLB  00
0956:  CALL   40F
0957:  MOVLP  08
0958:  MOVLW  2C
0959:  BTFSS  11.4
095A:  GOTO   159
095B:  MOVLB  03
095C:  MOVWF  1A
095D:  MOVLW  32
095E:  MOVLB  00
095F:  BTFSS  11.4
0960:  GOTO   15F
0961:  MOVLB  03
0962:  MOVWF  1A
0963:  MOVLW  2C
0964:  MOVLB  00
0965:  BTFSS  11.4
0966:  GOTO   165
0967:  MOVLB  03
0968:  MOVWF  1A
0969:  MOVLB  02
096A:  MOVF   31,W
096B:  MOVWF  34
096C:  MOVLW  37
096D:  MOVWF  35
096E:  MOVLP  00
096F:  MOVLB  00
0970:  CALL   40F
0971:  MOVLP  08
0972:  MOVF   37,W
0973:  MOVLB  02
0974:  MOVWF  34
0975:  MOVLW  37
0976:  MOVWF  35
0977:  MOVLP  00
0978:  MOVLB  00
0979:  CALL   40F
097A:  MOVLP  08
097B:  MOVLW  2C
097C:  BTFSS  11.4
097D:  GOTO   17C
097E:  MOVLB  03
097F:  MOVWF  1A
0980:  MOVLW  33
0981:  MOVLB  00
0982:  BTFSS  11.4
0983:  GOTO   182
0984:  MOVLB  03
0985:  MOVWF  1A
0986:  MOVLW  2C
0987:  MOVLB  00
0988:  BTFSS  11.4
0989:  GOTO   188
098A:  MOVLB  03
098B:  MOVWF  1A
098C:  MOVLB  02
098D:  MOVF   32,W
098E:  MOVWF  34
098F:  MOVLW  37
0990:  MOVWF  35
0991:  MOVLP  00
0992:  MOVLB  00
0993:  CALL   40F
0994:  MOVLP  08
0995:  MOVF   39,W
0996:  MOVLB  02
0997:  MOVWF  34
0998:  MOVLW  37
0999:  MOVWF  35
099A:  MOVLP  00
099B:  MOVLB  00
099C:  CALL   40F
099D:  MOVLP  08
099E:  MOVLW  2C
099F:  BTFSS  11.4
09A0:  GOTO   19F
09A1:  MOVLB  03
09A2:  MOVWF  1A
09A3:  MOVLW  34
09A4:  MOVLB  00
09A5:  BTFSS  11.4
09A6:  GOTO   1A5
09A7:  MOVLB  03
09A8:  MOVWF  1A
09A9:  MOVLW  2C
09AA:  MOVLB  00
09AB:  BTFSS  11.4
09AC:  GOTO   1AB
09AD:  MOVLB  03
09AE:  MOVWF  1A
09AF:  MOVLB  02
09B0:  MOVF   33,W
09B1:  MOVWF  34
09B2:  MOVLW  37
09B3:  MOVWF  35
09B4:  MOVLP  00
09B5:  MOVLB  00
09B6:  CALL   40F
09B7:  MOVLP  08
09B8:  MOVF   3B,W
09B9:  MOVLB  02
09BA:  MOVWF  34
09BB:  MOVLW  37
09BC:  MOVWF  35
09BD:  MOVLP  00
09BE:  MOVLB  00
09BF:  CALL   40F
09C0:  MOVLP  08
09C1:  MOVLW  0D
09C2:  BTFSS  11.4
09C3:  GOTO   1C2
09C4:  MOVLB  03
09C5:  MOVWF  1A
09C6:  MOVLW  0A
09C7:  MOVLB  00
09C8:  BTFSS  11.4
09C9:  GOTO   1C8
09CA:  MOVLB  03
09CB:  MOVWF  1A
....................       printf("OK\r\n"); 
09CC:  MOVLW  89
09CD:  MOVWF  11
09CE:  MOVLW  02
09CF:  MOVWF  12
09D0:  MOVLB  00
09D1:  CLRF   28
09D2:  BTFSC  0B.7
09D3:  BSF    28.7
09D4:  BCF    0B.7
09D5:  MOVLP  00
09D6:  CALL   174
09D7:  MOVLP  08
09D8:  BTFSC  28.7
09D9:  BSF    0B.7
....................    } 
09DA:  GOTO   3AB
....................    else if ((rx_msg[index_reader] == '=') && (rx_msg[index_reader+2] == '?')) // case 3 of PWMDUTY command 
09DB:  MOVLW  1E
09DC:  ADDWF  5E,W
09DD:  MOVWF  04
09DE:  MOVLW  20
09DF:  MOVWF  05
09E0:  BTFSC  03.0
09E1:  INCF   05,F
09E2:  MOVF   00,W
09E3:  SUBLW  3D
09E4:  BTFSS  03.2
09E5:  GOTO   2DE
09E6:  MOVLW  02
09E7:  ADDWF  5E,W
09E8:  ADDLW  1E
09E9:  MOVWF  04
09EA:  MOVLW  20
09EB:  MOVWF  05
09EC:  BTFSC  03.0
09ED:  INCF   05,F
09EE:  MOVF   00,W
09EF:  SUBLW  3F
09F0:  BTFSS  03.2
09F1:  GOTO   2DE
....................    { 
....................       // read the channel 
....................       desired_pwm_channel = rx_msg[index_reader+1]; 
09F2:  MOVLW  01
09F3:  ADDWF  5E,W
09F4:  ADDLW  1E
09F5:  MOVWF  04
09F6:  MOVLW  20
09F7:  MOVWF  05
09F8:  BTFSC  03.0
09F9:  INCF   05,F
09FA:  MOVF   00,W
09FB:  MOVWF  65
....................        
....................       // answer the command 
....................       if (desired_pwm_channel == '1') 
09FC:  MOVF   65,W
09FD:  SUBLW  31
09FE:  BTFSS  03.2
09FF:  GOTO   230
....................       { 
....................          printf("+PWMDUTY1:%X%X\r\n", (int)(desired_dutycycle_pwm1>>8), (int)(desired_dutycycle_pwm1)); 
0A00:  MOVF   36,W
0A01:  CLRF   7A
0A02:  MOVLB  02
0A03:  MOVWF  30
0A04:  MOVLW  8C
0A05:  MOVLB  03
0A06:  MOVWF  11
0A07:  MOVLW  02
0A08:  MOVWF  12
0A09:  BCF    03.0
0A0A:  MOVLW  0A
0A0B:  MOVLB  02
0A0C:  MOVWF  34
0A0D:  MOVLP  00
0A0E:  MOVLB  00
0A0F:  CALL   3B3
0A10:  MOVLP  08
0A11:  MOVLB  02
0A12:  MOVF   30,W
0A13:  MOVWF  34
0A14:  MOVLW  37
0A15:  MOVWF  35
0A16:  MOVLP  00
0A17:  MOVLB  00
0A18:  CALL   40F
0A19:  MOVLP  08
0A1A:  MOVF   35,W
0A1B:  MOVLB  02
0A1C:  MOVWF  34
0A1D:  MOVLW  37
0A1E:  MOVWF  35
0A1F:  MOVLP  00
0A20:  MOVLB  00
0A21:  CALL   40F
0A22:  MOVLP  08
0A23:  MOVLW  0D
0A24:  BTFSS  11.4
0A25:  GOTO   224
0A26:  MOVLB  03
0A27:  MOVWF  1A
0A28:  MOVLW  0A
0A29:  MOVLB  00
0A2A:  BTFSS  11.4
0A2B:  GOTO   22A
0A2C:  MOVLB  03
0A2D:  MOVWF  1A
....................       } 
0A2E:  GOTO   2DC
0A2F:  MOVLB  00
....................       else if (desired_pwm_channel == '2') 
0A30:  MOVF   65,W
0A31:  SUBLW  32
0A32:  BTFSS  03.2
0A33:  GOTO   264
....................       { 
....................          printf("+PWMDUTY2:%X%X\r\n", (int)(desired_dutycycle_pwm2>>8), (int)(desired_dutycycle_pwm2)); 
0A34:  MOVF   38,W
0A35:  CLRF   7A
0A36:  MOVLB  02
0A37:  MOVWF  30
0A38:  MOVLW  95
0A39:  MOVLB  03
0A3A:  MOVWF  11
0A3B:  MOVLW  02
0A3C:  MOVWF  12
0A3D:  BCF    03.0
0A3E:  MOVLW  0A
0A3F:  MOVLB  02
0A40:  MOVWF  34
0A41:  MOVLP  00
0A42:  MOVLB  00
0A43:  CALL   3B3
0A44:  MOVLP  08
0A45:  MOVLB  02
0A46:  MOVF   30,W
0A47:  MOVWF  34
0A48:  MOVLW  37
0A49:  MOVWF  35
0A4A:  MOVLP  00
0A4B:  MOVLB  00
0A4C:  CALL   40F
0A4D:  MOVLP  08
0A4E:  MOVF   37,W
0A4F:  MOVLB  02
0A50:  MOVWF  34
0A51:  MOVLW  37
0A52:  MOVWF  35
0A53:  MOVLP  00
0A54:  MOVLB  00
0A55:  CALL   40F
0A56:  MOVLP  08
0A57:  MOVLW  0D
0A58:  BTFSS  11.4
0A59:  GOTO   258
0A5A:  MOVLB  03
0A5B:  MOVWF  1A
0A5C:  MOVLW  0A
0A5D:  MOVLB  00
0A5E:  BTFSS  11.4
0A5F:  GOTO   25E
0A60:  MOVLB  03
0A61:  MOVWF  1A
....................       } 
0A62:  GOTO   2DC
0A63:  MOVLB  00
....................       else if (desired_pwm_channel == '3') 
0A64:  MOVF   65,W
0A65:  SUBLW  33
0A66:  BTFSS  03.2
0A67:  GOTO   298
....................       { 
....................          printf("+PWMDUTY3:%X%X\r\n", (int)(desired_dutycycle_pwm3>>8), (int)(desired_dutycycle_pwm3)); 
0A68:  MOVF   3A,W
0A69:  CLRF   7A
0A6A:  MOVLB  02
0A6B:  MOVWF  30
0A6C:  MOVLW  9E
0A6D:  MOVLB  03
0A6E:  MOVWF  11
0A6F:  MOVLW  02
0A70:  MOVWF  12
0A71:  BCF    03.0
0A72:  MOVLW  0A
0A73:  MOVLB  02
0A74:  MOVWF  34
0A75:  MOVLP  00
0A76:  MOVLB  00
0A77:  CALL   3B3
0A78:  MOVLP  08
0A79:  MOVLB  02
0A7A:  MOVF   30,W
0A7B:  MOVWF  34
0A7C:  MOVLW  37
0A7D:  MOVWF  35
0A7E:  MOVLP  00
0A7F:  MOVLB  00
0A80:  CALL   40F
0A81:  MOVLP  08
0A82:  MOVF   39,W
0A83:  MOVLB  02
0A84:  MOVWF  34
0A85:  MOVLW  37
0A86:  MOVWF  35
0A87:  MOVLP  00
0A88:  MOVLB  00
0A89:  CALL   40F
0A8A:  MOVLP  08
0A8B:  MOVLW  0D
0A8C:  BTFSS  11.4
0A8D:  GOTO   28C
0A8E:  MOVLB  03
0A8F:  MOVWF  1A
0A90:  MOVLW  0A
0A91:  MOVLB  00
0A92:  BTFSS  11.4
0A93:  GOTO   292
0A94:  MOVLB  03
0A95:  MOVWF  1A
....................       } 
0A96:  GOTO   2DC
0A97:  MOVLB  00
....................       else if (desired_pwm_channel == '4') 
0A98:  MOVF   65,W
0A99:  SUBLW  34
0A9A:  BTFSS  03.2
0A9B:  GOTO   2CC
....................       { 
....................          printf("+PWMDUTY4:%X%X\r\n", (int)(desired_dutycycle_pwm4>>8), (int)(desired_dutycycle_pwm4)); 
0A9C:  MOVF   3C,W
0A9D:  CLRF   7A
0A9E:  MOVLB  02
0A9F:  MOVWF  30
0AA0:  MOVLW  A7
0AA1:  MOVLB  03
0AA2:  MOVWF  11
0AA3:  MOVLW  02
0AA4:  MOVWF  12
0AA5:  BCF    03.0
0AA6:  MOVLW  0A
0AA7:  MOVLB  02
0AA8:  MOVWF  34
0AA9:  MOVLP  00
0AAA:  MOVLB  00
0AAB:  CALL   3B3
0AAC:  MOVLP  08
0AAD:  MOVLB  02
0AAE:  MOVF   30,W
0AAF:  MOVWF  34
0AB0:  MOVLW  37
0AB1:  MOVWF  35
0AB2:  MOVLP  00
0AB3:  MOVLB  00
0AB4:  CALL   40F
0AB5:  MOVLP  08
0AB6:  MOVF   3B,W
0AB7:  MOVLB  02
0AB8:  MOVWF  34
0AB9:  MOVLW  37
0ABA:  MOVWF  35
0ABB:  MOVLP  00
0ABC:  MOVLB  00
0ABD:  CALL   40F
0ABE:  MOVLP  08
0ABF:  MOVLW  0D
0AC0:  BTFSS  11.4
0AC1:  GOTO   2C0
0AC2:  MOVLB  03
0AC3:  MOVWF  1A
0AC4:  MOVLW  0A
0AC5:  MOVLB  00
0AC6:  BTFSS  11.4
0AC7:  GOTO   2C6
0AC8:  MOVLB  03
0AC9:  MOVWF  1A
....................       } 
0ACA:  GOTO   2DC
0ACB:  MOVLB  00
....................       else 
....................       { 
....................          // the command is not recognized 
....................          printf("ERROR\r\n"); 
0ACC:  MOVLW  B0
0ACD:  MOVLB  03
0ACE:  MOVWF  11
0ACF:  MOVLW  02
0AD0:  MOVWF  12
0AD1:  MOVLB  00
0AD2:  CLRF   28
0AD3:  BTFSC  0B.7
0AD4:  BSF    28.7
0AD5:  BCF    0B.7
0AD6:  MOVLP  00
0AD7:  CALL   174
0AD8:  MOVLP  08
0AD9:  BTFSC  28.7
0ADA:  BSF    0B.7
0ADB:  MOVLB  03
....................       } 
....................    } 
0ADC:  GOTO   3AC
0ADD:  MOVLB  00
....................    else if (rx_msg[index_reader] == '=') // case 1 of PWMDUTY command 
0ADE:  MOVLW  1E
0ADF:  ADDWF  5E,W
0AE0:  MOVWF  04
0AE1:  MOVLW  20
0AE2:  MOVWF  05
0AE3:  BTFSC  03.0
0AE4:  INCF   05,F
0AE5:  MOVF   00,W
0AE6:  SUBLW  3D
0AE7:  BTFSS  03.2
0AE8:  GOTO   39C
....................    { 
....................       // read the channel 
....................       desired_pwm_channel = rx_msg[index_reader+1]; 
0AE9:  MOVLW  01
0AEA:  ADDWF  5E,W
0AEB:  ADDLW  1E
0AEC:  MOVWF  04
0AED:  MOVLW  20
0AEE:  MOVWF  05
0AEF:  BTFSC  03.0
0AF0:  INCF   05,F
0AF1:  MOVF   00,W
0AF2:  MOVWF  65
....................        
....................       // read the value 
....................       for (i = index_reader+3; i < index_rx_msg; i++) 
0AF3:  MOVLW  03
0AF4:  ADDWF  5E,W
0AF5:  MOVLB  02
0AF6:  MOVWF  2D
0AF7:  MOVLB  00
0AF8:  MOVF   52,W
0AF9:  MOVLB  02
0AFA:  SUBWF  2D,W
0AFB:  BTFSC  03.0
0AFC:  GOTO   31F
....................       { 
....................          // add character to value buffer 
....................          value_msg[index_value_msg] = rx_msg[i]; 
0AFD:  MOVLW  3F
0AFE:  MOVLB  00
0AFF:  ADDWF  64,W
0B00:  MOVWF  78
0B01:  MOVLW  20
0B02:  MOVWF  7A
0B03:  BTFSC  03.0
0B04:  INCF   7A,F
0B05:  MOVF   78,W
0B06:  MOVLB  02
0B07:  MOVWF  30
0B08:  MOVF   7A,W
0B09:  MOVWF  31
0B0A:  MOVLW  1E
0B0B:  ADDWF  2D,W
0B0C:  MOVWF  04
0B0D:  MOVLW  20
0B0E:  MOVWF  05
0B0F:  BTFSC  03.0
0B10:  INCF   05,F
0B11:  MOVF   00,W
0B12:  MOVWF  32
0B13:  MOVF   31,W
0B14:  MOVWF  05
0B15:  MOVF   30,W
0B16:  MOVWF  04
0B17:  MOVF   32,W
0B18:  MOVWF  00
....................          index_value_msg += 1; 
0B19:  MOVLW  01
0B1A:  MOVLB  00
0B1B:  ADDWF  64,F
0B1C:  MOVLB  02
0B1D:  INCF   2D,F
0B1E:  GOTO   2F7
....................       } 
....................        
....................       // end of value (read buffer to get the number) 
....................       unsigned int16 temp_desired_pwm_dutycyle = 0; 
0B1F:  CLRF   2F
0B20:  CLRF   2E
....................       for (i = 0; i < index_value_msg; i++) 
0B21:  CLRF   2D
0B22:  MOVLB  00
0B23:  MOVF   64,W
0B24:  MOVLB  02
0B25:  SUBWF  2D,W
0B26:  BTFSC  03.0
0B27:  GOTO   348
....................       { 
....................          temp_desired_pwm_dutycyle += char_hex_to_dec(value_msg[i],index_value_msg-2-i); 
0B28:  MOVLW  3F
0B29:  ADDWF  2D,W
0B2A:  MOVWF  04
0B2B:  MOVLW  20
0B2C:  MOVWF  05
0B2D:  BTFSC  03.0
0B2E:  INCF   05,F
0B2F:  MOVF   00,W
0B30:  MOVWF  30
0B31:  MOVLW  02
0B32:  MOVLB  00
0B33:  SUBWF  64,W
0B34:  MOVWF  78
0B35:  MOVLB  02
0B36:  MOVF   2D,W
0B37:  SUBWF  78,W
0B38:  MOVWF  31
0B39:  MOVF   30,W
0B3A:  MOVWF  32
0B3B:  MOVF   31,W
0B3C:  MOVWF  33
0B3D:  MOVLP  00
0B3E:  MOVLB  00
0B3F:  CALL   439
0B40:  MOVLP  08
0B41:  MOVF   77,W
0B42:  MOVLB  02
0B43:  ADDWF  2E,F
0B44:  MOVF   78,W
0B45:  ADDWFC 2F,F
0B46:  INCF   2D,F
0B47:  GOTO   322
....................       } 
....................        
....................       // answer the command 
....................       if (desired_pwm_channel == '1') 
0B48:  MOVLB  00
0B49:  MOVF   65,W
0B4A:  SUBLW  31
0B4B:  BTFSS  03.2
0B4C:  GOTO   356
....................       { 
....................          desired_dutycycle_pwm1 = temp_desired_pwm_dutycyle; // assig final value of PWM dutycycle 
0B4D:  MOVLB  02
0B4E:  MOVF   2F,W
0B4F:  MOVLB  00
0B50:  MOVWF  36
0B51:  MOVLB  02
0B52:  MOVF   2E,W
0B53:  MOVLB  00
0B54:  MOVWF  35
....................       } 
0B55:  GOTO   38C
....................       else if (desired_pwm_channel == '2') 
0B56:  MOVF   65,W
0B57:  SUBLW  32
0B58:  BTFSS  03.2
0B59:  GOTO   363
....................       { 
....................          desired_dutycycle_pwm2 = temp_desired_pwm_dutycyle; // assig final value of PWM dutycycle 
0B5A:  MOVLB  02
0B5B:  MOVF   2F,W
0B5C:  MOVLB  00
0B5D:  MOVWF  38
0B5E:  MOVLB  02
0B5F:  MOVF   2E,W
0B60:  MOVLB  00
0B61:  MOVWF  37
....................       } 
0B62:  GOTO   38C
....................       else if (desired_pwm_channel == '3') 
0B63:  MOVF   65,W
0B64:  SUBLW  33
0B65:  BTFSS  03.2
0B66:  GOTO   370
....................       { 
....................          desired_dutycycle_pwm3 = temp_desired_pwm_dutycyle; // assig final value of PWM dutycycle 
0B67:  MOVLB  02
0B68:  MOVF   2F,W
0B69:  MOVLB  00
0B6A:  MOVWF  3A
0B6B:  MOVLB  02
0B6C:  MOVF   2E,W
0B6D:  MOVLB  00
0B6E:  MOVWF  39
....................       } 
0B6F:  GOTO   38C
....................       else if (desired_pwm_channel == '4') 
0B70:  MOVF   65,W
0B71:  SUBLW  34
0B72:  BTFSS  03.2
0B73:  GOTO   37D
....................       { 
....................          desired_dutycycle_pwm4 = temp_desired_pwm_dutycyle; // assig final value of PWM dutycycle 
0B74:  MOVLB  02
0B75:  MOVF   2F,W
0B76:  MOVLB  00
0B77:  MOVWF  3C
0B78:  MOVLB  02
0B79:  MOVF   2E,W
0B7A:  MOVLB  00
0B7B:  MOVWF  3B
....................       } 
0B7C:  GOTO   38C
....................       else 
....................       { 
....................          // the command is not recognized 
....................          printf("ERROR\r\n"); 
0B7D:  MOVLW  B4
0B7E:  MOVLB  03
0B7F:  MOVWF  11
0B80:  MOVLW  02
0B81:  MOVWF  12
0B82:  MOVLB  00
0B83:  CLRF   28
0B84:  BTFSC  0B.7
0B85:  BSF    28.7
0B86:  BCF    0B.7
0B87:  MOVLP  00
0B88:  CALL   174
0B89:  MOVLP  08
0B8A:  BTFSC  28.7
0B8B:  BSF    0B.7
....................       } 
....................        
....................       printf("OK\r\n"); 
0B8C:  MOVLW  B8
0B8D:  MOVLB  03
0B8E:  MOVWF  11
0B8F:  MOVLW  02
0B90:  MOVWF  12
0B91:  MOVLB  00
0B92:  CLRF   28
0B93:  BTFSC  0B.7
0B94:  BSF    28.7
0B95:  BCF    0B.7
0B96:  MOVLP  00
0B97:  CALL   174
0B98:  MOVLP  08
0B99:  BTFSC  28.7
0B9A:  BSF    0B.7
....................    } 
0B9B:  GOTO   3AB
....................    else 
....................    { 
....................       // the command is not recognized 
....................       printf("ERROR\r\n"); 
0B9C:  MOVLW  BB
0B9D:  MOVLB  03
0B9E:  MOVWF  11
0B9F:  MOVLW  02
0BA0:  MOVWF  12
0BA1:  MOVLB  00
0BA2:  CLRF   28
0BA3:  BTFSC  0B.7
0BA4:  BSF    28.7
0BA5:  BCF    0B.7
0BA6:  MOVLP  00
0BA7:  CALL   174
0BA8:  MOVLP  08
0BA9:  BTFSC  28.7
0BAA:  BSF    0B.7
0BAB:  MOVLB  03
....................    } 
0BAC:  MOVLP  08
0BAD:  MOVLB  00
0BAE:  GOTO   5A9 (RETURN)
.................... } 
....................  
....................  
.................... /* 
.................... * Function to manage ABOUT command 
.................... */ 
.................... void Manage_ABOUT_Command(void) 
.................... { 
....................    // answer the command 
....................    printf("Version: 1.0\r\n"); 
*
0712:  MOVLW  BF
0713:  MOVLB  03
0714:  MOVWF  11
0715:  MOVLW  02
0716:  MOVWF  12
0717:  MOVLB  00
0718:  CLRF   28
0719:  BTFSC  0B.7
071A:  BSF    28.7
071B:  BCF    0B.7
071C:  CALL   174
071D:  BTFSC  28.7
071E:  BSF    0B.7
....................    printf("Date: 26/08/2022\r\n"); 
071F:  MOVLW  C7
0720:  MOVLB  03
0721:  MOVWF  11
0722:  MOVLW  02
0723:  MOVWF  12
0724:  MOVLB  00
0725:  CLRF   28
0726:  BTFSC  0B.7
0727:  BSF    28.7
0728:  BCF    0B.7
0729:  CALL   174
072A:  BTFSC  28.7
072B:  BSF    0B.7
....................    printf("OK\r\n"); 
072C:  MOVLW  D1
072D:  MOVLB  03
072E:  MOVWF  11
072F:  MOVLW  02
0730:  MOVWF  12
0731:  MOVLB  00
0732:  CLRF   28
0733:  BTFSC  0B.7
0734:  BSF    28.7
0735:  BCF    0B.7
0736:  CALL   174
0737:  BTFSC  28.7
0738:  BSF    0B.7
0739:  MOVLP  08
073A:  GOTO   5CC (RETURN)
.................... } 
....................  
....................  
.................... /* 
.................... * Function to manage HELP command 
.................... */ 
.................... void Manage_HELP_Command(void) 
.................... { 
....................    // answer the command 
....................    printf("AT  Comando de prueba\r\n"); 
073B:  MOVLW  D4
073C:  MOVLB  03
073D:  MOVWF  11
073E:  MOVLW  02
073F:  MOVWF  12
0740:  MOVLB  00
0741:  CLRF   28
0742:  BTFSC  0B.7
0743:  BSF    28.7
0744:  BCF    0B.7
0745:  CALL   174
0746:  BTFSC  28.7
0747:  BSF    0B.7
....................    printf("AT+ANOUT  Para establecer salidas analogas\r\n"); 
0748:  MOVLW  E0
0749:  MOVLB  03
074A:  MOVWF  11
074B:  MOVLW  02
074C:  MOVWF  12
074D:  MOVLB  00
074E:  CLRF   28
074F:  BTFSC  0B.7
0750:  BSF    28.7
0751:  BCF    0B.7
0752:  CALL   174
0753:  BTFSC  28.7
0754:  BSF    0B.7
....................    printf("AT+PWMPERIOD  Para establecer periodo de canales PWM\r\n"); 
0755:  MOVLW  F7
0756:  MOVLB  03
0757:  MOVWF  11
0758:  MOVLW  02
0759:  MOVWF  12
075A:  MOVLB  00
075B:  CLRF   28
075C:  BTFSC  0B.7
075D:  BSF    28.7
075E:  BCF    0B.7
075F:  CALL   174
0760:  BTFSC  28.7
0761:  BSF    0B.7
....................    printf("AT+PWMDUTY  Para establecer ciclo de trabajo de canales PWM\r\n"); 
0762:  MOVLW  13
0763:  MOVLB  03
0764:  MOVWF  11
0765:  MOVLW  03
0766:  MOVWF  12
0767:  MOVLB  00
0768:  CLRF   28
0769:  BTFSC  0B.7
076A:  BSF    28.7
076B:  BCF    0B.7
076C:  CALL   174
076D:  BTFSC  28.7
076E:  BSF    0B.7
....................    printf("AT+ABOUT  Para mostrar informacion del producto\r\n"); 
076F:  MOVLW  32
0770:  MOVLB  03
0771:  MOVWF  11
0772:  MOVLW  03
0773:  MOVWF  12
0774:  MOVLB  00
0775:  CLRF   28
0776:  BTFSC  0B.7
0777:  BSF    28.7
0778:  BCF    0B.7
0779:  CALL   174
077A:  BTFSC  28.7
077B:  BSF    0B.7
....................    printf("AT+HELP  Para mostrar lista de comandos\r\n"); 
077C:  MOVLW  4B
077D:  MOVLB  03
077E:  MOVWF  11
077F:  MOVLW  03
0780:  MOVWF  12
0781:  MOVLB  00
0782:  CLRF   28
0783:  BTFSC  0B.7
0784:  BSF    28.7
0785:  BCF    0B.7
0786:  CALL   174
0787:  BTFSC  28.7
0788:  BSF    0B.7
....................    printf("OK\r\n"); 
0789:  MOVLW  60
078A:  MOVLB  03
078B:  MOVWF  11
078C:  MOVLW  03
078D:  MOVWF  12
078E:  MOVLB  00
078F:  CLRF   28
0790:  BTFSC  0B.7
0791:  BSF    28.7
0792:  BCF    0B.7
0793:  CALL   174
0794:  BTFSC  28.7
0795:  BSF    0B.7
0796:  MOVLP  08
0797:  GOTO   5F0 (RETURN)
.................... } 
....................  
....................  
.................... /*  
.................... * Function to clear buffers of UART communications 
.................... */ 
.................... void Clear_Buffers(void) 
.................... { 
....................    for (int8 j = 0; j < index_rx_msg; j++) 
0798:  MOVLB  02
0799:  CLRF   2D
079A:  MOVLB  00
079B:  MOVF   52,W
079C:  MOVLB  02
079D:  SUBWF  2D,W
079E:  BTFSC  03.0
079F:  GOTO   7AA
....................    { 
....................       rx_msg[j] = 0;  
07A0:  MOVLW  1E
07A1:  ADDWF  2D,W
07A2:  MOVWF  04
07A3:  MOVLW  20
07A4:  MOVWF  05
07A5:  BTFSC  03.0
07A6:  INCF   05,F
07A7:  CLRF   00
07A8:  INCF   2D,F
07A9:  GOTO   79A
....................    } 
....................    index_rx_msg = 0; // reset the buffer index 
07AA:  MOVLB  00
07AB:  CLRF   52
....................     
....................    for (j = 0; j < index_identifier_msg; j++) 
07AC:  MOVLB  02
07AD:  CLRF   2D
07AE:  MOVLB  00
07AF:  MOVF   5D,W
07B0:  MOVLB  02
07B1:  SUBWF  2D,W
07B2:  BTFSC  03.0
07B3:  GOTO   7BE
....................    { 
....................       identifier_msg[j] = 0;  
07B4:  MOVLW  33
07B5:  ADDWF  2D,W
07B6:  MOVWF  04
07B7:  MOVLW  20
07B8:  MOVWF  05
07B9:  BTFSC  03.0
07BA:  INCF   05,F
07BB:  CLRF   00
07BC:  INCF   2D,F
07BD:  GOTO   7AE
....................    } 
....................    index_identifier_msg = 0; // reset the buffer index 
07BE:  MOVLB  00
07BF:  CLRF   5D
....................     
....................    for (j = 0; j < index_value_msg; j++) 
07C0:  MOVLB  02
07C1:  CLRF   2D
07C2:  MOVLB  00
07C3:  MOVF   64,W
07C4:  MOVLB  02
07C5:  SUBWF  2D,W
07C6:  BTFSC  03.0
07C7:  GOTO   7D2
....................    { 
....................       value_msg[j] = 0;  
07C8:  MOVLW  3F
07C9:  ADDWF  2D,W
07CA:  MOVWF  04
07CB:  MOVLW  20
07CC:  MOVWF  05
07CD:  BTFSC  03.0
07CE:  INCF   05,F
07CF:  CLRF   00
07D0:  INCF   2D,F
07D1:  GOTO   7C2
....................    } 
....................    index_value_msg = 0; // reset the buffer index 
07D2:  MOVLB  00
07D3:  CLRF   64
07D4:  MOVLP  08
07D5:  GOTO   613 (RETURN)
.................... } 
....................  
....................  
.................... #ifdef __DEBUG__ 
.................... void Print_Buffers(void) 
.................... { 
....................    // print the message received 
....................    for (int8 k = 0; k < index_rx_msg; k++) 
....................    { 
....................       putc(rx_msg[k]);  
....................    } 
....................    printf("\r\n"); 
....................     
....................    // print the identifier received 
....................    for (k = 0; k < index_identifier_msg; k++) 
....................    { 
....................       putc(identifier_msg[k]);  
....................    } 
....................    printf("\r\n"); 
....................     
....................    // print the value received 
....................    for (k = 0; k < index_value_msg; k++) 
....................    { 
....................       putc(value_msg[k]);  
....................    } 
....................    printf("\r\n"); 
.................... } 
.................... #endif 
....................  
....................  
.................... void main() 
*
0BAF:  MOVLB  03
0BB0:  BSF    1F.3
0BB1:  MOVLW  08
0BB2:  MOVWF  1B
0BB3:  MOVLW  02
0BB4:  MOVWF  1C
0BB5:  MOVLW  A6
0BB6:  MOVWF  1E
0BB7:  MOVLW  90
0BB8:  MOVWF  1D
0BB9:  MOVLB  04
0BBA:  BCF    15.5
0BBB:  MOVLW  40
0BBC:  MOVWF  14
0BBD:  MOVLW  0B
0BBE:  MOVWF  12
0BBF:  MOVLW  3A
0BC0:  MOVWF  15
0BC1:  MOVLB  01
0BC2:  BCF    0E.5
0BC3:  BSF    0E.4
0BC4:  BCF    0E.3
0BC5:  MOVLB  00
0BC6:  CLRF   2C
0BC7:  CLRF   2B
0BC8:  CLRF   2E
0BC9:  CLRF   2D
0BCA:  CLRF   2F
0BCB:  CLRF   30
0BCC:  CLRF   32
0BCD:  CLRF   31
0BCE:  MOVLW  05
0BCF:  MOVWF  34
0BD0:  MOVLW  24
0BD1:  MOVWF  33
0BD2:  CLRF   36
0BD3:  CLRF   35
0BD4:  CLRF   38
0BD5:  CLRF   37
0BD6:  CLRF   3A
0BD7:  CLRF   39
0BD8:  CLRF   3C
0BD9:  CLRF   3B
0BDA:  CLRF   3D
0BDB:  CLRF   52
0BDC:  CLRF   5D
0BDD:  CLRF   5E
0BDE:  CLRF   64
0BDF:  CLRF   65
0BE0:  CLRF   66
0BE1:  CLRF   70
0BE2:  MOVLB  0F
0BE3:  CLRF   11
0BE4:  CLRF   12
0BE5:  CLRF   18
0BE6:  CLRF   19
0BE7:  CLRF   1A
0BE8:  MOVLB  03
0BE9:  CLRF   0C
0BEA:  CLRF   0D
0BEB:  CLRF   0F
0BEC:  CLRF   10
0BED:  MOVLB  02
0BEE:  CLRF   12
0BEF:  CLRF   11
0BF0:  CLRF   14
0BF1:  CLRF   13
0BF2:  GOTO   463
0BF3:  DATA 02,34
0BF4:  DATA 00,34
0BF5:  DATA 29,34
0BF6:  DATA 00,34
0BF7:  DATA 00,34
0BF8:  DATA 14,34
0BF9:  DATA 40,34
0BFA:  DATA 3E,34
0BFB:  DATA 00,34
0BFC:  DATA 0A,34
0BFD:  DATA 40,34
0BFE:  DATA 53,34
0BFF:  DATA 00,34
0C00:  DATA 05,34
0C01:  DATA 40,34
0C02:  DATA 5F,34
0C03:  DATA 00,34
0C04:  DATA 06,34
0C05:  DATA 00,34
0C06:  DATA 68,34
0C07:  DATA 41,34
0C08:  DATA 4E,34
0C09:  DATA 4F,34
0C0A:  DATA 55,34
0C0B:  DATA 54,34
0C0C:  DATA 00,34
0C0D:  DATA 06,34
0C0E:  DATA 00,34
0C0F:  DATA A2,34
0C10:  DATA 61,34
0C11:  DATA 6E,34
0C12:  DATA 6F,34
0C13:  DATA 75,34
0C14:  DATA 74,34
0C15:  DATA 00,34
0C16:  DATA 1C,34
0C17:  DATA 00,34
0C18:  DATA AC,34
0C19:  DATA 50,34
0C1A:  DATA 57,34
0C1B:  DATA 4D,34
0C1C:  DATA 50,34
0C1D:  DATA 45,34
0C1E:  DATA 52,34
0C1F:  DATA 49,34
0C20:  DATA 4F,34
0C21:  DATA 44,34
0C22:  DATA 00,34
0C23:  DATA 70,34
0C24:  DATA 77,34
0C25:  DATA 6D,34
0C26:  DATA 70,34
0C27:  DATA 65,34
0C28:  DATA 72,34
0C29:  DATA 69,34
0C2A:  DATA 6F,34
0C2B:  DATA 64,34
0C2C:  DATA 00,34
0C2D:  DATA 50,34
0C2E:  DATA 57,34
0C2F:  DATA 4D,34
0C30:  DATA 44,34
0C31:  DATA 55,34
0C32:  DATA 54,34
0C33:  DATA 59,34
0C34:  DATA 00,34
0C35:  DATA 08,34
0C36:  DATA 00,34
0C37:  DATA CA,34
0C38:  DATA 70,34
0C39:  DATA 77,34
0C3A:  DATA 6D,34
0C3B:  DATA 64,34
0C3C:  DATA 75,34
0C3D:  DATA 74,34
0C3E:  DATA 79,34
0C3F:  DATA 00,34
0C40:  DATA 06,34
0C41:  DATA 00,34
0C42:  DATA D4,34
0C43:  DATA 41,34
0C44:  DATA 42,34
0C45:  DATA 4F,34
0C46:  DATA 55,34
0C47:  DATA 54,34
0C48:  DATA 00,34
0C49:  DATA 06,34
0C4A:  DATA 00,34
0C4B:  DATA DE,34
0C4C:  DATA 61,34
0C4D:  DATA 62,34
0C4E:  DATA 6F,34
0C4F:  DATA 75,34
0C50:  DATA 74,34
0C51:  DATA 00,34
0C52:  DATA 05,34
0C53:  DATA 00,34
0C54:  DATA E8,34
0C55:  DATA 48,34
0C56:  DATA 45,34
0C57:  DATA 4C,34
0C58:  DATA 50,34
0C59:  DATA 00,34
0C5A:  DATA 05,34
0C5B:  DATA 01,34
0C5C:  DATA 22,34
0C5D:  DATA 68,34
0C5E:  DATA 65,34
0C5F:  DATA 6C,34
0C60:  DATA 70,34
0C61:  DATA 00,34
0C62:  DATA 00,34
0C63:  MOVLW  0B
0C64:  MOVWF  05
0C65:  MOVLW  F3
0C66:  MOVWF  04
0C67:  BSF    05.7
0C68:  MOVIW  [FSR0++],W
0C69:  MOVWF  77
0C6A:  XORLW  00
0C6B:  BTFSC  03.2
0C6C:  GOTO   47D
0C6D:  MOVIW  [FSR0++],W
0C6E:  MOVWF  78
0C6F:  BTFSC  78.7
0C70:  GOTO   475
0C71:  ANDLW  0F
0C72:  MOVWF  07
0C73:  MOVIW  [FSR0++],W
0C74:  MOVWF  06
0C75:  BTFSC  78.6
0C76:  MOVIW  [FSR0++],W
0C77:  BTFSS  78.6
0C78:  MOVIW  [FSR0++],W
0C79:  MOVWI  W,[FSR1++]
0C7A:  DECFSZ 77,F
0C7B:  GOTO   477
0C7C:  GOTO   468
.................... { 
....................    // Set initial state of IO pins 
....................    output_low(USER_LED); // start with led turn off 
0C7D:  MOVLW  CF
0C7E:  TRIS   6
0C7F:  BCF    0D.4
....................    output_low(COMMS_LED); // start with led turn off 
0C80:  TRIS   6
0C81:  BCF    0D.5
....................    output_high(CS_PIN); // start in high to disable the slave 
0C82:  MOVLW  F5
0C83:  MOVLB  01
0C84:  MOVWF  0F
0C85:  MOVLB  02
0C86:  BSF    0F.3
....................     
....................    // Set initial state of PWM pins 
....................    output_low(PWM1_PIN); 
0C87:  MOVLB  01
0C88:  BCF    0E.2
0C89:  MOVLB  02
0C8A:  BCF    0E.2
....................    output_low(PWM2_PIN); 
0C8B:  MOVLB  01
0C8C:  BCF    0E.1
0C8D:  MOVLB  02
0C8E:  BCF    0E.1
....................    output_low(PWM3_PIN); 
0C8F:  MOVLB  01
0C90:  BCF    10.0
0C91:  MOVLB  02
0C92:  BCF    10.0
....................    output_low(PWM4_PIN); 
0C93:  MOVLB  01
0C94:  MOVWF  0F
0C95:  MOVLB  02
0C96:  BCF    0F.1
....................     
....................    // Set initial 0V (0x000) at DAC output channels 
....................    output_low(CS_PIN); // to enable slave 
0C97:  MOVLB  01
0C98:  MOVWF  0F
0C99:  MOVLB  02
0C9A:  BCF    0F.3
....................    // to channel 1 
....................    spi_dac_command_H = 0x10; //  CH1:1Y(0001-Y) / CH2:5Y(0101-Y) 
0C9B:  MOVLW  10
0C9C:  MOVLB  00
0C9D:  MOVWF  2F
....................    spi_dac_command_L = 0x00; //  YY(Y-HH00) 
0C9E:  CLRF   30
....................    spi_write(spi_dac_command_H); 
0C9F:  MOVLB  04
0CA0:  MOVF   11,W
0CA1:  MOVLB  00
0CA2:  MOVF   2F,W
0CA3:  MOVLB  04
0CA4:  MOVWF  11
0CA5:  RRF    14,W
0CA6:  BTFSS  03.0
0CA7:  GOTO   4A5
....................    spi_write(spi_dac_command_H); 
0CA8:  MOVF   11,W
0CA9:  MOVLB  00
0CAA:  MOVF   2F,W
0CAB:  MOVLB  04
0CAC:  MOVWF  11
0CAD:  RRF    14,W
0CAE:  BTFSS  03.0
0CAF:  GOTO   4AD
....................    // to channel 2 
....................    spi_dac_command_H = 0x50; //  CH1:1Y(0001-Y) / CH2:5Y(0101-Y) 
0CB0:  MOVLW  50
0CB1:  MOVLB  00
0CB2:  MOVWF  2F
....................    spi_dac_command_L = 0x00; //  YY(Y-HH00) 
0CB3:  CLRF   30
....................    spi_write(spi_dac_command_H); 
0CB4:  MOVLB  04
0CB5:  MOVF   11,W
0CB6:  MOVLB  00
0CB7:  MOVF   2F,W
0CB8:  MOVLB  04
0CB9:  MOVWF  11
0CBA:  RRF    14,W
0CBB:  BTFSS  03.0
0CBC:  GOTO   4BA
....................    spi_write(spi_dac_command_H); 
0CBD:  MOVF   11,W
0CBE:  MOVLB  00
0CBF:  MOVF   2F,W
0CC0:  MOVLB  04
0CC1:  MOVWF  11
0CC2:  RRF    14,W
0CC3:  BTFSS  03.0
0CC4:  GOTO   4C2
....................    output_high(CS_PIN); // to finish spi transaction 
0CC5:  MOVLW  F5
0CC6:  MOVLB  01
0CC7:  MOVWF  0F
0CC8:  MOVLB  02
0CC9:  BSF    0F.3
....................     
....................    // Configure TIM2 to PWM timebase 
....................    setup_timer_2(T2_DIV_BY_1,75,1); // 15,2 us overflow, 15,2 us interrupt 
0CCA:  MOVLW  00
0CCB:  MOVWF  78
0CCC:  IORLW  04
0CCD:  MOVLB  00
0CCE:  MOVWF  1C
0CCF:  MOVLW  4B
0CD0:  MOVWF  1B
....................     
....................    // Configure interrupts 
....................    enable_interrupts(INT_TIMER2); // timer 2 interrupt 
0CD1:  MOVLB  01
0CD2:  BSF    11.1
....................    enable_interrupts(INT_RDA); // UART interrupt 
0CD3:  BSF    11.5
....................    enable_interrupts(GLOBAL); 
0CD4:  MOVLW  C0
0CD5:  IORWF  0B,F
....................     
....................    // Start UART communication 
....................    uart_state = ST_WAIT; 
0CD6:  MOVLB  00
0CD7:  CLRF   67
....................    printf("READY\r\n"); 
0CD8:  MOVLW  63
0CD9:  MOVLB  03
0CDA:  MOVWF  11
0CDB:  MOVLW  03
0CDC:  MOVWF  12
0CDD:  MOVLB  00
0CDE:  CLRF   28
0CDF:  BTFSC  0B.7
0CE0:  BSF    28.7
0CE1:  BCF    0B.7
0CE2:  MOVLP  00
0CE3:  CALL   174
0CE4:  MOVLP  08
0CE5:  BTFSC  28.7
0CE6:  BSF    0B.7
....................  
....................    // Loop to manage UART communications/messages 
....................    while(TRUE) 
....................    { 
....................       if (NEW_MSG_RECEIVED_FLAG == true) 
0CE7:  DECFSZ 70,W
0CE8:  GOTO   615
....................       { 
....................          // manage the event 
....................          if (rx_msg[0] == 0) // simple AT command 
0CE9:  MOVF   3E,F
0CEA:  BTFSS  03.2
0CEB:  GOTO   4FC
....................          { 
....................             printf("OK\r\n");  
0CEC:  MOVLW  67
0CED:  MOVLB  03
0CEE:  MOVWF  11
0CEF:  MOVLW  03
0CF0:  MOVWF  12
0CF1:  MOVLB  00
0CF2:  CLRF   28
0CF3:  BTFSC  0B.7
0CF4:  BSF    28.7
0CF5:  BCF    0B.7
0CF6:  MOVLP  00
0CF7:  CALL   174
0CF8:  MOVLP  08
0CF9:  BTFSC  28.7
0CFA:  BSF    0B.7
....................          } 
0CFB:  GOTO   611
....................          else if (rx_msg[0] == '+') // complex AT command 
0CFC:  MOVF   3E,W
0CFD:  SUBLW  2B
0CFE:  BTFSS  03.2
0CFF:  GOTO   602
....................          { 
....................             // get the identifier of the received command 
....................             for (int8 i = 1; i < index_rx_msg; i++) 
0D00:  MOVLW  01
0D01:  MOVLB  02
0D02:  MOVWF  2C
0D03:  MOVLB  00
0D04:  MOVF   52,W
0D05:  MOVLB  02
0D06:  SUBWF  2C,W
0D07:  BTFSC  03.0
0D08:  GOTO   543
....................             { 
....................                if ( (rx_msg[i] == '=') || (rx_msg[i] == '?') ) 
0D09:  MOVLW  1E
0D0A:  ADDWF  2C,W
0D0B:  MOVWF  04
0D0C:  MOVLW  20
0D0D:  MOVWF  05
0D0E:  BTFSC  03.0
0D0F:  INCF   05,F
0D10:  MOVF   00,W
0D11:  SUBLW  3D
0D12:  BTFSC  03.2
0D13:  GOTO   51F
0D14:  MOVLW  1E
0D15:  ADDWF  2C,W
0D16:  MOVWF  04
0D17:  MOVLW  20
0D18:  MOVWF  05
0D19:  BTFSC  03.0
0D1A:  INCF   05,F
0D1B:  MOVF   00,W
0D1C:  SUBLW  3F
0D1D:  BTFSS  03.2
0D1E:  GOTO   525
....................                { 
....................                   // end of command identifier 
....................                   index_reader = i; 
0D1F:  MOVF   2C,W
0D20:  MOVLB  00
0D21:  MOVWF  5E
....................                   break; 
0D22:  MOVLB  02
0D23:  GOTO   543
....................                } 
0D24:  GOTO   541
....................                else 
....................                { 
....................                   // read the command identifier 
....................                   identifier_msg[index_identifier_msg] = rx_msg[i]; 
0D25:  MOVLW  33
0D26:  MOVLB  00
0D27:  ADDWF  5D,W
0D28:  MOVLB  02
0D29:  MOVWF  2D
0D2A:  MOVLW  20
0D2B:  MOVWF  2E
0D2C:  BTFSC  03.0
0D2D:  INCF   2E,F
0D2E:  MOVLW  1E
0D2F:  ADDWF  2C,W
0D30:  MOVWF  04
0D31:  MOVLW  20
0D32:  MOVWF  05
0D33:  BTFSC  03.0
0D34:  INCF   05,F
0D35:  MOVF   00,W
0D36:  MOVWF  2F
0D37:  MOVF   2E,W
0D38:  MOVWF  05
0D39:  MOVF   2D,W
0D3A:  MOVWF  04
0D3B:  MOVF   2F,W
0D3C:  MOVWF  00
....................                   index_identifier_msg += 1; 
0D3D:  MOVLW  01
0D3E:  MOVLB  00
0D3F:  ADDWF  5D,F
0D40:  MOVLB  02
....................                } 
0D41:  INCF   2C,F
0D42:  GOTO   503
....................             } 
....................              
....................             // select between commands 
....................             ////// ANOUT Command ////// 
....................             if ( (strcmp(identifier_msg, CMD_1) == 0) || (strcmp(identifier_msg, CMD_1_1) == 0) )  
0D43:  MOVLW  20
0D44:  MOVWF  2E
0D45:  MOVLW  33
0D46:  MOVWF  2D
0D47:  MOVLW  20
0D48:  MOVWF  30
0D49:  MOVLW  48
0D4A:  MOVWF  2F
0D4B:  MOVLP  00
0D4C:  MOVLB  00
0D4D:  CALL   372
0D4E:  MOVLP  08
0D4F:  MOVF   78,F
0D50:  BTFSC  03.2
0D51:  GOTO   562
0D52:  MOVLW  20
0D53:  MOVLB  02
0D54:  MOVWF  2E
0D55:  MOVLW  33
0D56:  MOVWF  2D
0D57:  MOVLW  20
0D58:  MOVWF  30
0D59:  MOVLW  52
0D5A:  MOVWF  2F
0D5B:  MOVLP  00
0D5C:  MOVLB  00
0D5D:  CALL   372
0D5E:  MOVLP  08
0D5F:  MOVF   78,F
0D60:  BTFSS  03.2
0D61:  GOTO   566
....................             { 
....................                Manage_ANOUT_Command(); 
0D62:  MOVLP  00
0D63:  GOTO   555
0D64:  MOVLP  08
....................             } 
0D65:  GOTO   601
....................              
....................             ////// PWMPERIOD Command ////// 
....................             else if ( (strcmp(identifier_msg, CMD_2) == 0) || (strcmp(identifier_msg, CMD_2_2) == 0) )  
0D66:  MOVLW  20
0D67:  MOVLB  02
0D68:  MOVWF  2E
0D69:  MOVLW  33
0D6A:  MOVWF  2D
0D6B:  MOVLW  20
0D6C:  MOVWF  30
0D6D:  MOVLW  5C
0D6E:  MOVWF  2F
0D6F:  MOVLP  00
0D70:  MOVLB  00
0D71:  CALL   372
0D72:  MOVLP  08
0D73:  MOVF   78,F
0D74:  BTFSC  03.2
0D75:  GOTO   586
0D76:  MOVLW  20
0D77:  MOVLB  02
0D78:  MOVWF  2E
0D79:  MOVLW  33
0D7A:  MOVWF  2D
0D7B:  MOVLW  20
0D7C:  MOVWF  30
0D7D:  MOVLW  66
0D7E:  MOVWF  2F
0D7F:  MOVLP  00
0D80:  MOVLB  00
0D81:  CALL   372
0D82:  MOVLP  08
0D83:  MOVF   78,F
0D84:  BTFSS  03.2
0D85:  GOTO   588
....................             { 
....................                Manage_PWMPERIOD_Command(); 
0D86:  GOTO   000
....................             } 
0D87:  GOTO   601
....................              
....................             ////// PWMDUTY Command ////// 
....................             else if ( (strcmp(identifier_msg, CMD_3) == 0) || (strcmp(identifier_msg, CMD_3_3) == 0) )  
0D88:  MOVLW  20
0D89:  MOVLB  02
0D8A:  MOVWF  2E
0D8B:  MOVLW  33
0D8C:  MOVWF  2D
0D8D:  MOVLW  20
0D8E:  MOVWF  30
0D8F:  MOVLW  70
0D90:  MOVWF  2F
0D91:  MOVLP  00
0D92:  MOVLB  00
0D93:  CALL   372
0D94:  MOVLP  08
0D95:  MOVF   78,F
0D96:  BTFSC  03.2
0D97:  GOTO   5A8
0D98:  MOVLW  20
0D99:  MOVLB  02
0D9A:  MOVWF  2E
0D9B:  MOVLW  33
0D9C:  MOVWF  2D
0D9D:  MOVLW  20
0D9E:  MOVWF  30
0D9F:  MOVLW  7A
0DA0:  MOVWF  2F
0DA1:  MOVLP  00
0DA2:  MOVLB  00
0DA3:  CALL   372
0DA4:  MOVLP  08
0DA5:  MOVF   78,F
0DA6:  BTFSS  03.2
0DA7:  GOTO   5AA
....................             { 
....................                Manage_PWMDUTY_Command(); 
0DA8:  GOTO   118
....................             } 
0DA9:  GOTO   601
....................              
....................             ////// ABOUT Command ////// 
....................             else if ( (strcmp(identifier_msg, CMD_4) == 0) || (strcmp(identifier_msg, CMD_4_4) == 0) ) 
0DAA:  MOVLW  20
0DAB:  MOVLB  02
0DAC:  MOVWF  2E
0DAD:  MOVLW  33
0DAE:  MOVWF  2D
0DAF:  MOVLW  20
0DB0:  MOVWF  30
0DB1:  MOVLW  84
0DB2:  MOVWF  2F
0DB3:  MOVLP  00
0DB4:  MOVLB  00
0DB5:  CALL   372
0DB6:  MOVLP  08
0DB7:  MOVF   78,F
0DB8:  BTFSC  03.2
0DB9:  GOTO   5CA
0DBA:  MOVLW  20
0DBB:  MOVLB  02
0DBC:  MOVWF  2E
0DBD:  MOVLW  33
0DBE:  MOVWF  2D
0DBF:  MOVLW  20
0DC0:  MOVWF  30
0DC1:  MOVLW  8E
0DC2:  MOVWF  2F
0DC3:  MOVLP  00
0DC4:  MOVLB  00
0DC5:  CALL   372
0DC6:  MOVLP  08
0DC7:  MOVF   78,F
0DC8:  BTFSS  03.2
0DC9:  GOTO   5CE
....................             { 
....................                Manage_ABOUT_Command(); 
0DCA:  MOVLP  00
0DCB:  GOTO   712
0DCC:  MOVLP  08
....................             } 
0DCD:  GOTO   601
....................              
....................             ////// HELP command ////// 
....................             else if ( (strcmp(identifier_msg, CMD_5) == 0) || (strcmp(identifier_msg, CMD_5_5) == 0) )  
0DCE:  MOVLW  20
0DCF:  MOVLB  02
0DD0:  MOVWF  2E
0DD1:  MOVLW  33
0DD2:  MOVWF  2D
0DD3:  MOVLW  20
0DD4:  MOVWF  30
0DD5:  MOVLW  98
0DD6:  MOVWF  2F
0DD7:  MOVLP  00
0DD8:  MOVLB  00
0DD9:  CALL   372
0DDA:  MOVLP  08
0DDB:  MOVF   78,F
0DDC:  BTFSC  03.2
0DDD:  GOTO   5EE
0DDE:  MOVLW  20
0DDF:  MOVLB  02
0DE0:  MOVWF  2E
0DE1:  MOVLW  33
0DE2:  MOVWF  2D
0DE3:  MOVLW  20
0DE4:  MOVWF  30
0DE5:  MOVLW  A2
0DE6:  MOVWF  2F
0DE7:  MOVLP  00
0DE8:  MOVLB  00
0DE9:  CALL   372
0DEA:  MOVLP  08
0DEB:  MOVF   78,F
0DEC:  BTFSS  03.2
0DED:  GOTO   5F2
....................             { 
....................                Manage_HELP_Command(); 
0DEE:  MOVLP  00
0DEF:  GOTO   73B
0DF0:  MOVLP  08
....................             } 
0DF1:  GOTO   601
....................              
....................             else 
....................             { 
....................                // the identifier of the command is not recognized 
....................                printf("ERROR\r\n"); 
0DF2:  MOVLW  6A
0DF3:  MOVLB  03
0DF4:  MOVWF  11
0DF5:  MOVLW  03
0DF6:  MOVWF  12
0DF7:  MOVLB  00
0DF8:  CLRF   28
0DF9:  BTFSC  0B.7
0DFA:  BSF    28.7
0DFB:  BCF    0B.7
0DFC:  MOVLP  00
0DFD:  CALL   174
0DFE:  MOVLP  08
0DFF:  BTFSC  28.7
0E00:  BSF    0B.7
....................             } 
....................              
....................             #ifdef __DEBUG__ 
....................             Print_Buffers(); // to view buffer's info in debugging 
....................             #endif 
....................          } 
0E01:  GOTO   611
....................          else 
....................          { 
....................             // the structure of the command is not correct 
....................             printf("ERROR\r\n"); 
0E02:  MOVLW  6E
0E03:  MOVLB  03
0E04:  MOVWF  11
0E05:  MOVLW  03
0E06:  MOVWF  12
0E07:  MOVLB  00
0E08:  CLRF   28
0E09:  BTFSC  0B.7
0E0A:  BSF    28.7
0E0B:  BCF    0B.7
0E0C:  MOVLP  00
0E0D:  CALL   174
0E0E:  MOVLP  08
0E0F:  BTFSC  28.7
0E10:  BSF    0B.7
....................          } 
....................           
....................          // clear the buffers 
....................          Clear_Buffers(); 
0E11:  MOVLP  00
0E12:  GOTO   798
0E13:  MOVLP  08
....................          // clear the flag 
....................          NEW_MSG_RECEIVED_FLAG = false; 
0E14:  CLRF   70
....................       } 
....................       else 
....................       { 
....................          // do nothing 
....................       } 
0E15:  GOTO   4E7
....................    } 
.................... } 
0E16:  SLEEP

Configuration Fuses:
   Word  1: 39C2   HS NOWDT PUT MCLR NOPROTECT NOCPD NOBROWNOUT NOCLKOUT IESO FCMEN
   Word  2: 1EFF   NOWRT NOVCAP PLL_SW STVREN BORV19 NODEBUG NOLVP
