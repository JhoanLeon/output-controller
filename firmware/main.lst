CCS PCM C Compiler, Version 5.015, 5967               26-ago.-22 20:52

               Filename:   D:\Proyectos\output_controller\firmware\main.lst

               ROM used:   3063 words (19%)
                           Largest free fragment is 2048
               RAM used:   183 (18%) at main() level
                           216 (21%) worst case
               Stack used: 4 locations (2 in main + 2 for interrupts)
               Stack size: 16

*
0000:  MOVLP  08
0001:  GOTO   000
0002:  NOP
*
0004:  CLRF   03
0005:  MOVLP  00
0006:  MOVLB  00
0007:  MOVF   77,W
0008:  MOVWF  20
0009:  MOVF   78,W
000A:  MOVWF  21
000B:  MOVF   79,W
000C:  MOVWF  22
000D:  MOVF   7A,W
000E:  MOVWF  23
000F:  MOVLB  03
0010:  MOVF   11,W
0011:  MOVLB  00
0012:  MOVWF  24
0013:  MOVLB  03
0014:  MOVF   12,W
0015:  MOVLB  00
0016:  MOVWF  25
0017:  MOVLB  03
0018:  MOVF   13,W
0019:  MOVLB  00
001A:  MOVWF  26
001B:  MOVLB  03
001C:  MOVF   14,W
001D:  MOVLB  00
001E:  MOVWF  27
001F:  CLRF   05
0020:  MOVLW  91
0021:  MOVWF  04
0022:  BTFSS  00.1
0023:  GOTO   026
0024:  BTFSC  11.1
0025:  GOTO   046
0026:  CLRF   05
0027:  MOVLW  91
0028:  MOVWF  04
0029:  BTFSS  00.5
002A:  GOTO   02D
002B:  BTFSC  11.5
002C:  GOTO   048
002D:  MOVF   20,W
002E:  MOVWF  77
002F:  MOVF   21,W
0030:  MOVWF  78
0031:  MOVF   22,W
0032:  MOVWF  79
0033:  MOVF   23,W
0034:  MOVWF  7A
0035:  MOVF   24,W
0036:  MOVLB  03
0037:  MOVWF  11
0038:  MOVLB  00
0039:  MOVF   25,W
003A:  MOVLB  03
003B:  MOVWF  12
003C:  MOVLB  00
003D:  MOVF   26,W
003E:  MOVLB  03
003F:  MOVWF  13
0040:  MOVLB  00
0041:  MOVF   27,W
0042:  MOVLB  03
0043:  MOVWF  14
0044:  RETFIE
0045:  MOVLB  00
0046:  MOVLP  00
0047:  GOTO   088
0048:  MOVLP  00
0049:  GOTO   1C6
.................... #include <main.h> 
.................... #include <16F1939.h> 
.................... //////////// Standard Header file for the PIC16F1939 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F1939 
004A:  CLRF   78
004B:  CLRF   79
004C:  CLRF   77
004D:  CLRF   7A
004E:  MOVLB  02
004F:  MOVF   44,W
0050:  BTFSS  03.2
0051:  GOTO   055
0052:  MOVF   43,W
0053:  BTFSC  03.2
0054:  GOTO   06F
0055:  MOVLW  10
0056:  MOVWF  45
0057:  BCF    03.0
0058:  RLF    41,F
0059:  RLF    42,F
005A:  RLF    77,F
005B:  RLF    7A,F
005C:  MOVF   44,W
005D:  SUBWF  7A,W
005E:  BTFSS  03.2
005F:  GOTO   062
0060:  MOVF   43,W
0061:  SUBWF  77,W
0062:  BTFSS  03.0
0063:  GOTO   06B
0064:  MOVF   43,W
0065:  SUBWF  77,F
0066:  BTFSS  03.0
0067:  DECF   7A,F
0068:  MOVF   44,W
0069:  SUBWF  7A,F
006A:  BSF    03.0
006B:  RLF    78,F
006C:  RLF    79,F
006D:  DECFSZ 45,F
006E:  GOTO   057
006F:  MOVLB  00
0070:  RETURN
0071:  MOVLW  10
0072:  MOVLB  02
0073:  MOVWF  47
0074:  CLRF   77
0075:  CLRF   7A
0076:  RRF    44,F
0077:  RRF    43,F
0078:  BTFSS  03.0
0079:  GOTO   080
007A:  MOVF   45,W
007B:  ADDWF  77,F
007C:  BTFSC  03.0
007D:  INCF   7A,F
007E:  MOVF   46,W
007F:  ADDWF  7A,F
0080:  RRF    7A,F
0081:  RRF    77,F
0082:  RRF    79,F
0083:  RRF    78,F
0084:  DECFSZ 47,F
0085:  GOTO   076
0086:  MOVLB  00
0087:  RETURN
*
0174:  MOVF   0B,W
0175:  BCF    0B.7
0176:  MOVLB  03
0177:  BSF    15.7
0178:  BSF    15.0
0179:  NOP
017A:  NOP
017B:  BTFSC  09.7
017C:  BSF    0B.7
017D:  MOVF   13,W
017E:  ANDLW  7F
017F:  BTFSC  03.2
0180:  GOTO   1C4
0181:  MOVLB  02
0182:  MOVWF  41
0183:  MOVLB  03
0184:  MOVF   11,W
0185:  MOVLB  02
0186:  MOVWF  42
0187:  MOVLB  03
0188:  MOVF   12,W
0189:  MOVLB  02
018A:  MOVWF  43
018B:  MOVF   41,W
018C:  MOVLB  00
018D:  BTFSS  11.4
018E:  GOTO   18D
018F:  MOVLB  03
0190:  MOVWF  1A
0191:  MOVLB  02
0192:  MOVF   42,W
0193:  MOVLB  03
0194:  MOVWF  11
0195:  MOVLB  02
0196:  MOVF   43,W
0197:  MOVLB  03
0198:  MOVWF  12
0199:  MOVF   0B,W
019A:  BCF    0B.7
019B:  BSF    15.7
019C:  BSF    15.0
019D:  NOP
019E:  NOP
019F:  BTFSC  09.7
01A0:  BSF    0B.7
01A1:  RLF    13,W
01A2:  RLF    14,W
01A3:  ANDLW  7F
01A4:  BTFSC  03.2
01A5:  GOTO   1C4
01A6:  MOVLB  02
01A7:  MOVWF  41
01A8:  MOVLB  03
01A9:  MOVF   11,W
01AA:  MOVLB  02
01AB:  MOVWF  42
01AC:  MOVLB  03
01AD:  MOVF   12,W
01AE:  MOVLB  02
01AF:  MOVWF  43
01B0:  MOVF   41,W
01B1:  MOVLB  00
01B2:  BTFSS  11.4
01B3:  GOTO   1B2
01B4:  MOVLB  03
01B5:  MOVWF  1A
01B6:  MOVLB  02
01B7:  MOVF   42,W
01B8:  MOVLB  03
01B9:  MOVWF  11
01BA:  MOVLB  02
01BB:  MOVF   43,W
01BC:  MOVLB  03
01BD:  MOVWF  12
01BE:  INCF   11,F
01BF:  BTFSC  03.2
01C0:  INCF   12,F
01C1:  MOVLB  00
01C2:  GOTO   174
01C3:  MOVLB  03
01C4:  MOVLB  00
01C5:  RETURN
*
021E:  DATA 45,29
021F:  DATA D2,27
0220:  DATA D2,06
0221:  DATA 0A,00
0222:  DATA 45,29
0223:  DATA D2,27
0224:  DATA D2,06
0225:  DATA 0A,00
0226:  DATA 45,29
0227:  DATA D2,27
0228:  DATA D2,06
0229:  DATA 0A,00
022A:  DATA D2,22
022B:  DATA 41,22
022C:  DATA D9,06
022D:  DATA 0A,00
022E:  DATA CF,25
022F:  DATA 0D,05
0230:  DATA 00,00
0231:  DATA 2B,28
0232:  DATA D7,26
0233:  DATA D0,22
0234:  DATA D2,24
0235:  DATA 4F,22
0236:  DATA BA,12
0237:  DATA D8,12
0238:  DATA D8,06
0239:  DATA 0A,00
023A:  DATA CF,25
023B:  DATA 0D,05
023C:  DATA 00,01
023D:  DATA 2B,28
023E:  DATA D7,26
023F:  DATA D0,22
0240:  DATA D2,24
0241:  DATA 4F,22
0242:  DATA BA,12
0243:  DATA D8,12
0244:  DATA D8,06
0245:  DATA 0A,00
0246:  DATA CF,25
0247:  DATA 0D,05
0248:  DATA 00,01
0249:  DATA 45,29
024A:  DATA D2,27
024B:  DATA D2,06
024C:  DATA 0A,00
024D:  DATA 2B,28
024E:  DATA D7,26
024F:  DATA C4,2A
0250:  DATA D4,2C
0251:  DATA BA,18
0252:  DATA AC,12
0253:  DATA D8,12
0254:  DATA 58,16
0255:  DATA 32,16
0256:  DATA 25,2C
0257:  DATA 25,2C
0258:  DATA AC,19
0259:  DATA AC,12
025A:  DATA D8,12
025B:  DATA 58,16
025C:  DATA 34,16
025D:  DATA 25,2C
025E:  DATA 25,2C
025F:  DATA 0D,05
0260:  DATA 00,01
0261:  DATA CF,25
0262:  DATA 0D,05
0263:  DATA 00,01
0264:  DATA 2B,28
0265:  DATA D7,26
0266:  DATA C4,2A
0267:  DATA D4,2C
0268:  DATA 31,1D
0269:  DATA 25,2C
026A:  DATA 25,2C
026B:  DATA 0D,05
026C:  DATA 00,01
026D:  DATA 2B,28
026E:  DATA D7,26
026F:  DATA C4,2A
0270:  DATA D4,2C
0271:  DATA 32,1D
0272:  DATA 25,2C
0273:  DATA 25,2C
0274:  DATA 0D,05
0275:  DATA 00,01
0276:  DATA 2B,28
0277:  DATA D7,26
0278:  DATA C4,2A
0279:  DATA D4,2C
027A:  DATA 33,1D
027B:  DATA 25,2C
027C:  DATA 25,2C
027D:  DATA 0D,05
027E:  DATA 00,01
027F:  DATA 2B,28
0280:  DATA D7,26
0281:  DATA C4,2A
0282:  DATA D4,2C
0283:  DATA 34,1D
0284:  DATA 25,2C
0285:  DATA 25,2C
0286:  DATA 0D,05
0287:  DATA 00,01
0288:  DATA 45,29
0289:  DATA D2,27
028A:  DATA D2,06
028B:  DATA 0A,00
028C:  DATA 45,29
028D:  DATA D2,27
028E:  DATA D2,06
028F:  DATA 0A,00
0290:  DATA CF,25
0291:  DATA 0D,05
0292:  DATA 00,01
0293:  DATA 45,29
0294:  DATA D2,27
0295:  DATA D2,06
0296:  DATA 0A,00
0297:  DATA D6,32
0298:  DATA F2,39
0299:  DATA E9,37
029A:  DATA 6E,1D
029B:  DATA A0,18
029C:  DATA 2E,18
029D:  DATA 0D,05
029E:  DATA 00,01
029F:  DATA C4,30
02A0:  DATA F4,32
02A1:  DATA 3A,10
02A2:  DATA 32,1B
02A3:  DATA 2F,18
02A4:  DATA B8,17
02A5:  DATA 32,18
02A6:  DATA 32,19
02A7:  DATA 0D,05
02A8:  DATA 00,01
02A9:  DATA CF,25
02AA:  DATA 0D,05
02AB:  DATA 00,01
02AC:  DATA 41,2A
02AD:  DATA 20,10
02AE:  DATA C3,37
02AF:  DATA ED,30
02B0:  DATA 6E,32
02B1:  DATA 6F,10
02B2:  DATA E4,32
02B3:  DATA 20,38
02B4:  DATA F2,3A
02B5:  DATA 65,31
02B6:  DATA E1,06
02B7:  DATA 0A,00
02B8:  DATA 41,2A
02B9:  DATA AB,20
02BA:  DATA CE,27
02BB:  DATA 55,2A
02BC:  DATA 20,10
02BD:  DATA D0,30
02BE:  DATA F2,30
02BF:  DATA A0,32
02C0:  DATA 73,3A
02C1:  DATA 61,31
02C2:  DATA EC,32
02C3:  DATA E3,32
02C4:  DATA 72,10
02C5:  DATA F3,30
02C6:  DATA EC,34
02C7:  DATA E4,30
02C8:  DATA 73,10
02C9:  DATA 61,37
02CA:  DATA 61,36
02CB:  DATA EF,33
02CC:  DATA E1,39
02CD:  DATA 0D,05
02CE:  DATA 00,01
02CF:  DATA 41,2A
02D0:  DATA 2B,28
02D1:  DATA D7,26
02D2:  DATA D0,22
02D3:  DATA D2,24
02D4:  DATA 4F,22
02D5:  DATA 20,10
02D6:  DATA D0,30
02D7:  DATA F2,30
02D8:  DATA A0,32
02D9:  DATA 73,3A
02DA:  DATA 61,31
02DB:  DATA EC,32
02DC:  DATA E3,32
02DD:  DATA 72,10
02DE:  DATA F0,32
02DF:  DATA F2,34
02E0:  DATA 6F,32
02E1:  DATA 6F,10
02E2:  DATA E4,32
02E3:  DATA A0,31
02E4:  DATA 61,37
02E5:  DATA 61,36
02E6:  DATA E5,39
02E7:  DATA 20,28
02E8:  DATA D7,26
02E9:  DATA 0D,05
02EA:  DATA 00,01
02EB:  DATA 41,2A
02EC:  DATA 2B,28
02ED:  DATA D7,26
02EE:  DATA C4,2A
02EF:  DATA D4,2C
02F0:  DATA 20,10
02F1:  DATA D0,30
02F2:  DATA F2,30
02F3:  DATA A0,32
02F4:  DATA 73,3A
02F5:  DATA 61,31
02F6:  DATA EC,32
02F7:  DATA E3,32
02F8:  DATA 72,10
02F9:  DATA E3,34
02FA:  DATA 63,36
02FB:  DATA 6F,10
02FC:  DATA E4,32
02FD:  DATA 20,3A
02FE:  DATA F2,30
02FF:  DATA E2,30
0300:  DATA EA,37
0301:  DATA 20,32
0302:  DATA 65,10
0303:  DATA E3,30
0304:  DATA EE,30
0305:  DATA EC,32
0306:  DATA 73,10
0307:  DATA D0,2B
0308:  DATA CD,06
0309:  DATA 0A,00
030A:  DATA 41,2A
030B:  DATA AB,20
030C:  DATA C2,27
030D:  DATA 55,2A
030E:  DATA 20,10
030F:  DATA D0,30
0310:  DATA F2,30
0311:  DATA A0,36
0312:  DATA EF,39
0313:  DATA 74,39
0314:  DATA 61,39
0315:  DATA A0,34
0316:  DATA 6E,33
0317:  DATA 6F,39
0318:  DATA ED,30
0319:  DATA E3,34
031A:  DATA 6F,37
031B:  DATA 20,32
031C:  DATA 65,36
031D:  DATA 20,38
031E:  DATA F2,37
031F:  DATA E4,3A
0320:  DATA 63,3A
0321:  DATA EF,06
0322:  DATA 0A,00
0323:  DATA 41,2A
0324:  DATA 2B,24
0325:  DATA 45,26
0326:  DATA 50,10
0327:  DATA 20,28
0328:  DATA 61,39
0329:  DATA 61,10
032A:  DATA ED,37
032B:  DATA 73,3A
032C:  DATA F2,30
032D:  DATA 72,10
032E:  DATA EC,34
032F:  DATA 73,3A
0330:  DATA 61,10
0331:  DATA E4,32
0332:  DATA A0,31
0333:  DATA EF,36
0334:  DATA 61,37
0335:  DATA E4,37
0336:  DATA F3,06
0337:  DATA 0A,00
0338:  DATA CF,25
0339:  DATA 0D,05
033A:  DATA 00,01
033B:  DATA 45,29
033C:  DATA D2,27
033D:  DATA D2,06
033E:  DATA 0A,00
033F:  DATA 45,29
0340:  DATA D2,27
0341:  DATA D2,06
0342:  DATA 0A,00
*
0384:  MOVF   00,F
0385:  BTFSC  03.2
0386:  GOTO   39A
0387:  MOVF   05,W
0388:  MOVLB  02
0389:  MOVWF  33
038A:  MOVF   04,W
038B:  MOVWF  32
038C:  MOVF   00,W
038D:  MOVLB  00
038E:  BTFSS  11.4
038F:  GOTO   38E
0390:  MOVLB  03
0391:  MOVWF  1A
0392:  MOVLB  02
0393:  MOVF   33,W
0394:  MOVWF  05
0395:  MOVF   32,W
0396:  MOVWF  04
0397:  ADDFSR 01,FSR0
0398:  MOVLB  00
0399:  GOTO   384
039A:  MOVLP  08
039B:  GOTO   187 (RETURN)
039C:  MOVF   0B,W
039D:  BCF    0B.7
039E:  MOVLB  03
039F:  BSF    15.7
03A0:  BSF    15.0
03A1:  NOP
03A2:  NOP
03A3:  BTFSC  09.7
03A4:  BSF    0B.7
03A5:  BTFSC  03.0
03A6:  GOTO   3D1
03A7:  MOVF   13,W
03A8:  ANDLW  7F
03A9:  MOVLB  02
03AA:  MOVWF  37
03AB:  MOVLB  03
03AC:  MOVF   11,W
03AD:  MOVLB  02
03AE:  MOVWF  38
03AF:  MOVLB  03
03B0:  MOVF   12,W
03B1:  MOVLB  02
03B2:  MOVWF  39
03B3:  MOVF   37,W
03B4:  MOVLB  00
03B5:  BTFSS  11.4
03B6:  GOTO   3B5
03B7:  MOVLB  03
03B8:  MOVWF  1A
03B9:  MOVLB  02
03BA:  MOVF   38,W
03BB:  MOVLB  03
03BC:  MOVWF  11
03BD:  MOVLB  02
03BE:  MOVF   39,W
03BF:  MOVLB  03
03C0:  MOVWF  12
03C1:  MOVF   0B,W
03C2:  BCF    0B.7
03C3:  BSF    15.7
03C4:  BSF    15.0
03C5:  NOP
03C6:  NOP
03C7:  BTFSC  09.7
03C8:  BSF    0B.7
03C9:  MOVLB  02
03CA:  DECFSZ 36,F
03CB:  GOTO   3CD
03CC:  GOTO   3CF
03CD:  MOVLB  03
03CE:  GOTO   3D1
03CF:  GOTO   3F6
03D0:  MOVLB  03
03D1:  RLF    13,W
03D2:  RLF    14,W
03D3:  ANDLW  7F
03D4:  MOVLB  02
03D5:  MOVWF  37
03D6:  MOVLB  03
03D7:  MOVF   11,W
03D8:  MOVLB  02
03D9:  MOVWF  38
03DA:  MOVLB  03
03DB:  MOVF   12,W
03DC:  MOVLB  02
03DD:  MOVWF  39
03DE:  MOVF   37,W
03DF:  MOVLB  00
03E0:  BTFSS  11.4
03E1:  GOTO   3E0
03E2:  MOVLB  03
03E3:  MOVWF  1A
03E4:  MOVLB  02
03E5:  MOVF   38,W
03E6:  MOVLB  03
03E7:  MOVWF  11
03E8:  MOVLB  02
03E9:  MOVF   39,W
03EA:  MOVLB  03
03EB:  MOVWF  12
03EC:  INCF   11,F
03ED:  BTFSC  03.2
03EE:  INCF   12,F
03EF:  BCF    03.0
03F0:  MOVLB  02
03F1:  DECFSZ 36,F
03F2:  GOTO   3F4
03F3:  GOTO   3F6
03F4:  MOVLB  00
03F5:  GOTO   39C
03F6:  MOVLB  00
03F7:  RETURN
03F8:  MOVLB  02
03F9:  BTFSC  37.7
03FA:  GOTO   40F
03FB:  MOVLW  0F
03FC:  MOVWF  77
03FD:  SWAPF  36,W
03FE:  ANDWF  77,F
03FF:  MOVLW  0A
0400:  SUBWF  77,W
0401:  BTFSC  03.0
0402:  GOTO   406
0403:  MOVLW  30
0404:  ADDWF  77,F
0405:  GOTO   408
0406:  MOVF   37,W
0407:  ADDWF  77,F
0408:  MOVF   77,W
0409:  MOVLB  00
040A:  BTFSS  11.4
040B:  GOTO   40A
040C:  MOVLB  03
040D:  MOVWF  1A
040E:  MOVLB  02
040F:  MOVLW  0F
0410:  ANDWF  36,F
0411:  MOVLW  0A
0412:  SUBWF  36,W
0413:  BTFSC  03.0
0414:  GOTO   417
0415:  MOVLW  30
0416:  GOTO   419
0417:  BCF    37.7
0418:  MOVF   37,W
0419:  ADDWF  36,F
041A:  MOVF   36,W
041B:  MOVLB  00
041C:  BTFSS  11.4
041D:  GOTO   41C
041E:  MOVLB  03
041F:  MOVWF  1A
0420:  MOVLB  00
0421:  RETURN
*
04B8:  BCF    0A.0
04B9:  BCF    0A.1
04BA:  BSF    0A.2
04BB:  ADDWF  02,F
04BC:  GOTO   431
04BD:  GOTO   436
04BE:  GOTO   43B
04BF:  GOTO   440
04C0:  GOTO   445
04C1:  GOTO   44A
04C2:  GOTO   44F
04C3:  GOTO   454
04C4:  GOTO   459
04C5:  GOTO   47C
04C6:  GOTO   47C
04C7:  GOTO   47C
04C8:  GOTO   47C
04C9:  GOTO   47C
04CA:  GOTO   47C
04CB:  GOTO   47C
04CC:  GOTO   45E
04CD:  GOTO   463
04CE:  GOTO   468
04CF:  GOTO   46D
04D0:  GOTO   472
04D1:  GOTO   477
04D2:  BCF    0A.0
04D3:  BCF    0A.1
04D4:  BSF    0A.2
04D5:  ADDWF  02,F
04D6:  GOTO   484
04D7:  GOTO   489
04D8:  GOTO   48E
04D9:  GOTO   493
....................  
.................... #list 
....................  
.................... #device ADC=16 
....................  
.................... #FUSES NOWDT                    // no Watch Dog Timer 
.................... #FUSES NOBROWNOUT               // no brownout reset 
.................... #FUSES NOLVP                    // no low voltage programming, B3(PIC16) or B5(PIC18) used for I/O 
....................  
.................... #use delay(crystal=20000000)  // external crystal clock 
....................  
.................... // I/O pin configurations 
.................... #use STANDARD_IO( B ) 
.................... #use FIXED_IO( B_outputs=PIN_B4,PIN_B5 ) 
.................... #use STANDARD_IO( D ) 
.................... #use FIXED_IO( D_outputs=PIN_D3,PIN_D1 ) 
....................  
.................... // Pin definitions 
.................... #define USER_LED     PIN_B4 
.................... #define COMMS_LED    PIN_B5 
.................... #define CS_PIN       PIN_D3  
....................  
.................... #define PWM1_PIN     PIN_C2 
.................... #define PWM2_PIN     PIN_C1 
.................... #define PWM3_PIN     PIN_E0 
.................... #define PWM4_PIN     PIN_D1 
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
0343:  MOVLB  02
0344:  MOVF   33,W
0345:  MOVWF  7A
0346:  MOVF   32,W
0347:  MOVWF  04
0348:  MOVF   7A,W
0349:  MOVWF  05
034A:  MOVF   00,W
034B:  MOVWF  36
034C:  MOVF   35,W
034D:  MOVWF  7A
034E:  MOVF   34,W
034F:  MOVWF  04
0350:  MOVF   7A,W
0351:  MOVWF  05
0352:  MOVF   00,W
0353:  SUBWF  36,W
0354:  BTFSS  03.2
0355:  GOTO   36C
....................       if (*s1 == '\0') 
0356:  MOVF   33,W
0357:  MOVWF  7A
0358:  MOVF   32,W
0359:  MOVWF  04
035A:  MOVF   7A,W
035B:  MOVWF  05
035C:  MOVF   00,F
035D:  BTFSS  03.2
035E:  GOTO   362
....................          return(0); 
035F:  MOVLW  00
0360:  MOVWF  78
0361:  GOTO   382
0362:  MOVF   33,W
0363:  MOVWF  7A
0364:  MOVF   32,W
0365:  INCF   32,F
0366:  BTFSC  03.2
0367:  INCF   33,F
0368:  INCF   34,F
0369:  BTFSC  03.2
036A:  INCF   35,F
036B:  GOTO   344
....................    return((*s1 < *s2) ? -1: 1); 
036C:  MOVF   33,W
036D:  MOVWF  7A
036E:  MOVF   32,W
036F:  MOVWF  04
0370:  MOVF   33,W
0371:  MOVWF  05
0372:  MOVF   00,W
0373:  MOVWF  36
0374:  MOVF   35,W
0375:  MOVWF  7A
0376:  MOVF   34,W
0377:  MOVWF  04
0378:  MOVF   35,W
0379:  MOVWF  05
037A:  MOVF   00,W
037B:  SUBWF  36,W
037C:  BTFSC  03.0
037D:  GOTO   380
037E:  MOVLW  FF
037F:  GOTO   381
0380:  MOVLW  01
0381:  MOVWF  78
0382:  MOVLB  00
0383:  RETURN
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define __DEBUG__ 
....................  
.................... // Configuration of communication peripherals 
.................... #use rs232(baud=9600,xmit=PIN_C6,rcv=PIN_C7,bits=8,parity=N) 
*
04DA:  BTFSS  11.4
04DB:  GOTO   4DA
04DC:  MOVLB  03
04DD:  MOVWF  1A
04DE:  MOVLB  00
04DF:  RETURN
.................... #use SPI (MASTER, SPI1, BAUD=5000000, MODE=2, BITS=8, STREAM=SPI_1, MSB_FIRST) 
....................  
.................... // Define variables 
.................... unsigned int16 pwm_counter = 0; // counter of timer2 timebase 
.................... unsigned int16 desired_pwm_period = 6579; // 100ms 
....................  
.................... unsigned int16 desired_dutycycle_pwm1 = 25; // 0-100% 
.................... unsigned int16 desired_dutycycle_pwm2 = 50; // 0-100% 
.................... unsigned int16 desired_dutycycle_pwm3 = 75; // 0-100% 
.................... unsigned int16 desired_dutycycle_pwm4 = 100; // 0-100% 
....................  
.................... unsigned int16 desired_anout1_value = 0; // 0x0000 - 0xFFFF 
.................... unsigned int16 desired_anout2_value = 0; // 0x0000 - 0xFFFF 
....................  
.................... // Variables to UART communications 
.................... unsigned char char_received = 0; // variable to save chars received by UART 
....................  
.................... unsigned char rx_msg[20] = {0}; // buffer to receive UART messages 
.................... unsigned int8 index_rx_msg = 0; // index to manage the rx_msg buffer 
....................  
.................... unsigned char identifier_msg[10] = {0}; // buffer to receive UART messages 
.................... unsigned int8 index_identifier_msg = 0; // index to manage the identifier_msg buffer 
....................  
.................... unsigned int8 index_reader = 0; // to read received commands 
....................  
.................... char value_msg[5] = {0}; // buffer to save <value> messages 
.................... unsigned int8 index_value_msg = 0; // index to manage the value_msg buffer 
....................  
.................... char desired_pwm_channel = 0; // variable to save the desired channel in the command 
....................  
.................... // StateMachine to UART Protocol 
.................... enum UART_STATES 
.................... { 
....................    ST_WAIT = 0, 
....................    ST_A = 1, 
....................    ST_MSG = 2 
.................... } uart_state; 
....................  
.................... // UART commands identifiers 
.................... char CMD_1[10] = "ANOUT"; 
.................... char CMD_1_1[10] = "anout"; 
.................... char CMD_2[10] = "PWMPERIOD"; 
.................... char CMD_2_2[10] = "pwmperiod";   
.................... char CMD_3[10] = "PWMDUTY"; 
.................... char CMD_3_3[10] = "pwmduty"; 
.................... char CMD_4[10] = "ABOUT"; 
.................... char CMD_4_4[10] = "about"; 
.................... char CMD_5[10] = "HELP"; 
.................... char CMD_5_5[10] = "help"; 
....................  
.................... // Flags to manage events 
.................... volatile int8 NEW_MSG_RECEIVED_FLAG = false; 
....................  
....................  
.................... #INT_TIMER2 
.................... /* 
.................... * ISR Function to generate PWM timebase 
.................... */ 
.................... void ISR_Timer_2(void) 
.................... {    
....................    // set pwm period 
....................    if (pwm_counter == desired_pwm_period) 
*
0088:  MOVF   31,W
0089:  SUBWF  2F,W
008A:  BTFSS  03.2
008B:  GOTO   093
008C:  MOVF   32,W
008D:  SUBWF  30,W
008E:  BTFSS  03.2
008F:  GOTO   093
....................    { 
....................       // reset the counter to get the desired period 
....................       pwm_counter = 0; 
0090:  CLRF   30
0091:  CLRF   2F
....................    } 
0092:  GOTO   097
....................    else 
....................    { 
....................       // count timebase 
....................       pwm_counter += 1; 
0093:  MOVLW  01
0094:  ADDWF  2F,F
0095:  MOVLW  00
0096:  ADDWFC 30,F
....................    } 
....................     
....................    // set pwm outputs 
....................    if (pwm_counter < (desired_pwm_period/100)*desired_dutycycle_pwm1) 
0097:  MOVF   32,W
0098:  MOVLB  02
0099:  MOVWF  42
009A:  MOVLB  00
009B:  MOVF   31,W
009C:  MOVLB  02
009D:  MOVWF  41
009E:  CLRF   44
009F:  MOVLW  64
00A0:  MOVWF  43
00A1:  MOVLB  00
00A2:  CALL   04A
00A3:  MOVF   79,W
00A4:  MOVLB  02
00A5:  MOVWF  42
00A6:  MOVF   78,W
00A7:  MOVWF  41
00A8:  MOVF   42,W
00A9:  MOVWF  44
00AA:  MOVF   41,W
00AB:  MOVWF  43
00AC:  MOVLB  00
00AD:  MOVF   34,W
00AE:  MOVLB  02
00AF:  MOVWF  46
00B0:  MOVLB  00
00B1:  MOVF   33,W
00B2:  MOVLB  02
00B3:  MOVWF  45
00B4:  MOVLB  00
00B5:  CALL   071
00B6:  MOVF   79,W
00B7:  MOVWF  7A
00B8:  MOVF   30,W
00B9:  SUBWF  7A,W
00BA:  BTFSS  03.0
00BB:  GOTO   0C8
00BC:  BTFSS  03.2
00BD:  GOTO   0C2
00BE:  MOVF   78,W
00BF:  SUBWF  2F,W
00C0:  BTFSC  03.0
00C1:  GOTO   0C8
....................    { 
....................       // activate pwm1 output 
....................       output_high(PWM1_PIN); 
00C2:  MOVLB  01
00C3:  BCF    0E.2
00C4:  MOVLB  02
00C5:  BSF    0E.2
....................    } 
00C6:  GOTO   0CC
00C7:  MOVLB  00
....................    else 
....................    { 
....................       output_low(PWM1_PIN); 
00C8:  MOVLB  01
00C9:  BCF    0E.2
00CA:  MOVLB  02
00CB:  BCF    0E.2
....................    } 
....................     
....................    if (pwm_counter < (desired_pwm_period/100)*desired_dutycycle_pwm2) 
00CC:  MOVLB  00
00CD:  MOVF   32,W
00CE:  MOVLB  02
00CF:  MOVWF  42
00D0:  MOVLB  00
00D1:  MOVF   31,W
00D2:  MOVLB  02
00D3:  MOVWF  41
00D4:  CLRF   44
00D5:  MOVLW  64
00D6:  MOVWF  43
00D7:  MOVLB  00
00D8:  CALL   04A
00D9:  MOVF   79,W
00DA:  MOVLB  02
00DB:  MOVWF  42
00DC:  MOVF   78,W
00DD:  MOVWF  41
00DE:  MOVF   42,W
00DF:  MOVWF  44
00E0:  MOVF   41,W
00E1:  MOVWF  43
00E2:  MOVLB  00
00E3:  MOVF   36,W
00E4:  MOVLB  02
00E5:  MOVWF  46
00E6:  MOVLB  00
00E7:  MOVF   35,W
00E8:  MOVLB  02
00E9:  MOVWF  45
00EA:  MOVLB  00
00EB:  CALL   071
00EC:  MOVF   79,W
00ED:  MOVWF  7A
00EE:  MOVF   30,W
00EF:  SUBWF  7A,W
00F0:  BTFSS  03.0
00F1:  GOTO   0FE
00F2:  BTFSS  03.2
00F3:  GOTO   0F8
00F4:  MOVF   78,W
00F5:  SUBWF  2F,W
00F6:  BTFSC  03.0
00F7:  GOTO   0FE
....................    { 
....................       // activate pwm2 output 
....................       output_high(PWM2_PIN); 
00F8:  MOVLB  01
00F9:  BCF    0E.1
00FA:  MOVLB  02
00FB:  BSF    0E.1
....................    } 
00FC:  GOTO   102
00FD:  MOVLB  00
....................    else 
....................    { 
....................       output_low(PWM2_PIN); 
00FE:  MOVLB  01
00FF:  BCF    0E.1
0100:  MOVLB  02
0101:  BCF    0E.1
....................    } 
....................     
....................    if (pwm_counter < (desired_pwm_period/100)*desired_dutycycle_pwm3) 
0102:  MOVLB  00
0103:  MOVF   32,W
0104:  MOVLB  02
0105:  MOVWF  42
0106:  MOVLB  00
0107:  MOVF   31,W
0108:  MOVLB  02
0109:  MOVWF  41
010A:  CLRF   44
010B:  MOVLW  64
010C:  MOVWF  43
010D:  MOVLB  00
010E:  CALL   04A
010F:  MOVF   79,W
0110:  MOVLB  02
0111:  MOVWF  42
0112:  MOVF   78,W
0113:  MOVWF  41
0114:  MOVF   42,W
0115:  MOVWF  44
0116:  MOVF   41,W
0117:  MOVWF  43
0118:  MOVLB  00
0119:  MOVF   38,W
011A:  MOVLB  02
011B:  MOVWF  46
011C:  MOVLB  00
011D:  MOVF   37,W
011E:  MOVLB  02
011F:  MOVWF  45
0120:  MOVLB  00
0121:  CALL   071
0122:  MOVF   79,W
0123:  MOVWF  7A
0124:  MOVF   30,W
0125:  SUBWF  7A,W
0126:  BTFSS  03.0
0127:  GOTO   134
0128:  BTFSS  03.2
0129:  GOTO   12E
012A:  MOVF   78,W
012B:  SUBWF  2F,W
012C:  BTFSC  03.0
012D:  GOTO   134
....................    { 
....................       // activate pwm3 output 
....................       output_high(PWM3_PIN); 
012E:  MOVLB  01
012F:  BCF    10.0
0130:  MOVLB  02
0131:  BSF    10.0
....................    } 
0132:  GOTO   138
0133:  MOVLB  00
....................    else 
....................    { 
....................       output_low(PWM3_PIN); 
0134:  MOVLB  01
0135:  BCF    10.0
0136:  MOVLB  02
0137:  BCF    10.0
....................    } 
....................     
....................    if (pwm_counter < (desired_pwm_period/100)*desired_dutycycle_pwm4) 
0138:  MOVLB  00
0139:  MOVF   32,W
013A:  MOVLB  02
013B:  MOVWF  42
013C:  MOVLB  00
013D:  MOVF   31,W
013E:  MOVLB  02
013F:  MOVWF  41
0140:  CLRF   44
0141:  MOVLW  64
0142:  MOVWF  43
0143:  MOVLB  00
0144:  CALL   04A
0145:  MOVF   79,W
0146:  MOVLB  02
0147:  MOVWF  42
0148:  MOVF   78,W
0149:  MOVWF  41
014A:  MOVF   42,W
014B:  MOVWF  44
014C:  MOVF   41,W
014D:  MOVWF  43
014E:  MOVLB  00
014F:  MOVF   3A,W
0150:  MOVLB  02
0151:  MOVWF  46
0152:  MOVLB  00
0153:  MOVF   39,W
0154:  MOVLB  02
0155:  MOVWF  45
0156:  MOVLB  00
0157:  CALL   071
0158:  MOVF   79,W
0159:  MOVWF  7A
015A:  MOVF   30,W
015B:  SUBWF  7A,W
015C:  BTFSS  03.0
015D:  GOTO   16B
015E:  BTFSS  03.2
015F:  GOTO   164
0160:  MOVF   78,W
0161:  SUBWF  2F,W
0162:  BTFSC  03.0
0163:  GOTO   16B
....................    { 
....................       // activate pwm4 output 
....................       output_high(PWM4_PIN); 
0164:  MOVLW  F5
0165:  MOVLB  01
0166:  MOVWF  0F
0167:  MOVLB  02
0168:  BSF    0F.1
....................    } 
0169:  GOTO   170
016A:  MOVLB  00
....................    else 
....................    { 
....................       output_low(PWM4_PIN); 
016B:  MOVLW  F5
016C:  MOVLB  01
016D:  MOVWF  0F
016E:  MOVLB  02
016F:  BCF    0F.1
....................    } 
.................... } 
....................  
....................  
0170:  MOVLB  00
0171:  BCF    11.1
0172:  MOVLP  00
0173:  GOTO   02D
.................... #INT_RDA 
.................... /* 
.................... * ISR Function to read UART messages 
.................... */ 
.................... void ISR_Receive_UART(void) 
.................... { 
....................    char_received = getc(); // read the received byte 
*
01C6:  BTFSS  11.5
01C7:  GOTO   1C6
01C8:  MOVLB  03
01C9:  MOVF   19,W
01CA:  MOVLB  00
01CB:  MOVWF  3F
....................     
....................    switch(uart_state) 
01CC:  MOVF   68,W
01CD:  BTFSC  03.2
01CE:  GOTO   1D6
01CF:  XORLW  01
01D0:  BTFSC  03.2
01D1:  GOTO   1EA
01D2:  XORLW  03
01D3:  BTFSC  03.2
01D4:  GOTO   1FE
01D5:  GOTO   214
....................    { 
....................       case ST_WAIT: // wait for AT command 
....................       { 
....................          if ( (char_received == 'A') || (char_received == 'a') ) 
01D6:  MOVF   3F,W
01D7:  SUBLW  41
01D8:  BTFSC  03.2
01D9:  GOTO   1DE
01DA:  MOVF   3F,W
01DB:  SUBLW  61
01DC:  BTFSS  03.2
01DD:  GOTO   1E1
....................          { 
....................             // next state 
....................             uart_state = ST_A; 
01DE:  MOVLW  01
01DF:  MOVWF  68
....................          } 
01E0:  GOTO   1E9
....................          else 
....................          { 
....................             // send error and continue in wait state 
....................             printf("ERROR\r\n"); 
01E1:  MOVLW  1E
01E2:  MOVLB  03
01E3:  MOVWF  11
01E4:  MOVLW  02
01E5:  MOVWF  12
01E6:  MOVLB  00
01E7:  CALL   174
....................             uart_state = ST_WAIT; 
01E8:  CLRF   68
....................          } 
....................           
....................          break; 
01E9:  GOTO   21B
....................       }; 
....................        
....................       case ST_A: // wait for AT command 
....................       { 
....................          if (char_received == 'T' || char_received == 't') 
01EA:  MOVF   3F,W
01EB:  SUBLW  54
01EC:  BTFSC  03.2
01ED:  GOTO   1F2
01EE:  MOVF   3F,W
01EF:  SUBLW  74
01F0:  BTFSS  03.2
01F1:  GOTO   1F5
....................          { 
....................             // next state 
....................             uart_state = ST_MSG; 
01F2:  MOVLW  02
01F3:  MOVWF  68
....................          } 
01F4:  GOTO   1FD
....................          else 
....................          { 
....................             // send error and return to wait state 
....................             printf("ERROR\r\n"); 
01F5:  MOVLW  22
01F6:  MOVLB  03
01F7:  MOVWF  11
01F8:  MOVLW  02
01F9:  MOVWF  12
01FA:  MOVLB  00
01FB:  CALL   174
....................             uart_state = ST_WAIT; 
01FC:  CLRF   68
....................          } 
....................           
....................          break; 
01FD:  GOTO   21B
....................       }; 
....................        
....................       case ST_MSG: 
....................       { 
....................          if (char_received == '\r') ///////// CHANGE THISSSSSS TO \n TO GET FINAL \r\n 
01FE:  MOVF   3F,W
01FF:  SUBLW  0D
0200:  BTFSS  03.2
0201:  GOTO   206
....................          { 
....................             // end of message flag 
....................             NEW_MSG_RECEIVED_FLAG = true; 
0202:  MOVLW  01
0203:  MOVWF  70
....................             // next state 
....................             uart_state = ST_WAIT;  
0204:  CLRF   68
....................          } 
0205:  GOTO   213
....................          else 
....................          { 
....................             // add character to buffer 
....................             rx_msg[index_rx_msg] = char_received; 
0206:  MOVLW  20
0207:  ADDWF  54,W
0208:  MOVWF  04
0209:  MOVLW  20
020A:  MOVWF  05
020B:  BTFSC  03.0
020C:  INCF   05,F
020D:  MOVF   3F,W
020E:  MOVWF  00
....................             index_rx_msg += 1; 
020F:  MOVLW  01
0210:  ADDWF  54,F
....................             // next state 
....................             uart_state = ST_MSG;  
0211:  MOVLW  02
0212:  MOVWF  68
....................          } 
....................           
....................          break; 
0213:  GOTO   21B
....................       }; 
....................        
....................       default: 
....................       { 
....................          printf("ERROR\r\n"); 
0214:  MOVLW  26
0215:  MOVLB  03
0216:  MOVWF  11
0217:  MOVLW  02
0218:  MOVWF  12
0219:  MOVLB  00
021A:  CALL   174
....................          break; 
....................       }; 
....................    } 
021B:  BCF    11.5
021C:  MOVLP  00
021D:  GOTO   02D
.................... } 
....................  
....................  
.................... int32 char_hex_to_dec(char car, int pos) 
*
0422:  MOVLB  02
0423:  CLRF   37
0424:  CLRF   36
0425:  CLRF   39
0426:  CLRF   38
0427:  CLRF   3B
0428:  CLRF   3A
.................... { 
....................    unsigned int16 ans = 0; 
....................    unsigned int16 base = 0; 
....................    unsigned int16 exp = 0; 
....................     
....................    switch (car) 
0429:  MOVLW  31
042A:  SUBWF  34,W
042B:  ADDLW  EA
042C:  BTFSC  03.0
042D:  GOTO   47D
042E:  ADDLW  16
042F:  MOVLB  00
0430:  GOTO   4B8
....................    { 
....................       case '1': base = 1; 
0431:  MOVLB  02
0432:  CLRF   39
0433:  MOVLW  01
0434:  MOVWF  38
....................       break; 
0435:  GOTO   47D
....................        
....................       case '2': base = 2; 
0436:  MOVLB  02
0437:  CLRF   39
0438:  MOVLW  02
0439:  MOVWF  38
....................       break; 
043A:  GOTO   47D
....................        
....................       case '3': base = 3; 
043B:  MOVLB  02
043C:  CLRF   39
043D:  MOVLW  03
043E:  MOVWF  38
....................       break; 
043F:  GOTO   47D
....................        
....................       case '4': base = 4; 
0440:  MOVLB  02
0441:  CLRF   39
0442:  MOVLW  04
0443:  MOVWF  38
....................       break; 
0444:  GOTO   47D
....................        
....................       case '5': base = 5; 
0445:  MOVLB  02
0446:  CLRF   39
0447:  MOVLW  05
0448:  MOVWF  38
....................       break; 
0449:  GOTO   47D
....................        
....................       case '6': base = 6; 
044A:  MOVLB  02
044B:  CLRF   39
044C:  MOVLW  06
044D:  MOVWF  38
....................       break; 
044E:  GOTO   47D
....................        
....................       case '7': base = 7; 
044F:  MOVLB  02
0450:  CLRF   39
0451:  MOVLW  07
0452:  MOVWF  38
....................       break; 
0453:  GOTO   47D
....................        
....................       case '8': base = 8; 
0454:  MOVLB  02
0455:  CLRF   39
0456:  MOVLW  08
0457:  MOVWF  38
....................       break; 
0458:  GOTO   47D
....................        
....................       case '9': base = 9; 
0459:  MOVLB  02
045A:  CLRF   39
045B:  MOVLW  09
045C:  MOVWF  38
....................       break; 
045D:  GOTO   47D
....................        
....................       case 'A': base = 10; 
045E:  MOVLB  02
045F:  CLRF   39
0460:  MOVLW  0A
0461:  MOVWF  38
....................       break; 
0462:  GOTO   47D
....................        
....................       case 'B': base = 11; 
0463:  MOVLB  02
0464:  CLRF   39
0465:  MOVLW  0B
0466:  MOVWF  38
....................       break; 
0467:  GOTO   47D
....................        
....................       case 'C': base = 12; 
0468:  MOVLB  02
0469:  CLRF   39
046A:  MOVLW  0C
046B:  MOVWF  38
....................       break; 
046C:  GOTO   47D
....................        
....................       case 'D': base = 13; 
046D:  MOVLB  02
046E:  CLRF   39
046F:  MOVLW  0D
0470:  MOVWF  38
....................       break; 
0471:  GOTO   47D
....................        
....................       case 'E': base = 14; 
0472:  MOVLB  02
0473:  CLRF   39
0474:  MOVLW  0E
0475:  MOVWF  38
....................       break; 
0476:  GOTO   47D
....................        
....................       case 'F': base = 15; 
0477:  MOVLB  02
0478:  CLRF   39
0479:  MOVLW  0F
047A:  MOVWF  38
....................       break; 
047B:  GOTO   47D
047C:  MOVLB  02
....................    } 
....................     
....................    switch (pos) 
047D:  MOVF   35,W
047E:  ADDLW  FC
047F:  BTFSC  03.0
0480:  GOTO   499
0481:  ADDLW  04
0482:  MOVLB  00
0483:  GOTO   4D2
....................    { 
....................       case 0: exp = 1; 
0484:  MOVLB  02
0485:  CLRF   3B
0486:  MOVLW  01
0487:  MOVWF  3A
....................       break; 
0488:  GOTO   499
....................        
....................       case 1: exp = 16; 
0489:  MOVLB  02
048A:  CLRF   3B
048B:  MOVLW  10
048C:  MOVWF  3A
....................       break; 
048D:  GOTO   499
....................        
....................       case 2: exp = 256; 
048E:  MOVLW  01
048F:  MOVLB  02
0490:  MOVWF  3B
0491:  CLRF   3A
....................       break; 
0492:  GOTO   499
....................        
....................       case 3: exp = 4096; 
0493:  MOVLW  10
0494:  MOVLB  02
0495:  MOVWF  3B
0496:  CLRF   3A
....................       break; 
0497:  GOTO   499
0498:  MOVLB  02
....................    } 
0499:  MOVLB  00
049A:  CLRF   28
049B:  BTFSC  0B.7
049C:  BSF    28.7
049D:  BCF    0B.7
....................     
....................    ans = base*exp; 
049E:  MOVLB  02
049F:  MOVF   39,W
04A0:  MOVWF  44
04A1:  MOVF   38,W
04A2:  MOVWF  43
04A3:  MOVF   3B,W
04A4:  MOVWF  46
04A5:  MOVF   3A,W
04A6:  MOVWF  45
04A7:  MOVLB  00
04A8:  CALL   071
04A9:  BTFSC  28.7
04AA:  BSF    0B.7
04AB:  MOVF   79,W
04AC:  MOVLB  02
04AD:  MOVWF  37
04AE:  MOVF   78,W
04AF:  MOVWF  36
....................     
....................    return ans; 
04B0:  MOVF   36,W
04B1:  MOVWF  77
04B2:  MOVF   37,W
04B3:  MOVWF  78
04B4:  CLRF   79
04B5:  CLRF   7A
04B6:  MOVLB  00
04B7:  RETURN
.................... } 
....................  
....................  
.................... /*  
.................... * Function to clear buffers 
.................... */ 
.................... void Clear_Buffers(void) 
.................... { 
....................    for (int8 j = 0; j < index_rx_msg; j++) 
*
054C:  MOVLB  02
054D:  CLRF   32
054E:  MOVLB  00
054F:  MOVF   54,W
0550:  MOVLB  02
0551:  SUBWF  32,W
0552:  BTFSC  03.0
0553:  GOTO   55E
....................    { 
....................       rx_msg[j] = 0;  
0554:  MOVLW  20
0555:  ADDWF  32,W
0556:  MOVWF  04
0557:  MOVLW  20
0558:  MOVWF  05
0559:  BTFSC  03.0
055A:  INCF   05,F
055B:  CLRF   00
055C:  INCF   32,F
055D:  GOTO   54E
....................    } 
....................    index_rx_msg = 0; // reset the buffer index 
055E:  MOVLB  00
055F:  CLRF   54
....................     
....................    for (j = 0; j < index_identifier_msg; j++) 
0560:  MOVLB  02
0561:  CLRF   32
0562:  MOVLB  00
0563:  MOVF   5F,W
0564:  MOVLB  02
0565:  SUBWF  32,W
0566:  BTFSC  03.0
0567:  GOTO   572
....................    { 
....................       identifier_msg[j] = 0;  
0568:  MOVLW  35
0569:  ADDWF  32,W
056A:  MOVWF  04
056B:  MOVLW  20
056C:  MOVWF  05
056D:  BTFSC  03.0
056E:  INCF   05,F
056F:  CLRF   00
0570:  INCF   32,F
0571:  GOTO   562
....................    } 
....................    index_identifier_msg = 0; // reset the buffer index 
0572:  MOVLB  00
0573:  CLRF   5F
....................     
....................    for (j = 0; j < index_value_msg; j++) 
0574:  MOVLB  02
0575:  CLRF   32
0576:  MOVLB  00
0577:  MOVF   66,W
0578:  MOVLB  02
0579:  SUBWF  32,W
057A:  BTFSC  03.0
057B:  GOTO   586
....................    { 
....................       value_msg[j] = 0;  
057C:  MOVLW  41
057D:  ADDWF  32,W
057E:  MOVWF  04
057F:  MOVLW  20
0580:  MOVWF  05
0581:  BTFSC  03.0
0582:  INCF   05,F
0583:  CLRF   00
0584:  INCF   32,F
0585:  GOTO   576
....................    } 
....................    index_value_msg = 0; // reset the buffer index 
0586:  MOVLB  00
0587:  CLRF   66
0588:  MOVLP  08
0589:  GOTO   66A (RETURN)
.................... } 
....................  
....................  
.................... #ifdef __DEBUG__ 
.................... void Print_Buffers(void) 
.................... { 
....................    // print the message received 
....................    for (int8 k = 0; k < index_rx_msg; k++) 
*
04E0:  MOVLB  02
04E1:  CLRF   32
04E2:  MOVLB  00
04E3:  MOVF   54,W
04E4:  MOVLB  02
04E5:  SUBWF  32,W
04E6:  BTFSC  03.0
04E7:  GOTO   4F7
....................    { 
....................       putc(rx_msg[k]);  
04E8:  MOVLW  20
04E9:  ADDWF  32,W
04EA:  MOVWF  04
04EB:  MOVLW  20
04EC:  MOVWF  05
04ED:  BTFSC  03.0
04EE:  INCF   05,F
04EF:  MOVF   00,W
04F0:  MOVWF  33
04F1:  MOVF   33,W
04F2:  MOVLB  00
04F3:  CALL   4DA
04F4:  MOVLB  02
04F5:  INCF   32,F
04F6:  GOTO   4E2
....................    } 
....................    printf("\r\n"); 
04F7:  MOVLW  0D
04F8:  MOVLB  00
04F9:  BTFSS  11.4
04FA:  GOTO   4F9
04FB:  MOVLB  03
04FC:  MOVWF  1A
04FD:  MOVLW  0A
04FE:  MOVLB  00
04FF:  BTFSS  11.4
0500:  GOTO   4FF
0501:  MOVLB  03
0502:  MOVWF  1A
....................     
....................    // print the identifier received 
....................    for (k = 0; k < index_identifier_msg; k++) 
0503:  MOVLB  02
0504:  CLRF   32
0505:  MOVLB  00
0506:  MOVF   5F,W
0507:  MOVLB  02
0508:  SUBWF  32,W
0509:  BTFSC  03.0
050A:  GOTO   51A
....................    { 
....................       putc(identifier_msg[k]);  
050B:  MOVLW  35
050C:  ADDWF  32,W
050D:  MOVWF  04
050E:  MOVLW  20
050F:  MOVWF  05
0510:  BTFSC  03.0
0511:  INCF   05,F
0512:  MOVF   00,W
0513:  MOVWF  33
0514:  MOVF   33,W
0515:  MOVLB  00
0516:  CALL   4DA
0517:  MOVLB  02
0518:  INCF   32,F
0519:  GOTO   505
....................    } 
....................    printf("\r\n"); 
051A:  MOVLW  0D
051B:  MOVLB  00
051C:  BTFSS  11.4
051D:  GOTO   51C
051E:  MOVLB  03
051F:  MOVWF  1A
0520:  MOVLW  0A
0521:  MOVLB  00
0522:  BTFSS  11.4
0523:  GOTO   522
0524:  MOVLB  03
0525:  MOVWF  1A
....................     
....................    // print the value received 
....................    for (k = 0; k < index_value_msg; k++) 
0526:  MOVLB  02
0527:  CLRF   32
0528:  MOVLB  00
0529:  MOVF   66,W
052A:  MOVLB  02
052B:  SUBWF  32,W
052C:  BTFSC  03.0
052D:  GOTO   53D
....................    { 
....................       putc(value_msg[k]);  
052E:  MOVLW  41
052F:  ADDWF  32,W
0530:  MOVWF  04
0531:  MOVLW  20
0532:  MOVWF  05
0533:  BTFSC  03.0
0534:  INCF   05,F
0535:  MOVF   00,W
0536:  MOVWF  33
0537:  MOVF   33,W
0538:  MOVLB  00
0539:  CALL   4DA
053A:  MOVLB  02
053B:  INCF   32,F
053C:  GOTO   528
....................    } 
....................    printf("\r\n"); 
053D:  MOVLW  0D
053E:  MOVLB  00
053F:  BTFSS  11.4
0540:  GOTO   53F
0541:  MOVLB  03
0542:  MOVWF  1A
0543:  MOVLW  0A
0544:  MOVLB  00
0545:  BTFSS  11.4
0546:  GOTO   545
0547:  MOVLB  03
0548:  MOVWF  1A
0549:  MOVLP  08
054A:  MOVLB  00
054B:  GOTO   657 (RETURN)
.................... } 
.................... #endif 
....................  
....................  
.................... void main() 
*
0800:  MOVLB  03
0801:  BSF    1F.3
0802:  MOVLW  08
0803:  MOVWF  1B
0804:  MOVLW  02
0805:  MOVWF  1C
0806:  MOVLW  A6
0807:  MOVWF  1E
0808:  MOVLW  90
0809:  MOVWF  1D
080A:  MOVLB  04
080B:  BCF    15.5
080C:  MOVLW  40
080D:  MOVWF  14
080E:  MOVLW  0B
080F:  MOVWF  12
0810:  MOVLW  3A
0811:  MOVWF  15
0812:  MOVLB  01
0813:  BCF    0E.5
0814:  BSF    0E.4
0815:  BCF    0E.3
0816:  MOVLB  00
0817:  CLRF   30
0818:  CLRF   2F
0819:  MOVLW  19
081A:  MOVWF  32
081B:  MOVLW  B3
081C:  MOVWF  31
081D:  CLRF   34
081E:  MOVLW  19
081F:  MOVWF  33
0820:  CLRF   36
0821:  MOVLW  32
0822:  MOVWF  35
0823:  CLRF   38
0824:  MOVLW  4B
0825:  MOVWF  37
0826:  CLRF   3A
0827:  MOVLW  64
0828:  MOVWF  39
0829:  CLRF   3C
082A:  CLRF   3B
082B:  CLRF   3E
082C:  CLRF   3D
082D:  CLRF   3F
082E:  CLRF   54
082F:  CLRF   5F
0830:  CLRF   60
0831:  CLRF   66
0832:  CLRF   67
0833:  CLRF   70
0834:  MOVLB  0F
0835:  CLRF   11
0836:  CLRF   12
0837:  CLRF   18
0838:  CLRF   19
0839:  CLRF   1A
083A:  MOVLB  03
083B:  CLRF   0C
083C:  CLRF   0D
083D:  CLRF   0F
083E:  CLRF   10
083F:  MOVLB  02
0840:  CLRF   12
0841:  CLRF   11
0842:  CLRF   14
0843:  CLRF   13
0844:  GOTO   0B5
0845:  DATA 02,34
0846:  DATA 00,34
0847:  DATA 29,34
0848:  DATA 00,34
0849:  DATA 00,34
084A:  DATA 14,34
084B:  DATA 40,34
084C:  DATA 40,34
084D:  DATA 00,34
084E:  DATA 0A,34
084F:  DATA 40,34
0850:  DATA 55,34
0851:  DATA 00,34
0852:  DATA 05,34
0853:  DATA 40,34
0854:  DATA 61,34
0855:  DATA 00,34
0856:  DATA 06,34
0857:  DATA 00,34
0858:  DATA 69,34
0859:  DATA 41,34
085A:  DATA 4E,34
085B:  DATA 4F,34
085C:  DATA 55,34
085D:  DATA 54,34
085E:  DATA 00,34
085F:  DATA 06,34
0860:  DATA 00,34
0861:  DATA A3,34
0862:  DATA 61,34
0863:  DATA 6E,34
0864:  DATA 6F,34
0865:  DATA 75,34
0866:  DATA 74,34
0867:  DATA 00,34
0868:  DATA 1C,34
0869:  DATA 00,34
086A:  DATA AD,34
086B:  DATA 50,34
086C:  DATA 57,34
086D:  DATA 4D,34
086E:  DATA 50,34
086F:  DATA 45,34
0870:  DATA 52,34
0871:  DATA 49,34
0872:  DATA 4F,34
0873:  DATA 44,34
0874:  DATA 00,34
0875:  DATA 70,34
0876:  DATA 77,34
0877:  DATA 6D,34
0878:  DATA 70,34
0879:  DATA 65,34
087A:  DATA 72,34
087B:  DATA 69,34
087C:  DATA 6F,34
087D:  DATA 64,34
087E:  DATA 00,34
087F:  DATA 50,34
0880:  DATA 57,34
0881:  DATA 4D,34
0882:  DATA 44,34
0883:  DATA 55,34
0884:  DATA 54,34
0885:  DATA 59,34
0886:  DATA 00,34
0887:  DATA 08,34
0888:  DATA 00,34
0889:  DATA CB,34
088A:  DATA 70,34
088B:  DATA 77,34
088C:  DATA 6D,34
088D:  DATA 64,34
088E:  DATA 75,34
088F:  DATA 74,34
0890:  DATA 79,34
0891:  DATA 00,34
0892:  DATA 06,34
0893:  DATA 00,34
0894:  DATA D5,34
0895:  DATA 41,34
0896:  DATA 42,34
0897:  DATA 4F,34
0898:  DATA 55,34
0899:  DATA 54,34
089A:  DATA 00,34
089B:  DATA 06,34
089C:  DATA 00,34
089D:  DATA DF,34
089E:  DATA 61,34
089F:  DATA 62,34
08A0:  DATA 6F,34
08A1:  DATA 75,34
08A2:  DATA 74,34
08A3:  DATA 00,34
08A4:  DATA 05,34
08A5:  DATA 00,34
08A6:  DATA E9,34
08A7:  DATA 48,34
08A8:  DATA 45,34
08A9:  DATA 4C,34
08AA:  DATA 50,34
08AB:  DATA 00,34
08AC:  DATA 05,34
08AD:  DATA 01,34
08AE:  DATA 23,34
08AF:  DATA 68,34
08B0:  DATA 65,34
08B1:  DATA 6C,34
08B2:  DATA 70,34
08B3:  DATA 00,34
08B4:  DATA 00,34
08B5:  MOVLW  08
08B6:  MOVWF  05
08B7:  MOVLW  45
08B8:  MOVWF  04
08B9:  BSF    05.7
08BA:  MOVIW  [FSR0++],W
08BB:  MOVWF  77
08BC:  XORLW  00
08BD:  BTFSC  03.2
08BE:  GOTO   0CF
08BF:  MOVIW  [FSR0++],W
08C0:  MOVWF  78
08C1:  BTFSC  78.7
08C2:  GOTO   0C7
08C3:  ANDLW  0F
08C4:  MOVWF  07
08C5:  MOVIW  [FSR0++],W
08C6:  MOVWF  06
08C7:  BTFSC  78.6
08C8:  MOVIW  [FSR0++],W
08C9:  BTFSS  78.6
08CA:  MOVIW  [FSR0++],W
08CB:  MOVWI  W,[FSR1++]
08CC:  DECFSZ 77,F
08CD:  GOTO   0C9
08CE:  GOTO   0BA
.................... { 
....................    // Set initial state of IO pins 
....................    output_low(USER_LED); // start with led turn off 
08CF:  MOVLW  CF
08D0:  TRIS   6
08D1:  BCF    0D.4
....................    output_low(COMMS_LED); // start with led turn off 
08D2:  TRIS   6
08D3:  BCF    0D.5
....................    output_high(CS_PIN); // start in high to disable the slave 
08D4:  MOVLW  F5
08D5:  MOVLB  01
08D6:  MOVWF  0F
08D7:  MOVLB  02
08D8:  BSF    0F.3
....................     
....................    // Set initial state of PWM pins 
....................    output_low(PWM1_PIN); 
08D9:  MOVLB  01
08DA:  BCF    0E.2
08DB:  MOVLB  02
08DC:  BCF    0E.2
....................    output_low(PWM2_PIN); 
08DD:  MOVLB  01
08DE:  BCF    0E.1
08DF:  MOVLB  02
08E0:  BCF    0E.1
....................    output_low(PWM3_PIN); 
08E1:  MOVLB  01
08E2:  BCF    10.0
08E3:  MOVLB  02
08E4:  BCF    10.0
....................    output_low(PWM4_PIN); 
08E5:  MOVLB  01
08E6:  MOVWF  0F
08E7:  MOVLB  02
08E8:  BCF    0F.1
....................     
....................    // Set initial 0V at DAC output channels 
....................     
....................     
....................    // Configure TIM2 to PWM timebase 
....................    setup_timer_2(T2_DIV_BY_1,75,1);      // 15,2 us overflow, 15,2 us interrupt 
08E9:  MOVLW  00
08EA:  MOVWF  78
08EB:  IORLW  04
08EC:  MOVLB  00
08ED:  MOVWF  1C
08EE:  MOVLW  4B
08EF:  MOVWF  1B
....................     
....................    // Configure interrupts 
....................    enable_interrupts(INT_TIMER2); // timer 2 interrupt 
08F0:  MOVLB  01
08F1:  BSF    11.1
....................    enable_interrupts(INT_RDA); // UART interrupt 
08F2:  BSF    11.5
....................    enable_interrupts(GLOBAL); 
08F3:  MOVLW  C0
08F4:  IORWF  0B,F
....................     
....................    // Start UART communication 
....................    uart_state = ST_WAIT; 
08F5:  MOVLB  00
08F6:  CLRF   68
....................    printf("READY\r\n"); 
08F7:  MOVLW  2A
08F8:  MOVLB  03
08F9:  MOVWF  11
08FA:  MOVLW  02
08FB:  MOVWF  12
08FC:  MOVLB  00
08FD:  CLRF   28
08FE:  BTFSC  0B.7
08FF:  BSF    28.7
0900:  BCF    0B.7
0901:  MOVLP  00
0902:  CALL   174
0903:  MOVLP  08
0904:  BTFSC  28.7
0905:  BSF    0B.7
....................  
....................    while(TRUE) 
....................    { 
.................... //!      output_low(USER_LED); 
.................... //!      output_high(COMMS_LED); 
.................... //!      delay_ms(500); 
....................           
....................       if (NEW_MSG_RECEIVED_FLAG == true) 
0906:  DECFSZ 70,W
0907:  GOTO   66C
....................       { 
....................          // manage the event 
....................          if (rx_msg[0] == 0) // simple AT command 
0908:  MOVF   40,F
0909:  BTFSS  03.2
090A:  GOTO   11B
....................          { 
....................             printf("OK\r\n");  
090B:  MOVLW  2E
090C:  MOVLB  03
090D:  MOVWF  11
090E:  MOVLW  02
090F:  MOVWF  12
0910:  MOVLB  00
0911:  CLRF   28
0912:  BTFSC  0B.7
0913:  BSF    28.7
0914:  BCF    0B.7
0915:  MOVLP  00
0916:  CALL   174
0917:  MOVLP  08
0918:  BTFSC  28.7
0919:  BSF    0B.7
....................          } 
091A:  GOTO   668
....................          else if (rx_msg[0] == '+') // complex AT command 
091B:  MOVF   40,W
091C:  SUBLW  2B
091D:  BTFSS  03.2
091E:  GOTO   659
....................          { 
....................             // get the identifier of the received command 
....................             for (int8 i = 1; i < index_rx_msg; i++) 
091F:  MOVLW  01
0920:  MOVLB  02
0921:  MOVWF  2D
0922:  MOVLB  00
0923:  MOVF   54,W
0924:  MOVLB  02
0925:  SUBWF  2D,W
0926:  BTFSC  03.0
0927:  GOTO   162
....................             { 
....................                if ( (rx_msg[i] == '=') || (rx_msg[i] == '?') ) 
0928:  MOVLW  20
0929:  ADDWF  2D,W
092A:  MOVWF  04
092B:  MOVLW  20
092C:  MOVWF  05
092D:  BTFSC  03.0
092E:  INCF   05,F
092F:  MOVF   00,W
0930:  SUBLW  3D
0931:  BTFSC  03.2
0932:  GOTO   13E
0933:  MOVLW  20
0934:  ADDWF  2D,W
0935:  MOVWF  04
0936:  MOVLW  20
0937:  MOVWF  05
0938:  BTFSC  03.0
0939:  INCF   05,F
093A:  MOVF   00,W
093B:  SUBLW  3F
093C:  BTFSS  03.2
093D:  GOTO   144
....................                { 
....................                   // end of command identifier 
....................                   index_reader = i; 
093E:  MOVF   2D,W
093F:  MOVLB  00
0940:  MOVWF  60
....................                   break; 
0941:  MOVLB  02
0942:  GOTO   162
....................                } 
0943:  GOTO   160
....................                else 
....................                { 
....................                   // read the command identifier 
....................                   identifier_msg[index_identifier_msg] = rx_msg[i]; 
0944:  MOVLW  35
0945:  MOVLB  00
0946:  ADDWF  5F,W
0947:  MOVLB  02
0948:  MOVWF  32
0949:  MOVLW  20
094A:  MOVWF  33
094B:  BTFSC  03.0
094C:  INCF   33,F
094D:  MOVLW  20
094E:  ADDWF  2D,W
094F:  MOVWF  04
0950:  MOVLW  20
0951:  MOVWF  05
0952:  BTFSC  03.0
0953:  INCF   05,F
0954:  MOVF   00,W
0955:  MOVWF  34
0956:  MOVF   33,W
0957:  MOVWF  05
0958:  MOVF   32,W
0959:  MOVWF  04
095A:  MOVF   34,W
095B:  MOVWF  00
....................                   index_identifier_msg += 1; 
095C:  MOVLW  01
095D:  MOVLB  00
095E:  ADDWF  5F,F
095F:  MOVLB  02
....................                } 
0960:  INCF   2D,F
0961:  GOTO   122
....................             } 
....................              
....................             // select between commands 
....................             ////// ANOUT Command ////// 
....................             if ( (strcmp(identifier_msg, CMD_1) == 0) || (strcmp(identifier_msg, CMD_1_1) == 0) )  
0962:  MOVLW  20
0963:  MOVWF  33
0964:  MOVLW  35
0965:  MOVWF  32
0966:  MOVLW  20
0967:  MOVWF  35
0968:  MOVLW  49
0969:  MOVWF  34
096A:  MOVLP  00
096B:  MOVLB  00
096C:  CALL   343
096D:  MOVLP  08
096E:  MOVF   78,F
096F:  BTFSC  03.2
0970:  GOTO   181
0971:  MOVLW  20
0972:  MOVLB  02
0973:  MOVWF  33
0974:  MOVLW  35
0975:  MOVWF  32
0976:  MOVLW  20
0977:  MOVWF  35
0978:  MOVLW  53
0979:  MOVWF  34
097A:  MOVLP  00
097B:  MOVLB  00
097C:  CALL   343
097D:  MOVLP  08
097E:  MOVF   78,F
097F:  BTFSS  03.2
0980:  GOTO   189
....................             { 
....................                printf(CMD_1); 
0981:  MOVLW  20
0982:  MOVWF  05
0983:  MOVLW  49
0984:  MOVWF  04
0985:  MOVLP  00
0986:  GOTO   384
0987:  MOVLP  08
....................             } 
0988:  GOTO   653
....................              
....................             ////// PWMPERIOD Command ////// 
....................             else if ( (strcmp(identifier_msg, CMD_2) == 0) || (strcmp(identifier_msg, CMD_2_2) == 0) )  
0989:  MOVLW  20
098A:  MOVLB  02
098B:  MOVWF  33
098C:  MOVLW  35
098D:  MOVWF  32
098E:  MOVLW  20
098F:  MOVWF  35
0990:  MOVLW  5D
0991:  MOVWF  34
0992:  MOVLP  00
0993:  MOVLB  00
0994:  CALL   343
0995:  MOVLP  08
0996:  MOVF   78,F
0997:  BTFSC  03.2
0998:  GOTO   1A9
0999:  MOVLW  20
099A:  MOVLB  02
099B:  MOVWF  33
099C:  MOVLW  35
099D:  MOVWF  32
099E:  MOVLW  20
099F:  MOVWF  35
09A0:  MOVLW  67
09A1:  MOVWF  34
09A2:  MOVLP  00
09A3:  MOVLB  00
09A4:  CALL   343
09A5:  MOVLP  08
09A6:  MOVF   78,F
09A7:  BTFSS  03.2
09A8:  GOTO   2BD
....................             { 
....................                if (rx_msg[index_reader] == '?') // case 2 of PWMPERIOD command 
09A9:  MOVLW  20
09AA:  ADDWF  60,W
09AB:  MOVWF  04
09AC:  MOVLW  20
09AD:  MOVWF  05
09AE:  BTFSC  03.0
09AF:  INCF   05,F
09B0:  MOVF   00,W
09B1:  SUBLW  3F
09B2:  BTFSS  03.2
09B3:  GOTO   1F1
....................                { 
....................                   // answer the command 
....................                   printf("+PWMPERIOD:%X%X\r\n", (int)(desired_pwm_period>>8), (int)(desired_pwm_period)); 
09B4:  MOVF   32,W
09B5:  CLRF   7A
09B6:  MOVLB  02
09B7:  MOVWF  32
09B8:  MOVLW  31
09B9:  MOVLB  03
09BA:  MOVWF  11
09BB:  MOVLW  02
09BC:  MOVWF  12
09BD:  BCF    03.0
09BE:  MOVLW  0B
09BF:  MOVLB  02
09C0:  MOVWF  36
09C1:  MOVLP  00
09C2:  MOVLB  00
09C3:  CALL   39C
09C4:  MOVLP  08
09C5:  MOVLB  02
09C6:  MOVF   32,W
09C7:  MOVWF  36
09C8:  MOVLW  37
09C9:  MOVWF  37
09CA:  MOVLP  00
09CB:  MOVLB  00
09CC:  CALL   3F8
09CD:  MOVLP  08
09CE:  MOVF   31,W
09CF:  MOVLB  02
09D0:  MOVWF  36
09D1:  MOVLW  37
09D2:  MOVWF  37
09D3:  MOVLP  00
09D4:  MOVLB  00
09D5:  CALL   3F8
09D6:  MOVLP  08
09D7:  MOVLW  0D
09D8:  BTFSS  11.4
09D9:  GOTO   1D8
09DA:  MOVLB  03
09DB:  MOVWF  1A
09DC:  MOVLW  0A
09DD:  MOVLB  00
09DE:  BTFSS  11.4
09DF:  GOTO   1DE
09E0:  MOVLB  03
09E1:  MOVWF  1A
....................                   printf("OK\r\n"); 
09E2:  MOVLW  3A
09E3:  MOVWF  11
09E4:  MOVLW  02
09E5:  MOVWF  12
09E6:  MOVLB  00
09E7:  CLRF   28
09E8:  BTFSC  0B.7
09E9:  BSF    28.7
09EA:  BCF    0B.7
09EB:  MOVLP  00
09EC:  CALL   174
09ED:  MOVLP  08
09EE:  BTFSC  28.7
09EF:  BSF    0B.7
....................                } 
09F0:  GOTO   2BA
....................                else if ((rx_msg[index_reader] == '=') && (rx_msg[index_reader+1] == '?')) // case 3 of PWMPERIOD command 
09F1:  MOVLW  20
09F2:  ADDWF  60,W
09F3:  MOVWF  04
09F4:  MOVLW  20
09F5:  MOVWF  05
09F6:  BTFSC  03.0
09F7:  INCF   05,F
09F8:  MOVF   00,W
09F9:  SUBLW  3D
09FA:  BTFSS  03.2
09FB:  GOTO   238
09FC:  MOVLW  01
09FD:  ADDWF  60,W
09FE:  ADDLW  20
09FF:  MOVWF  04
0A00:  MOVLW  20
0A01:  MOVWF  05
0A02:  BTFSC  03.0
0A03:  INCF   05,F
0A04:  MOVF   00,W
0A05:  SUBLW  3F
0A06:  BTFSS  03.2
0A07:  GOTO   238
....................                { 
....................                   // answer the command 
....................                   printf("+PWMPERIOD:%X%X\r\n", (int)(desired_pwm_period>>8), (int)(desired_pwm_period)); 
0A08:  MOVF   32,W
0A09:  CLRF   7A
0A0A:  MOVLB  02
0A0B:  MOVWF  32
0A0C:  MOVLW  3D
0A0D:  MOVLB  03
0A0E:  MOVWF  11
0A0F:  MOVLW  02
0A10:  MOVWF  12
0A11:  BCF    03.0
0A12:  MOVLW  0B
0A13:  MOVLB  02
0A14:  MOVWF  36
0A15:  MOVLP  00
0A16:  MOVLB  00
0A17:  CALL   39C
0A18:  MOVLP  08
0A19:  MOVLB  02
0A1A:  MOVF   32,W
0A1B:  MOVWF  36
0A1C:  MOVLW  37
0A1D:  MOVWF  37
0A1E:  MOVLP  00
0A1F:  MOVLB  00
0A20:  CALL   3F8
0A21:  MOVLP  08
0A22:  MOVF   31,W
0A23:  MOVLB  02
0A24:  MOVWF  36
0A25:  MOVLW  37
0A26:  MOVWF  37
0A27:  MOVLP  00
0A28:  MOVLB  00
0A29:  CALL   3F8
0A2A:  MOVLP  08
0A2B:  MOVLW  0D
0A2C:  BTFSS  11.4
0A2D:  GOTO   22C
0A2E:  MOVLB  03
0A2F:  MOVWF  1A
0A30:  MOVLW  0A
0A31:  MOVLB  00
0A32:  BTFSS  11.4
0A33:  GOTO   232
0A34:  MOVLB  03
0A35:  MOVWF  1A
....................                } 
0A36:  GOTO   2BB
0A37:  MOVLB  00
....................                else if (rx_msg[index_reader] == '=') // case 1 of PWMPERIOD command 
0A38:  MOVLW  20
0A39:  ADDWF  60,W
0A3A:  MOVWF  04
0A3B:  MOVLW  20
0A3C:  MOVWF  05
0A3D:  BTFSC  03.0
0A3E:  INCF   05,F
0A3F:  MOVF   00,W
0A40:  SUBLW  3D
0A41:  BTFSS  03.2
0A42:  GOTO   2AB
....................                { 
....................                   // read the value 
....................                   for (i = index_reader+1; i <= index_rx_msg; i++) ///////// CHANGE THISSSSSS TO JUST < TO GET FINAL \r\n 
0A43:  MOVLW  01
0A44:  ADDWF  60,W
0A45:  MOVLB  02
0A46:  MOVWF  2D
0A47:  MOVF   2D,W
0A48:  MOVLB  00
0A49:  SUBWF  54,W
0A4A:  BTFSS  03.0
0A4B:  GOTO   26A
....................                   { 
....................                      // add character to value buffer 
....................                      value_msg[index_value_msg] = rx_msg[i]; 
0A4C:  MOVLW  41
0A4D:  ADDWF  66,W
0A4E:  MOVLB  02
0A4F:  MOVWF  32
0A50:  MOVLW  20
0A51:  MOVWF  33
0A52:  BTFSC  03.0
0A53:  INCF   33,F
0A54:  MOVLW  20
0A55:  ADDWF  2D,W
0A56:  MOVWF  04
0A57:  MOVLW  20
0A58:  MOVWF  05
0A59:  BTFSC  03.0
0A5A:  INCF   05,F
0A5B:  MOVF   00,W
0A5C:  MOVWF  34
0A5D:  MOVF   33,W
0A5E:  MOVWF  05
0A5F:  MOVF   32,W
0A60:  MOVWF  04
0A61:  MOVF   34,W
0A62:  MOVWF  00
....................                      index_value_msg += 1; 
0A63:  MOVLW  01
0A64:  MOVLB  00
0A65:  ADDWF  66,F
0A66:  MOVLB  02
0A67:  INCF   2D,F
0A68:  GOTO   247
0A69:  MOVLB  00
....................                   } 
....................                    
....................                   // end of value (read buffer to get the number) 
....................                   unsigned int16 temp_desired_pwm_period = 0; 
0A6A:  MOVLB  02
0A6B:  CLRF   2F
0A6C:  CLRF   2E
....................                   for (i = 0; i < index_value_msg; i++) 
0A6D:  CLRF   2D
0A6E:  MOVLB  00
0A6F:  MOVF   66,W
0A70:  MOVLB  02
0A71:  SUBWF  2D,W
0A72:  BTFSC  03.0
0A73:  GOTO   294
....................                   { 
....................                      temp_desired_pwm_period += char_hex_to_dec(value_msg[i],index_value_msg-2-i); 
0A74:  MOVLW  41
0A75:  ADDWF  2D,W
0A76:  MOVWF  04
0A77:  MOVLW  20
0A78:  MOVWF  05
0A79:  BTFSC  03.0
0A7A:  INCF   05,F
0A7B:  MOVF   00,W
0A7C:  MOVWF  32
0A7D:  MOVLW  02
0A7E:  MOVLB  00
0A7F:  SUBWF  66,W
0A80:  MOVWF  78
0A81:  MOVLB  02
0A82:  MOVF   2D,W
0A83:  SUBWF  78,W
0A84:  MOVWF  33
0A85:  MOVF   32,W
0A86:  MOVWF  34
0A87:  MOVF   33,W
0A88:  MOVWF  35
0A89:  MOVLP  00
0A8A:  MOVLB  00
0A8B:  CALL   422
0A8C:  MOVLP  08
0A8D:  MOVF   77,W
0A8E:  MOVLB  02
0A8F:  ADDWF  2E,F
0A90:  MOVF   78,W
0A91:  ADDWFC 2F,F
0A92:  INCF   2D,F
0A93:  GOTO   26E
....................                   } 
....................                   desired_pwm_period = temp_desired_pwm_period; // assig final value of PWM period 
0A94:  MOVF   2F,W
0A95:  MOVLB  00
0A96:  MOVWF  32
0A97:  MOVLB  02
0A98:  MOVF   2E,W
0A99:  MOVLB  00
0A9A:  MOVWF  31
....................                   printf("OK\r\n"); 
0A9B:  MOVLW  46
0A9C:  MOVLB  03
0A9D:  MOVWF  11
0A9E:  MOVLW  02
0A9F:  MOVWF  12
0AA0:  MOVLB  00
0AA1:  CLRF   28
0AA2:  BTFSC  0B.7
0AA3:  BSF    28.7
0AA4:  BCF    0B.7
0AA5:  MOVLP  00
0AA6:  CALL   174
0AA7:  MOVLP  08
0AA8:  BTFSC  28.7
0AA9:  BSF    0B.7
....................                } 
0AAA:  GOTO   2BA
....................                else 
....................                { 
....................                   // the command is not recognized 
....................                   printf("ERROR\r\n"); 
0AAB:  MOVLW  49
0AAC:  MOVLB  03
0AAD:  MOVWF  11
0AAE:  MOVLW  02
0AAF:  MOVWF  12
0AB0:  MOVLB  00
0AB1:  CLRF   28
0AB2:  BTFSC  0B.7
0AB3:  BSF    28.7
0AB4:  BCF    0B.7
0AB5:  MOVLP  00
0AB6:  CALL   174
0AB7:  MOVLP  08
0AB8:  BTFSC  28.7
0AB9:  BSF    0B.7
0ABA:  MOVLB  03
....................                } 
....................             } 
0ABB:  GOTO   654
0ABC:  MOVLB  00
....................              
....................             ////// PWMDUTY Command ////// 
....................             else if ( (strcmp(identifier_msg, CMD_3) == 0) || (strcmp(identifier_msg, CMD_3_3) == 0) )  
0ABD:  MOVLW  20
0ABE:  MOVLB  02
0ABF:  MOVWF  33
0AC0:  MOVLW  35
0AC1:  MOVWF  32
0AC2:  MOVLW  20
0AC3:  MOVWF  35
0AC4:  MOVLW  71
0AC5:  MOVWF  34
0AC6:  MOVLP  00
0AC7:  MOVLB  00
0AC8:  CALL   343
0AC9:  MOVLP  08
0ACA:  MOVF   78,F
0ACB:  BTFSC  03.2
0ACC:  GOTO   2DD
0ACD:  MOVLW  20
0ACE:  MOVLB  02
0ACF:  MOVWF  33
0AD0:  MOVLW  35
0AD1:  MOVWF  32
0AD2:  MOVLW  20
0AD3:  MOVWF  35
0AD4:  MOVLW  7B
0AD5:  MOVWF  34
0AD6:  MOVLP  00
0AD7:  MOVLB  00
0AD8:  CALL   343
0AD9:  MOVLP  08
0ADA:  MOVF   78,F
0ADB:  BTFSS  03.2
0ADC:  GOTO   56C
....................             { 
....................                if (rx_msg[index_reader] == '?') // case 2 of PWMDUTY command 
0ADD:  MOVLW  20
0ADE:  ADDWF  60,W
0ADF:  MOVWF  04
0AE0:  MOVLW  20
0AE1:  MOVWF  05
0AE2:  BTFSC  03.0
0AE3:  INCF   05,F
0AE4:  MOVF   00,W
0AE5:  SUBLW  3F
0AE6:  BTFSS  03.2
0AE7:  GOTO   39D
....................                { 
....................                   // answer the command 
....................                   printf("+PWMDUTY:1,%X%X,2,%X%X,3,%X%X,4,%X%X\r\n", (int)(desired_dutycycle_pwm1>>8), (int)(desired_dutycycle_pwm1),  
....................                                                                      (int)(desired_dutycycle_pwm2>>8), (int)(desired_dutycycle_pwm2), 
....................                                                                      (int)(desired_dutycycle_pwm3>>8), (int)(desired_dutycycle_pwm3), 
....................                                                                      (int)(desired_dutycycle_pwm4>>8), (int)(desired_dutycycle_pwm4)); 
0AE8:  MOVF   34,W
0AE9:  CLRF   7A
0AEA:  MOVLB  02
0AEB:  MOVWF  32
0AEC:  MOVLB  00
0AED:  MOVF   36,W
0AEE:  CLRF   7A
0AEF:  MOVLB  02
0AF0:  MOVWF  33
0AF1:  MOVLB  00
0AF2:  MOVF   38,W
0AF3:  CLRF   7A
0AF4:  MOVLB  02
0AF5:  MOVWF  34
0AF6:  MOVLB  00
0AF7:  MOVF   3A,W
0AF8:  CLRF   7A
0AF9:  MOVLB  02
0AFA:  MOVWF  35
0AFB:  MOVLW  4D
0AFC:  MOVLB  03
0AFD:  MOVWF  11
0AFE:  MOVLW  02
0AFF:  MOVWF  12
0B00:  BCF    03.0
0B01:  MOVLW  0B
0B02:  MOVLB  02
0B03:  MOVWF  36
0B04:  MOVLP  00
0B05:  MOVLB  00
0B06:  CALL   39C
0B07:  MOVLP  08
0B08:  MOVLB  02
0B09:  MOVF   32,W
0B0A:  MOVWF  36
0B0B:  MOVLW  37
0B0C:  MOVWF  37
0B0D:  MOVLP  00
0B0E:  MOVLB  00
0B0F:  CALL   3F8
0B10:  MOVLP  08
0B11:  MOVF   33,W
0B12:  MOVLB  02
0B13:  MOVWF  36
0B14:  MOVLW  37
0B15:  MOVWF  37
0B16:  MOVLP  00
0B17:  MOVLB  00
0B18:  CALL   3F8
0B19:  MOVLP  08
0B1A:  MOVLW  2C
0B1B:  BTFSS  11.4
0B1C:  GOTO   31B
0B1D:  MOVLB  03
0B1E:  MOVWF  1A
0B1F:  MOVLW  32
0B20:  MOVLB  00
0B21:  BTFSS  11.4
0B22:  GOTO   321
0B23:  MOVLB  03
0B24:  MOVWF  1A
0B25:  MOVLW  2C
0B26:  MOVLB  00
0B27:  BTFSS  11.4
0B28:  GOTO   327
0B29:  MOVLB  03
0B2A:  MOVWF  1A
0B2B:  MOVLB  02
0B2C:  MOVF   33,W
0B2D:  MOVWF  36
0B2E:  MOVLW  37
0B2F:  MOVWF  37
0B30:  MOVLP  00
0B31:  MOVLB  00
0B32:  CALL   3F8
0B33:  MOVLP  08
0B34:  MOVF   35,W
0B35:  MOVLB  02
0B36:  MOVWF  36
0B37:  MOVLW  37
0B38:  MOVWF  37
0B39:  MOVLP  00
0B3A:  MOVLB  00
0B3B:  CALL   3F8
0B3C:  MOVLP  08
0B3D:  MOVLW  2C
0B3E:  BTFSS  11.4
0B3F:  GOTO   33E
0B40:  MOVLB  03
0B41:  MOVWF  1A
0B42:  MOVLW  33
0B43:  MOVLB  00
0B44:  BTFSS  11.4
0B45:  GOTO   344
0B46:  MOVLB  03
0B47:  MOVWF  1A
0B48:  MOVLW  2C
0B49:  MOVLB  00
0B4A:  BTFSS  11.4
0B4B:  GOTO   34A
0B4C:  MOVLB  03
0B4D:  MOVWF  1A
0B4E:  MOVLB  02
0B4F:  MOVF   34,W
0B50:  MOVWF  36
0B51:  MOVLW  37
0B52:  MOVWF  37
0B53:  MOVLP  00
0B54:  MOVLB  00
0B55:  CALL   3F8
0B56:  MOVLP  08
0B57:  MOVF   37,W
0B58:  MOVLB  02
0B59:  MOVWF  36
0B5A:  MOVLW  37
0B5B:  MOVWF  37
0B5C:  MOVLP  00
0B5D:  MOVLB  00
0B5E:  CALL   3F8
0B5F:  MOVLP  08
0B60:  MOVLW  2C
0B61:  BTFSS  11.4
0B62:  GOTO   361
0B63:  MOVLB  03
0B64:  MOVWF  1A
0B65:  MOVLW  34
0B66:  MOVLB  00
0B67:  BTFSS  11.4
0B68:  GOTO   367
0B69:  MOVLB  03
0B6A:  MOVWF  1A
0B6B:  MOVLW  2C
0B6C:  MOVLB  00
0B6D:  BTFSS  11.4
0B6E:  GOTO   36D
0B6F:  MOVLB  03
0B70:  MOVWF  1A
0B71:  MOVLB  02
0B72:  MOVF   35,W
0B73:  MOVWF  36
0B74:  MOVLW  37
0B75:  MOVWF  37
0B76:  MOVLP  00
0B77:  MOVLB  00
0B78:  CALL   3F8
0B79:  MOVLP  08
0B7A:  MOVF   39,W
0B7B:  MOVLB  02
0B7C:  MOVWF  36
0B7D:  MOVLW  37
0B7E:  MOVWF  37
0B7F:  MOVLP  00
0B80:  MOVLB  00
0B81:  CALL   3F8
0B82:  MOVLP  08
0B83:  MOVLW  0D
0B84:  BTFSS  11.4
0B85:  GOTO   384
0B86:  MOVLB  03
0B87:  MOVWF  1A
0B88:  MOVLW  0A
0B89:  MOVLB  00
0B8A:  BTFSS  11.4
0B8B:  GOTO   38A
0B8C:  MOVLB  03
0B8D:  MOVWF  1A
....................                   printf("OK\r\n"); 
0B8E:  MOVLW  61
0B8F:  MOVWF  11
0B90:  MOVLW  02
0B91:  MOVWF  12
0B92:  MOVLB  00
0B93:  CLRF   28
0B94:  BTFSC  0B.7
0B95:  BSF    28.7
0B96:  BCF    0B.7
0B97:  MOVLP  00
0B98:  CALL   174
0B99:  MOVLP  08
0B9A:  BTFSC  28.7
0B9B:  BSF    0B.7
....................                } 
0B9C:  GOTO   569
....................                else if ((rx_msg[index_reader] == '=') && (rx_msg[index_reader+2] == '?')) // case 3 of PWMDUTY command 
0B9D:  MOVLW  20
0B9E:  ADDWF  60,W
0B9F:  MOVWF  04
0BA0:  MOVLW  20
0BA1:  MOVWF  05
0BA2:  BTFSC  03.0
0BA3:  INCF   05,F
0BA4:  MOVF   00,W
0BA5:  SUBLW  3D
0BA6:  BTFSS  03.2
0BA7:  GOTO   4A0
0BA8:  MOVLW  02
0BA9:  ADDWF  60,W
0BAA:  ADDLW  20
0BAB:  MOVWF  04
0BAC:  MOVLW  20
0BAD:  MOVWF  05
0BAE:  BTFSC  03.0
0BAF:  INCF   05,F
0BB0:  MOVF   00,W
0BB1:  SUBLW  3F
0BB2:  BTFSS  03.2
0BB3:  GOTO   4A0
....................                { 
....................                   // read the channel 
....................                   desired_pwm_channel = rx_msg[index_reader+1]; 
0BB4:  MOVLW  01
0BB5:  ADDWF  60,W
0BB6:  ADDLW  20
0BB7:  MOVWF  04
0BB8:  MOVLW  20
0BB9:  MOVWF  05
0BBA:  BTFSC  03.0
0BBB:  INCF   05,F
0BBC:  MOVF   00,W
0BBD:  MOVWF  67
....................                    
....................                   // answer the command 
....................                   if (desired_pwm_channel == '1') 
0BBE:  MOVF   67,W
0BBF:  SUBLW  31
0BC0:  BTFSS  03.2
0BC1:  GOTO   3F2
....................                   { 
....................                      printf("+PWMDUTY1:%X%X\r\n", (int)(desired_dutycycle_pwm1>>8), (int)(desired_dutycycle_pwm1)); 
0BC2:  MOVF   34,W
0BC3:  CLRF   7A
0BC4:  MOVLB  02
0BC5:  MOVWF  32
0BC6:  MOVLW  64
0BC7:  MOVLB  03
0BC8:  MOVWF  11
0BC9:  MOVLW  02
0BCA:  MOVWF  12
0BCB:  BCF    03.0
0BCC:  MOVLW  0A
0BCD:  MOVLB  02
0BCE:  MOVWF  36
0BCF:  MOVLP  00
0BD0:  MOVLB  00
0BD1:  CALL   39C
0BD2:  MOVLP  08
0BD3:  MOVLB  02
0BD4:  MOVF   32,W
0BD5:  MOVWF  36
0BD6:  MOVLW  37
0BD7:  MOVWF  37
0BD8:  MOVLP  00
0BD9:  MOVLB  00
0BDA:  CALL   3F8
0BDB:  MOVLP  08
0BDC:  MOVF   33,W
0BDD:  MOVLB  02
0BDE:  MOVWF  36
0BDF:  MOVLW  37
0BE0:  MOVWF  37
0BE1:  MOVLP  00
0BE2:  MOVLB  00
0BE3:  CALL   3F8
0BE4:  MOVLP  08
0BE5:  MOVLW  0D
0BE6:  BTFSS  11.4
0BE7:  GOTO   3E6
0BE8:  MOVLB  03
0BE9:  MOVWF  1A
0BEA:  MOVLW  0A
0BEB:  MOVLB  00
0BEC:  BTFSS  11.4
0BED:  GOTO   3EC
0BEE:  MOVLB  03
0BEF:  MOVWF  1A
....................                   } 
0BF0:  GOTO   49E
0BF1:  MOVLB  00
....................                   else if (desired_pwm_channel == '2') 
0BF2:  MOVF   67,W
0BF3:  SUBLW  32
0BF4:  BTFSS  03.2
0BF5:  GOTO   426
....................                   { 
....................                      printf("+PWMDUTY2:%X%X\r\n", (int)(desired_dutycycle_pwm2>>8), (int)(desired_dutycycle_pwm2)); 
0BF6:  MOVF   36,W
0BF7:  CLRF   7A
0BF8:  MOVLB  02
0BF9:  MOVWF  32
0BFA:  MOVLW  6D
0BFB:  MOVLB  03
0BFC:  MOVWF  11
0BFD:  MOVLW  02
0BFE:  MOVWF  12
0BFF:  BCF    03.0
0C00:  MOVLW  0A
0C01:  MOVLB  02
0C02:  MOVWF  36
0C03:  MOVLP  00
0C04:  MOVLB  00
0C05:  CALL   39C
0C06:  MOVLP  08
0C07:  MOVLB  02
0C08:  MOVF   32,W
0C09:  MOVWF  36
0C0A:  MOVLW  37
0C0B:  MOVWF  37
0C0C:  MOVLP  00
0C0D:  MOVLB  00
0C0E:  CALL   3F8
0C0F:  MOVLP  08
0C10:  MOVF   35,W
0C11:  MOVLB  02
0C12:  MOVWF  36
0C13:  MOVLW  37
0C14:  MOVWF  37
0C15:  MOVLP  00
0C16:  MOVLB  00
0C17:  CALL   3F8
0C18:  MOVLP  08
0C19:  MOVLW  0D
0C1A:  BTFSS  11.4
0C1B:  GOTO   41A
0C1C:  MOVLB  03
0C1D:  MOVWF  1A
0C1E:  MOVLW  0A
0C1F:  MOVLB  00
0C20:  BTFSS  11.4
0C21:  GOTO   420
0C22:  MOVLB  03
0C23:  MOVWF  1A
....................                   } 
0C24:  GOTO   49E
0C25:  MOVLB  00
....................                   else if (desired_pwm_channel == '3') 
0C26:  MOVF   67,W
0C27:  SUBLW  33
0C28:  BTFSS  03.2
0C29:  GOTO   45A
....................                   { 
....................                      printf("+PWMDUTY3:%X%X\r\n", (int)(desired_dutycycle_pwm3>>8), (int)(desired_dutycycle_pwm3)); 
0C2A:  MOVF   38,W
0C2B:  CLRF   7A
0C2C:  MOVLB  02
0C2D:  MOVWF  32
0C2E:  MOVLW  76
0C2F:  MOVLB  03
0C30:  MOVWF  11
0C31:  MOVLW  02
0C32:  MOVWF  12
0C33:  BCF    03.0
0C34:  MOVLW  0A
0C35:  MOVLB  02
0C36:  MOVWF  36
0C37:  MOVLP  00
0C38:  MOVLB  00
0C39:  CALL   39C
0C3A:  MOVLP  08
0C3B:  MOVLB  02
0C3C:  MOVF   32,W
0C3D:  MOVWF  36
0C3E:  MOVLW  37
0C3F:  MOVWF  37
0C40:  MOVLP  00
0C41:  MOVLB  00
0C42:  CALL   3F8
0C43:  MOVLP  08
0C44:  MOVF   37,W
0C45:  MOVLB  02
0C46:  MOVWF  36
0C47:  MOVLW  37
0C48:  MOVWF  37
0C49:  MOVLP  00
0C4A:  MOVLB  00
0C4B:  CALL   3F8
0C4C:  MOVLP  08
0C4D:  MOVLW  0D
0C4E:  BTFSS  11.4
0C4F:  GOTO   44E
0C50:  MOVLB  03
0C51:  MOVWF  1A
0C52:  MOVLW  0A
0C53:  MOVLB  00
0C54:  BTFSS  11.4
0C55:  GOTO   454
0C56:  MOVLB  03
0C57:  MOVWF  1A
....................                   } 
0C58:  GOTO   49E
0C59:  MOVLB  00
....................                   else if (desired_pwm_channel == '4') 
0C5A:  MOVF   67,W
0C5B:  SUBLW  34
0C5C:  BTFSS  03.2
0C5D:  GOTO   48E
....................                   { 
....................                      printf("+PWMDUTY4:%X%X\r\n", (int)(desired_dutycycle_pwm4>>8), (int)(desired_dutycycle_pwm4)); 
0C5E:  MOVF   3A,W
0C5F:  CLRF   7A
0C60:  MOVLB  02
0C61:  MOVWF  32
0C62:  MOVLW  7F
0C63:  MOVLB  03
0C64:  MOVWF  11
0C65:  MOVLW  02
0C66:  MOVWF  12
0C67:  BCF    03.0
0C68:  MOVLW  0A
0C69:  MOVLB  02
0C6A:  MOVWF  36
0C6B:  MOVLP  00
0C6C:  MOVLB  00
0C6D:  CALL   39C
0C6E:  MOVLP  08
0C6F:  MOVLB  02
0C70:  MOVF   32,W
0C71:  MOVWF  36
0C72:  MOVLW  37
0C73:  MOVWF  37
0C74:  MOVLP  00
0C75:  MOVLB  00
0C76:  CALL   3F8
0C77:  MOVLP  08
0C78:  MOVF   39,W
0C79:  MOVLB  02
0C7A:  MOVWF  36
0C7B:  MOVLW  37
0C7C:  MOVWF  37
0C7D:  MOVLP  00
0C7E:  MOVLB  00
0C7F:  CALL   3F8
0C80:  MOVLP  08
0C81:  MOVLW  0D
0C82:  BTFSS  11.4
0C83:  GOTO   482
0C84:  MOVLB  03
0C85:  MOVWF  1A
0C86:  MOVLW  0A
0C87:  MOVLB  00
0C88:  BTFSS  11.4
0C89:  GOTO   488
0C8A:  MOVLB  03
0C8B:  MOVWF  1A
....................                   } 
0C8C:  GOTO   49E
0C8D:  MOVLB  00
....................                   else 
....................                   { 
....................                      // the command is not recognized 
....................                      printf("ERROR\r\n"); 
0C8E:  MOVLW  88
0C8F:  MOVLB  03
0C90:  MOVWF  11
0C91:  MOVLW  02
0C92:  MOVWF  12
0C93:  MOVLB  00
0C94:  CLRF   28
0C95:  BTFSC  0B.7
0C96:  BSF    28.7
0C97:  BCF    0B.7
0C98:  MOVLP  00
0C99:  CALL   174
0C9A:  MOVLP  08
0C9B:  BTFSC  28.7
0C9C:  BSF    0B.7
0C9D:  MOVLB  03
....................                   } 
....................                } 
0C9E:  GOTO   56A
0C9F:  MOVLB  00
....................                else if (rx_msg[index_reader] == '=') // case 1 of PWMDUTY command 
0CA0:  MOVLW  20
0CA1:  ADDWF  60,W
0CA2:  MOVWF  04
0CA3:  MOVLW  20
0CA4:  MOVWF  05
0CA5:  BTFSC  03.0
0CA6:  INCF   05,F
0CA7:  MOVF   00,W
0CA8:  SUBLW  3D
0CA9:  BTFSS  03.2
0CAA:  GOTO   55A
....................                { 
....................                   // read the channel 
....................                   desired_pwm_channel = rx_msg[index_reader+1]; 
0CAB:  MOVLW  01
0CAC:  ADDWF  60,W
0CAD:  ADDLW  20
0CAE:  MOVWF  04
0CAF:  MOVLW  20
0CB0:  MOVWF  05
0CB1:  BTFSC  03.0
0CB2:  INCF   05,F
0CB3:  MOVF   00,W
0CB4:  MOVWF  67
....................                    
....................                   // read the value 
....................                   for (i = index_reader+3; i <= index_rx_msg; i++) ///////// CHANGE THISSSSSS TO JUST < TO GET FINAL \r\n 
0CB5:  MOVLW  03
0CB6:  ADDWF  60,W
0CB7:  MOVLB  02
0CB8:  MOVWF  2D
0CB9:  MOVF   2D,W
0CBA:  MOVLB  00
0CBB:  SUBWF  54,W
0CBC:  BTFSS  03.0
0CBD:  GOTO   4DC
....................                   { 
....................                      // add character to value buffer 
....................                      value_msg[index_value_msg] = rx_msg[i]; 
0CBE:  MOVLW  41
0CBF:  ADDWF  66,W
0CC0:  MOVLB  02
0CC1:  MOVWF  32
0CC2:  MOVLW  20
0CC3:  MOVWF  33
0CC4:  BTFSC  03.0
0CC5:  INCF   33,F
0CC6:  MOVLW  20
0CC7:  ADDWF  2D,W
0CC8:  MOVWF  04
0CC9:  MOVLW  20
0CCA:  MOVWF  05
0CCB:  BTFSC  03.0
0CCC:  INCF   05,F
0CCD:  MOVF   00,W
0CCE:  MOVWF  34
0CCF:  MOVF   33,W
0CD0:  MOVWF  05
0CD1:  MOVF   32,W
0CD2:  MOVWF  04
0CD3:  MOVF   34,W
0CD4:  MOVWF  00
....................                      index_value_msg += 1; 
0CD5:  MOVLW  01
0CD6:  MOVLB  00
0CD7:  ADDWF  66,F
0CD8:  MOVLB  02
0CD9:  INCF   2D,F
0CDA:  GOTO   4B9
0CDB:  MOVLB  00
....................                   } 
....................                    
....................                   // end of value (read buffer to get the number) 
....................                   unsigned int16 temp_desired_pwm_dutycyle = 0; 
0CDC:  MOVLB  02
0CDD:  CLRF   31
0CDE:  CLRF   30
....................                   for (i = 0; i < index_value_msg; i++) 
0CDF:  CLRF   2D
0CE0:  MOVLB  00
0CE1:  MOVF   66,W
0CE2:  MOVLB  02
0CE3:  SUBWF  2D,W
0CE4:  BTFSC  03.0
0CE5:  GOTO   506
....................                   { 
....................                      temp_desired_pwm_dutycyle += char_hex_to_dec(value_msg[i],index_value_msg-2-i); 
0CE6:  MOVLW  41
0CE7:  ADDWF  2D,W
0CE8:  MOVWF  04
0CE9:  MOVLW  20
0CEA:  MOVWF  05
0CEB:  BTFSC  03.0
0CEC:  INCF   05,F
0CED:  MOVF   00,W
0CEE:  MOVWF  32
0CEF:  MOVLW  02
0CF0:  MOVLB  00
0CF1:  SUBWF  66,W
0CF2:  MOVWF  78
0CF3:  MOVLB  02
0CF4:  MOVF   2D,W
0CF5:  SUBWF  78,W
0CF6:  MOVWF  33
0CF7:  MOVF   32,W
0CF8:  MOVWF  34
0CF9:  MOVF   33,W
0CFA:  MOVWF  35
0CFB:  MOVLP  00
0CFC:  MOVLB  00
0CFD:  CALL   422
0CFE:  MOVLP  08
0CFF:  MOVF   77,W
0D00:  MOVLB  02
0D01:  ADDWF  30,F
0D02:  MOVF   78,W
0D03:  ADDWFC 31,F
0D04:  INCF   2D,F
0D05:  GOTO   4E0
....................                   } 
....................                    
....................                   // answer the command 
....................                   if (desired_pwm_channel == '1') 
0D06:  MOVLB  00
0D07:  MOVF   67,W
0D08:  SUBLW  31
0D09:  BTFSS  03.2
0D0A:  GOTO   514
....................                   { 
....................                      desired_dutycycle_pwm1 = temp_desired_pwm_dutycyle; // assig final value of PWM dutycycle 
0D0B:  MOVLB  02
0D0C:  MOVF   31,W
0D0D:  MOVLB  00
0D0E:  MOVWF  34
0D0F:  MOVLB  02
0D10:  MOVF   30,W
0D11:  MOVLB  00
0D12:  MOVWF  33
....................                   } 
0D13:  GOTO   54A
....................                   else if (desired_pwm_channel == '2') 
0D14:  MOVF   67,W
0D15:  SUBLW  32
0D16:  BTFSS  03.2
0D17:  GOTO   521
....................                   { 
....................                      desired_dutycycle_pwm2 = temp_desired_pwm_dutycyle; // assig final value of PWM dutycycle 
0D18:  MOVLB  02
0D19:  MOVF   31,W
0D1A:  MOVLB  00
0D1B:  MOVWF  36
0D1C:  MOVLB  02
0D1D:  MOVF   30,W
0D1E:  MOVLB  00
0D1F:  MOVWF  35
....................                   } 
0D20:  GOTO   54A
....................                   else if (desired_pwm_channel == '3') 
0D21:  MOVF   67,W
0D22:  SUBLW  33
0D23:  BTFSS  03.2
0D24:  GOTO   52E
....................                   { 
....................                      desired_dutycycle_pwm3 = temp_desired_pwm_dutycyle; // assig final value of PWM dutycycle 
0D25:  MOVLB  02
0D26:  MOVF   31,W
0D27:  MOVLB  00
0D28:  MOVWF  38
0D29:  MOVLB  02
0D2A:  MOVF   30,W
0D2B:  MOVLB  00
0D2C:  MOVWF  37
....................                   } 
0D2D:  GOTO   54A
....................                   else if (desired_pwm_channel == '4') 
0D2E:  MOVF   67,W
0D2F:  SUBLW  34
0D30:  BTFSS  03.2
0D31:  GOTO   53B
....................                   { 
....................                      desired_dutycycle_pwm4 = temp_desired_pwm_dutycyle; // assig final value of PWM dutycycle 
0D32:  MOVLB  02
0D33:  MOVF   31,W
0D34:  MOVLB  00
0D35:  MOVWF  3A
0D36:  MOVLB  02
0D37:  MOVF   30,W
0D38:  MOVLB  00
0D39:  MOVWF  39
....................                   } 
0D3A:  GOTO   54A
....................                   else 
....................                   { 
....................                      // the command is not recognized 
....................                      printf("ERROR\r\n"); 
0D3B:  MOVLW  8C
0D3C:  MOVLB  03
0D3D:  MOVWF  11
0D3E:  MOVLW  02
0D3F:  MOVWF  12
0D40:  MOVLB  00
0D41:  CLRF   28
0D42:  BTFSC  0B.7
0D43:  BSF    28.7
0D44:  BCF    0B.7
0D45:  MOVLP  00
0D46:  CALL   174
0D47:  MOVLP  08
0D48:  BTFSC  28.7
0D49:  BSF    0B.7
....................                   } 
....................                    
....................                   printf("OK\r\n"); 
0D4A:  MOVLW  90
0D4B:  MOVLB  03
0D4C:  MOVWF  11
0D4D:  MOVLW  02
0D4E:  MOVWF  12
0D4F:  MOVLB  00
0D50:  CLRF   28
0D51:  BTFSC  0B.7
0D52:  BSF    28.7
0D53:  BCF    0B.7
0D54:  MOVLP  00
0D55:  CALL   174
0D56:  MOVLP  08
0D57:  BTFSC  28.7
0D58:  BSF    0B.7
....................                } 
0D59:  GOTO   569
....................                else 
....................                { 
....................                   // the command is not recognized 
....................                   printf("ERROR\r\n"); 
0D5A:  MOVLW  93
0D5B:  MOVLB  03
0D5C:  MOVWF  11
0D5D:  MOVLW  02
0D5E:  MOVWF  12
0D5F:  MOVLB  00
0D60:  CLRF   28
0D61:  BTFSC  0B.7
0D62:  BSF    28.7
0D63:  BCF    0B.7
0D64:  MOVLP  00
0D65:  CALL   174
0D66:  MOVLP  08
0D67:  BTFSC  28.7
0D68:  BSF    0B.7
0D69:  MOVLB  03
....................                } 
....................             } 
0D6A:  GOTO   654
0D6B:  MOVLB  00
....................              
....................             ////// ABOUT Command ////// 
....................             else if ( (strcmp(identifier_msg, CMD_4) == 0) || (strcmp(identifier_msg, CMD_4_4) == 0) ) 
0D6C:  MOVLW  20
0D6D:  MOVLB  02
0D6E:  MOVWF  33
0D6F:  MOVLW  35
0D70:  MOVWF  32
0D71:  MOVLW  20
0D72:  MOVWF  35
0D73:  MOVLW  85
0D74:  MOVWF  34
0D75:  MOVLP  00
0D76:  MOVLB  00
0D77:  CALL   343
0D78:  MOVLP  08
0D79:  MOVF   78,F
0D7A:  BTFSC  03.2
0D7B:  GOTO   58C
0D7C:  MOVLW  20
0D7D:  MOVLB  02
0D7E:  MOVWF  33
0D7F:  MOVLW  35
0D80:  MOVWF  32
0D81:  MOVLW  20
0D82:  MOVWF  35
0D83:  MOVLW  8F
0D84:  MOVWF  34
0D85:  MOVLP  00
0D86:  MOVLB  00
0D87:  CALL   343
0D88:  MOVLP  08
0D89:  MOVF   78,F
0D8A:  BTFSS  03.2
0D8B:  GOTO   5BA
....................             { 
....................                // answer the command 
....................                printf("Version: 1.0\r\n"); 
0D8C:  MOVLW  97
0D8D:  MOVLB  03
0D8E:  MOVWF  11
0D8F:  MOVLW  02
0D90:  MOVWF  12
0D91:  MOVLB  00
0D92:  CLRF   28
0D93:  BTFSC  0B.7
0D94:  BSF    28.7
0D95:  BCF    0B.7
0D96:  MOVLP  00
0D97:  CALL   174
0D98:  MOVLP  08
0D99:  BTFSC  28.7
0D9A:  BSF    0B.7
....................                printf("Date: 26/08/2022\r\n"); 
0D9B:  MOVLW  9F
0D9C:  MOVLB  03
0D9D:  MOVWF  11
0D9E:  MOVLW  02
0D9F:  MOVWF  12
0DA0:  MOVLB  00
0DA1:  CLRF   28
0DA2:  BTFSC  0B.7
0DA3:  BSF    28.7
0DA4:  BCF    0B.7
0DA5:  MOVLP  00
0DA6:  CALL   174
0DA7:  MOVLP  08
0DA8:  BTFSC  28.7
0DA9:  BSF    0B.7
....................                printf("OK\r\n"); 
0DAA:  MOVLW  A9
0DAB:  MOVLB  03
0DAC:  MOVWF  11
0DAD:  MOVLW  02
0DAE:  MOVWF  12
0DAF:  MOVLB  00
0DB0:  CLRF   28
0DB1:  BTFSC  0B.7
0DB2:  BSF    28.7
0DB3:  BCF    0B.7
0DB4:  MOVLP  00
0DB5:  CALL   174
0DB6:  MOVLP  08
0DB7:  BTFSC  28.7
0DB8:  BSF    0B.7
....................             } 
0DB9:  GOTO   653
....................              
....................             ////// HELP command ////// 
....................             else if ( (strcmp(identifier_msg, CMD_5) == 0) || (strcmp(identifier_msg, CMD_5_5) == 0) )  
0DBA:  MOVLW  20
0DBB:  MOVLB  02
0DBC:  MOVWF  33
0DBD:  MOVLW  35
0DBE:  MOVWF  32
0DBF:  MOVLW  20
0DC0:  MOVWF  35
0DC1:  MOVLW  99
0DC2:  MOVWF  34
0DC3:  MOVLP  00
0DC4:  MOVLB  00
0DC5:  CALL   343
0DC6:  MOVLP  08
0DC7:  MOVF   78,F
0DC8:  BTFSC  03.2
0DC9:  GOTO   5DA
0DCA:  MOVLW  20
0DCB:  MOVLB  02
0DCC:  MOVWF  33
0DCD:  MOVLW  35
0DCE:  MOVWF  32
0DCF:  MOVLW  20
0DD0:  MOVWF  35
0DD1:  MOVLW  A3
0DD2:  MOVWF  34
0DD3:  MOVLP  00
0DD4:  MOVLB  00
0DD5:  CALL   343
0DD6:  MOVLP  08
0DD7:  MOVF   78,F
0DD8:  BTFSS  03.2
0DD9:  GOTO   644
....................             { 
....................                // answer the command 
....................                printf("AT  Comando de prueba\r\n"); 
0DDA:  MOVLW  AC
0DDB:  MOVLB  03
0DDC:  MOVWF  11
0DDD:  MOVLW  02
0DDE:  MOVWF  12
0DDF:  MOVLB  00
0DE0:  CLRF   28
0DE1:  BTFSC  0B.7
0DE2:  BSF    28.7
0DE3:  BCF    0B.7
0DE4:  MOVLP  00
0DE5:  CALL   174
0DE6:  MOVLP  08
0DE7:  BTFSC  28.7
0DE8:  BSF    0B.7
....................                printf("AT+ANOUT  Para establecer salidas analogas\r\n"); 
0DE9:  MOVLW  B8
0DEA:  MOVLB  03
0DEB:  MOVWF  11
0DEC:  MOVLW  02
0DED:  MOVWF  12
0DEE:  MOVLB  00
0DEF:  CLRF   28
0DF0:  BTFSC  0B.7
0DF1:  BSF    28.7
0DF2:  BCF    0B.7
0DF3:  MOVLP  00
0DF4:  CALL   174
0DF5:  MOVLP  08
0DF6:  BTFSC  28.7
0DF7:  BSF    0B.7
....................                printf("AT+PWMPERIOD  Para establecer periodo de canales PWM\r\n"); 
0DF8:  MOVLW  CF
0DF9:  MOVLB  03
0DFA:  MOVWF  11
0DFB:  MOVLW  02
0DFC:  MOVWF  12
0DFD:  MOVLB  00
0DFE:  CLRF   28
0DFF:  BTFSC  0B.7
0E00:  BSF    28.7
0E01:  BCF    0B.7
0E02:  MOVLP  00
0E03:  CALL   174
0E04:  MOVLP  08
0E05:  BTFSC  28.7
0E06:  BSF    0B.7
....................                printf("AT+PWMDUTY  Para establecer ciclo de trabajo de canales PWM\r\n"); 
0E07:  MOVLW  EB
0E08:  MOVLB  03
0E09:  MOVWF  11
0E0A:  MOVLW  02
0E0B:  MOVWF  12
0E0C:  MOVLB  00
0E0D:  CLRF   28
0E0E:  BTFSC  0B.7
0E0F:  BSF    28.7
0E10:  BCF    0B.7
0E11:  MOVLP  00
0E12:  CALL   174
0E13:  MOVLP  08
0E14:  BTFSC  28.7
0E15:  BSF    0B.7
....................                printf("AT+ABOUT  Para mostrar informacion del producto\r\n"); 
0E16:  MOVLW  0A
0E17:  MOVLB  03
0E18:  MOVWF  11
0E19:  MOVLW  03
0E1A:  MOVWF  12
0E1B:  MOVLB  00
0E1C:  CLRF   28
0E1D:  BTFSC  0B.7
0E1E:  BSF    28.7
0E1F:  BCF    0B.7
0E20:  MOVLP  00
0E21:  CALL   174
0E22:  MOVLP  08
0E23:  BTFSC  28.7
0E24:  BSF    0B.7
....................                printf("AT+HELP  Para mostrar lista de comandos\r\n"); 
0E25:  MOVLW  23
0E26:  MOVLB  03
0E27:  MOVWF  11
0E28:  MOVLW  03
0E29:  MOVWF  12
0E2A:  MOVLB  00
0E2B:  CLRF   28
0E2C:  BTFSC  0B.7
0E2D:  BSF    28.7
0E2E:  BCF    0B.7
0E2F:  MOVLP  00
0E30:  CALL   174
0E31:  MOVLP  08
0E32:  BTFSC  28.7
0E33:  BSF    0B.7
....................                printf("OK\r\n"); 
0E34:  MOVLW  38
0E35:  MOVLB  03
0E36:  MOVWF  11
0E37:  MOVLW  03
0E38:  MOVWF  12
0E39:  MOVLB  00
0E3A:  CLRF   28
0E3B:  BTFSC  0B.7
0E3C:  BSF    28.7
0E3D:  BCF    0B.7
0E3E:  MOVLP  00
0E3F:  CALL   174
0E40:  MOVLP  08
0E41:  BTFSC  28.7
0E42:  BSF    0B.7
....................             } 
0E43:  GOTO   653
....................              
....................             else 
....................             { 
....................                // the identifier of the command is not recognized 
....................                printf("ERROR\r\n"); 
0E44:  MOVLW  3B
0E45:  MOVLB  03
0E46:  MOVWF  11
0E47:  MOVLW  03
0E48:  MOVWF  12
0E49:  MOVLB  00
0E4A:  CLRF   28
0E4B:  BTFSC  0B.7
0E4C:  BSF    28.7
0E4D:  BCF    0B.7
0E4E:  MOVLP  00
0E4F:  CALL   174
0E50:  MOVLP  08
0E51:  BTFSC  28.7
0E52:  BSF    0B.7
0E53:  MOVLB  03
....................             } 
....................              
....................             #ifdef __DEBUG__ 
....................             Print_Buffers(); // to view buffer's info in debugging 
0E54:  MOVLP  00
0E55:  MOVLB  00
0E56:  GOTO   4E0
0E57:  MOVLP  08
....................             #endif 
....................          } 
0E58:  GOTO   668
....................          else 
....................          { 
....................             // the structure of the command is not correct 
....................             printf("ERROR\r\n"); 
0E59:  MOVLW  3F
0E5A:  MOVLB  03
0E5B:  MOVWF  11
0E5C:  MOVLW  03
0E5D:  MOVWF  12
0E5E:  MOVLB  00
0E5F:  CLRF   28
0E60:  BTFSC  0B.7
0E61:  BSF    28.7
0E62:  BCF    0B.7
0E63:  MOVLP  00
0E64:  CALL   174
0E65:  MOVLP  08
0E66:  BTFSC  28.7
0E67:  BSF    0B.7
....................          } 
....................           
....................          // clear the buffers 
....................          Clear_Buffers(); 
0E68:  MOVLP  00
0E69:  GOTO   54C
0E6A:  MOVLP  08
....................          // clear the flag 
....................          NEW_MSG_RECEIVED_FLAG = false; 
0E6B:  CLRF   70
....................       } 
....................       else 
....................       { 
....................          // do nothing 
....................       } 
0E6C:  GOTO   106
....................    } 
.................... } 
0E6D:  SLEEP

Configuration Fuses:
   Word  1: 39C2   HS NOWDT PUT MCLR NOPROTECT NOCPD NOBROWNOUT NOCLKOUT IESO FCMEN
   Word  2: 1EFF   NOWRT NOVCAP PLL_SW STVREN BORV19 NODEBUG NOLVP
