CCS PCM C Compiler, Version 5.015, 5967               26-ago.-22 21:24

               Filename:   D:\Proyectos\output_controller\firmware\main.lst

               ROM used:   3389 words (21%)
                           Largest free fragment is 2048
               RAM used:   179 (17%) at main() level
                           212 (21%) worst case
               Stack used: 5 locations (3 in main + 2 for interrupts)
               Stack size: 16

*
0000:  MOVLP  08
0001:  GOTO   33C
0002:  NOP
*
0004:  CLRF   03
0005:  MOVLP  00
0006:  MOVLB  00
0007:  MOVF   77,W
0008:  MOVWF  20
0009:  MOVF   78,W
000A:  MOVWF  21
000B:  MOVF   79,W
000C:  MOVWF  22
000D:  MOVF   7A,W
000E:  MOVWF  23
000F:  MOVLB  03
0010:  MOVF   11,W
0011:  MOVLB  00
0012:  MOVWF  24
0013:  MOVLB  03
0014:  MOVF   12,W
0015:  MOVLB  00
0016:  MOVWF  25
0017:  MOVLB  03
0018:  MOVF   13,W
0019:  MOVLB  00
001A:  MOVWF  26
001B:  MOVLB  03
001C:  MOVF   14,W
001D:  MOVLB  00
001E:  MOVWF  27
001F:  CLRF   05
0020:  MOVLW  91
0021:  MOVWF  04
0022:  BTFSS  00.1
0023:  GOTO   026
0024:  BTFSC  11.1
0025:  GOTO   046
0026:  CLRF   05
0027:  MOVLW  91
0028:  MOVWF  04
0029:  BTFSS  00.5
002A:  GOTO   02D
002B:  BTFSC  11.5
002C:  GOTO   048
002D:  MOVF   20,W
002E:  MOVWF  77
002F:  MOVF   21,W
0030:  MOVWF  78
0031:  MOVF   22,W
0032:  MOVWF  79
0033:  MOVF   23,W
0034:  MOVWF  7A
0035:  MOVF   24,W
0036:  MOVLB  03
0037:  MOVWF  11
0038:  MOVLB  00
0039:  MOVF   25,W
003A:  MOVLB  03
003B:  MOVWF  12
003C:  MOVLB  00
003D:  MOVF   26,W
003E:  MOVLB  03
003F:  MOVWF  13
0040:  MOVLB  00
0041:  MOVF   27,W
0042:  MOVLB  03
0043:  MOVWF  14
0044:  RETFIE
0045:  MOVLB  00
0046:  MOVLP  00
0047:  GOTO   088
0048:  MOVLP  00
0049:  GOTO   1C6
.................... #include <main.h> 
.................... #include <16F1939.h> 
.................... //////////// Standard Header file for the PIC16F1939 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F1939 
004A:  CLRF   78
004B:  CLRF   79
004C:  CLRF   77
004D:  CLRF   7A
004E:  MOVLB  02
004F:  MOVF   40,W
0050:  BTFSS  03.2
0051:  GOTO   055
0052:  MOVF   3F,W
0053:  BTFSC  03.2
0054:  GOTO   06F
0055:  MOVLW  10
0056:  MOVWF  41
0057:  BCF    03.0
0058:  RLF    3D,F
0059:  RLF    3E,F
005A:  RLF    77,F
005B:  RLF    7A,F
005C:  MOVF   40,W
005D:  SUBWF  7A,W
005E:  BTFSS  03.2
005F:  GOTO   062
0060:  MOVF   3F,W
0061:  SUBWF  77,W
0062:  BTFSS  03.0
0063:  GOTO   06B
0064:  MOVF   3F,W
0065:  SUBWF  77,F
0066:  BTFSS  03.0
0067:  DECF   7A,F
0068:  MOVF   40,W
0069:  SUBWF  7A,F
006A:  BSF    03.0
006B:  RLF    78,F
006C:  RLF    79,F
006D:  DECFSZ 41,F
006E:  GOTO   057
006F:  MOVLB  00
0070:  RETURN
0071:  MOVLW  10
0072:  MOVLB  02
0073:  MOVWF  43
0074:  CLRF   77
0075:  CLRF   7A
0076:  RRF    40,F
0077:  RRF    3F,F
0078:  BTFSS  03.0
0079:  GOTO   080
007A:  MOVF   41,W
007B:  ADDWF  77,F
007C:  BTFSC  03.0
007D:  INCF   7A,F
007E:  MOVF   42,W
007F:  ADDWF  7A,F
0080:  RRF    7A,F
0081:  RRF    77,F
0082:  RRF    79,F
0083:  RRF    78,F
0084:  DECFSZ 43,F
0085:  GOTO   076
0086:  MOVLB  00
0087:  RETURN
*
0174:  MOVF   0B,W
0175:  BCF    0B.7
0176:  MOVLB  03
0177:  BSF    15.7
0178:  BSF    15.0
0179:  NOP
017A:  NOP
017B:  BTFSC  09.7
017C:  BSF    0B.7
017D:  MOVF   13,W
017E:  ANDLW  7F
017F:  BTFSC  03.2
0180:  GOTO   1C4
0181:  MOVLB  02
0182:  MOVWF  3D
0183:  MOVLB  03
0184:  MOVF   11,W
0185:  MOVLB  02
0186:  MOVWF  3E
0187:  MOVLB  03
0188:  MOVF   12,W
0189:  MOVLB  02
018A:  MOVWF  3F
018B:  MOVF   3D,W
018C:  MOVLB  00
018D:  BTFSS  11.4
018E:  GOTO   18D
018F:  MOVLB  03
0190:  MOVWF  1A
0191:  MOVLB  02
0192:  MOVF   3E,W
0193:  MOVLB  03
0194:  MOVWF  11
0195:  MOVLB  02
0196:  MOVF   3F,W
0197:  MOVLB  03
0198:  MOVWF  12
0199:  MOVF   0B,W
019A:  BCF    0B.7
019B:  BSF    15.7
019C:  BSF    15.0
019D:  NOP
019E:  NOP
019F:  BTFSC  09.7
01A0:  BSF    0B.7
01A1:  RLF    13,W
01A2:  RLF    14,W
01A3:  ANDLW  7F
01A4:  BTFSC  03.2
01A5:  GOTO   1C4
01A6:  MOVLB  02
01A7:  MOVWF  3D
01A8:  MOVLB  03
01A9:  MOVF   11,W
01AA:  MOVLB  02
01AB:  MOVWF  3E
01AC:  MOVLB  03
01AD:  MOVF   12,W
01AE:  MOVLB  02
01AF:  MOVWF  3F
01B0:  MOVF   3D,W
01B1:  MOVLB  00
01B2:  BTFSS  11.4
01B3:  GOTO   1B2
01B4:  MOVLB  03
01B5:  MOVWF  1A
01B6:  MOVLB  02
01B7:  MOVF   3E,W
01B8:  MOVLB  03
01B9:  MOVWF  11
01BA:  MOVLB  02
01BB:  MOVF   3F,W
01BC:  MOVLB  03
01BD:  MOVWF  12
01BE:  INCF   11,F
01BF:  BTFSC  03.2
01C0:  INCF   12,F
01C1:  MOVLB  00
01C2:  GOTO   174
01C3:  MOVLB  03
01C4:  MOVLB  00
01C5:  RETURN
*
021E:  DATA 45,29
021F:  DATA D2,27
0220:  DATA D2,06
0221:  DATA 0A,00
0222:  DATA 45,29
0223:  DATA D2,27
0224:  DATA D2,06
0225:  DATA 0A,00
0226:  DATA 45,29
0227:  DATA D2,27
0228:  DATA D2,06
0229:  DATA 0A,00
022A:  DATA 2B,28
022B:  DATA D7,26
022C:  DATA C4,2A
022D:  DATA D4,2C
022E:  DATA BA,18
022F:  DATA AC,12
0230:  DATA D8,12
0231:  DATA 58,16
0232:  DATA 32,16
0233:  DATA 25,2C
0234:  DATA 25,2C
0235:  DATA 0D,05
0236:  DATA 00,00
0237:  DATA CF,25
0238:  DATA 0D,05
0239:  DATA 00,01
023A:  DATA AB,20
023B:  DATA CE,27
023C:  DATA 55,2A
023D:  DATA 31,1D
023E:  DATA 25,2C
023F:  DATA 25,2C
0240:  DATA 0D,05
0241:  DATA 00,01
0242:  DATA AB,20
0243:  DATA CE,27
0244:  DATA 55,2A
0245:  DATA 32,1D
0246:  DATA 25,2C
0247:  DATA 25,2C
0248:  DATA 0D,05
0249:  DATA 00,01
024A:  DATA 45,29
024B:  DATA D2,27
024C:  DATA D2,06
024D:  DATA 0A,00
024E:  DATA 45,29
024F:  DATA D2,27
0250:  DATA D2,06
0251:  DATA 0A,00
0252:  DATA CF,25
0253:  DATA 0D,05
0254:  DATA 00,01
0255:  DATA 45,29
0256:  DATA D2,27
0257:  DATA D2,06
0258:  DATA 0A,00
0259:  DATA 2B,28
025A:  DATA D7,26
025B:  DATA D0,22
025C:  DATA D2,24
025D:  DATA 4F,22
025E:  DATA BA,12
025F:  DATA D8,12
0260:  DATA D8,06
0261:  DATA 0A,00
0262:  DATA CF,25
0263:  DATA 0D,05
0264:  DATA 00,01
0265:  DATA 2B,28
0266:  DATA D7,26
0267:  DATA D0,22
0268:  DATA D2,24
0269:  DATA 4F,22
026A:  DATA BA,12
026B:  DATA D8,12
026C:  DATA D8,06
026D:  DATA 0A,00
026E:  DATA CF,25
026F:  DATA 0D,05
0270:  DATA 00,01
0271:  DATA 45,29
0272:  DATA D2,27
0273:  DATA D2,06
0274:  DATA 0A,00
0275:  DATA 2B,28
0276:  DATA D7,26
0277:  DATA C4,2A
0278:  DATA D4,2C
0279:  DATA BA,18
027A:  DATA AC,12
027B:  DATA D8,12
027C:  DATA 58,16
027D:  DATA 32,16
027E:  DATA 25,2C
027F:  DATA 25,2C
0280:  DATA AC,19
0281:  DATA AC,12
0282:  DATA D8,12
0283:  DATA 58,16
0284:  DATA 34,16
0285:  DATA 25,2C
0286:  DATA 25,2C
0287:  DATA 0D,05
0288:  DATA 00,01
0289:  DATA CF,25
028A:  DATA 0D,05
028B:  DATA 00,01
028C:  DATA 2B,28
028D:  DATA D7,26
028E:  DATA C4,2A
028F:  DATA D4,2C
0290:  DATA 31,1D
0291:  DATA 25,2C
0292:  DATA 25,2C
0293:  DATA 0D,05
0294:  DATA 00,01
0295:  DATA 2B,28
0296:  DATA D7,26
0297:  DATA C4,2A
0298:  DATA D4,2C
0299:  DATA 32,1D
029A:  DATA 25,2C
029B:  DATA 25,2C
029C:  DATA 0D,05
029D:  DATA 00,01
029E:  DATA 2B,28
029F:  DATA D7,26
02A0:  DATA C4,2A
02A1:  DATA D4,2C
02A2:  DATA 33,1D
02A3:  DATA 25,2C
02A4:  DATA 25,2C
02A5:  DATA 0D,05
02A6:  DATA 00,01
02A7:  DATA 2B,28
02A8:  DATA D7,26
02A9:  DATA C4,2A
02AA:  DATA D4,2C
02AB:  DATA 34,1D
02AC:  DATA 25,2C
02AD:  DATA 25,2C
02AE:  DATA 0D,05
02AF:  DATA 00,01
02B0:  DATA 45,29
02B1:  DATA D2,27
02B2:  DATA D2,06
02B3:  DATA 0A,00
02B4:  DATA 45,29
02B5:  DATA D2,27
02B6:  DATA D2,06
02B7:  DATA 0A,00
02B8:  DATA CF,25
02B9:  DATA 0D,05
02BA:  DATA 00,01
02BB:  DATA 45,29
02BC:  DATA D2,27
02BD:  DATA D2,06
02BE:  DATA 0A,00
02BF:  DATA D6,32
02C0:  DATA F2,39
02C1:  DATA E9,37
02C2:  DATA 6E,1D
02C3:  DATA A0,18
02C4:  DATA 2E,18
02C5:  DATA 0D,05
02C6:  DATA 00,01
02C7:  DATA C4,30
02C8:  DATA F4,32
02C9:  DATA 3A,10
02CA:  DATA 32,1B
02CB:  DATA 2F,18
02CC:  DATA B8,17
02CD:  DATA 32,18
02CE:  DATA 32,19
02CF:  DATA 0D,05
02D0:  DATA 00,01
02D1:  DATA CF,25
02D2:  DATA 0D,05
02D3:  DATA 00,00
02D4:  DATA 41,2A
02D5:  DATA 20,10
02D6:  DATA C3,37
02D7:  DATA ED,30
02D8:  DATA 6E,32
02D9:  DATA 6F,10
02DA:  DATA E4,32
02DB:  DATA 20,38
02DC:  DATA F2,3A
02DD:  DATA 65,31
02DE:  DATA E1,06
02DF:  DATA 0A,00
02E0:  DATA 41,2A
02E1:  DATA AB,20
02E2:  DATA CE,27
02E3:  DATA 55,2A
02E4:  DATA 20,10
02E5:  DATA D0,30
02E6:  DATA F2,30
02E7:  DATA A0,32
02E8:  DATA 73,3A
02E9:  DATA 61,31
02EA:  DATA EC,32
02EB:  DATA E3,32
02EC:  DATA 72,10
02ED:  DATA F3,30
02EE:  DATA EC,34
02EF:  DATA E4,30
02F0:  DATA 73,10
02F1:  DATA 61,37
02F2:  DATA 61,36
02F3:  DATA EF,33
02F4:  DATA E1,39
02F5:  DATA 0D,05
02F6:  DATA 00,01
02F7:  DATA 41,2A
02F8:  DATA 2B,28
02F9:  DATA D7,26
02FA:  DATA D0,22
02FB:  DATA D2,24
02FC:  DATA 4F,22
02FD:  DATA 20,10
02FE:  DATA D0,30
02FF:  DATA F2,30
0300:  DATA A0,32
0301:  DATA 73,3A
0302:  DATA 61,31
0303:  DATA EC,32
0304:  DATA E3,32
0305:  DATA 72,10
0306:  DATA F0,32
0307:  DATA F2,34
0308:  DATA 6F,32
0309:  DATA 6F,10
030A:  DATA E4,32
030B:  DATA A0,31
030C:  DATA 61,37
030D:  DATA 61,36
030E:  DATA E5,39
030F:  DATA 20,28
0310:  DATA D7,26
0311:  DATA 0D,05
0312:  DATA 00,01
0313:  DATA 41,2A
0314:  DATA 2B,28
0315:  DATA D7,26
0316:  DATA C4,2A
0317:  DATA D4,2C
0318:  DATA 20,10
0319:  DATA D0,30
031A:  DATA F2,30
031B:  DATA A0,32
031C:  DATA 73,3A
031D:  DATA 61,31
031E:  DATA EC,32
031F:  DATA E3,32
0320:  DATA 72,10
0321:  DATA E3,34
0322:  DATA 63,36
0323:  DATA 6F,10
0324:  DATA E4,32
0325:  DATA 20,3A
0326:  DATA F2,30
0327:  DATA E2,30
0328:  DATA EA,37
0329:  DATA 20,32
032A:  DATA 65,10
032B:  DATA E3,30
032C:  DATA EE,30
032D:  DATA EC,32
032E:  DATA 73,10
032F:  DATA D0,2B
0330:  DATA CD,06
0331:  DATA 0A,00
0332:  DATA 41,2A
0333:  DATA AB,20
0334:  DATA C2,27
0335:  DATA 55,2A
0336:  DATA 20,10
0337:  DATA D0,30
0338:  DATA F2,30
0339:  DATA A0,36
033A:  DATA EF,39
033B:  DATA 74,39
033C:  DATA 61,39
033D:  DATA A0,34
033E:  DATA 6E,33
033F:  DATA 6F,39
0340:  DATA ED,30
0341:  DATA E3,34
0342:  DATA 6F,37
0343:  DATA 20,32
0344:  DATA 65,36
0345:  DATA 20,38
0346:  DATA F2,37
0347:  DATA E4,3A
0348:  DATA 63,3A
0349:  DATA EF,06
034A:  DATA 0A,00
034B:  DATA 41,2A
034C:  DATA 2B,24
034D:  DATA 45,26
034E:  DATA 50,10
034F:  DATA 20,28
0350:  DATA 61,39
0351:  DATA 61,10
0352:  DATA ED,37
0353:  DATA 73,3A
0354:  DATA F2,30
0355:  DATA 72,10
0356:  DATA EC,34
0357:  DATA 73,3A
0358:  DATA 61,10
0359:  DATA E4,32
035A:  DATA A0,31
035B:  DATA EF,36
035C:  DATA 61,37
035D:  DATA E4,37
035E:  DATA F3,06
035F:  DATA 0A,00
0360:  DATA CF,25
0361:  DATA 0D,05
0362:  DATA 00,00
0363:  DATA D2,22
0364:  DATA 41,22
0365:  DATA D9,06
0366:  DATA 0A,00
0367:  DATA CF,25
0368:  DATA 0D,05
0369:  DATA 00,01
036A:  DATA 45,29
036B:  DATA D2,27
036C:  DATA D2,06
036D:  DATA 0A,00
036E:  DATA 45,29
036F:  DATA D2,27
0370:  DATA D2,06
0371:  DATA 0A,00
*
03B3:  MOVF   0B,W
03B4:  BCF    0B.7
03B5:  MOVLB  03
03B6:  BSF    15.7
03B7:  BSF    15.0
03B8:  NOP
03B9:  NOP
03BA:  BTFSC  09.7
03BB:  BSF    0B.7
03BC:  BTFSC  03.0
03BD:  GOTO   3E8
03BE:  MOVF   13,W
03BF:  ANDLW  7F
03C0:  MOVLB  02
03C1:  MOVWF  33
03C2:  MOVLB  03
03C3:  MOVF   11,W
03C4:  MOVLB  02
03C5:  MOVWF  34
03C6:  MOVLB  03
03C7:  MOVF   12,W
03C8:  MOVLB  02
03C9:  MOVWF  35
03CA:  MOVF   33,W
03CB:  MOVLB  00
03CC:  BTFSS  11.4
03CD:  GOTO   3CC
03CE:  MOVLB  03
03CF:  MOVWF  1A
03D0:  MOVLB  02
03D1:  MOVF   34,W
03D2:  MOVLB  03
03D3:  MOVWF  11
03D4:  MOVLB  02
03D5:  MOVF   35,W
03D6:  MOVLB  03
03D7:  MOVWF  12
03D8:  MOVF   0B,W
03D9:  BCF    0B.7
03DA:  BSF    15.7
03DB:  BSF    15.0
03DC:  NOP
03DD:  NOP
03DE:  BTFSC  09.7
03DF:  BSF    0B.7
03E0:  MOVLB  02
03E1:  DECFSZ 32,F
03E2:  GOTO   3E4
03E3:  GOTO   3E6
03E4:  MOVLB  03
03E5:  GOTO   3E8
03E6:  GOTO   40D
03E7:  MOVLB  03
03E8:  RLF    13,W
03E9:  RLF    14,W
03EA:  ANDLW  7F
03EB:  MOVLB  02
03EC:  MOVWF  33
03ED:  MOVLB  03
03EE:  MOVF   11,W
03EF:  MOVLB  02
03F0:  MOVWF  34
03F1:  MOVLB  03
03F2:  MOVF   12,W
03F3:  MOVLB  02
03F4:  MOVWF  35
03F5:  MOVF   33,W
03F6:  MOVLB  00
03F7:  BTFSS  11.4
03F8:  GOTO   3F7
03F9:  MOVLB  03
03FA:  MOVWF  1A
03FB:  MOVLB  02
03FC:  MOVF   34,W
03FD:  MOVLB  03
03FE:  MOVWF  11
03FF:  MOVLB  02
0400:  MOVF   35,W
0401:  MOVLB  03
0402:  MOVWF  12
0403:  INCF   11,F
0404:  BTFSC  03.2
0405:  INCF   12,F
0406:  BCF    03.0
0407:  MOVLB  02
0408:  DECFSZ 32,F
0409:  GOTO   40B
040A:  GOTO   40D
040B:  MOVLB  00
040C:  GOTO   3B3
040D:  MOVLB  00
040E:  RETURN
040F:  MOVLB  02
0410:  BTFSC  33.7
0411:  GOTO   426
0412:  MOVLW  0F
0413:  MOVWF  77
0414:  SWAPF  32,W
0415:  ANDWF  77,F
0416:  MOVLW  0A
0417:  SUBWF  77,W
0418:  BTFSC  03.0
0419:  GOTO   41D
041A:  MOVLW  30
041B:  ADDWF  77,F
041C:  GOTO   41F
041D:  MOVF   33,W
041E:  ADDWF  77,F
041F:  MOVF   77,W
0420:  MOVLB  00
0421:  BTFSS  11.4
0422:  GOTO   421
0423:  MOVLB  03
0424:  MOVWF  1A
0425:  MOVLB  02
0426:  MOVLW  0F
0427:  ANDWF  32,F
0428:  MOVLW  0A
0429:  SUBWF  32,W
042A:  BTFSC  03.0
042B:  GOTO   42E
042C:  MOVLW  30
042D:  GOTO   430
042E:  BCF    33.7
042F:  MOVF   33,W
0430:  ADDWF  32,F
0431:  MOVF   32,W
0432:  MOVLB  00
0433:  BTFSS  11.4
0434:  GOTO   433
0435:  MOVLB  03
0436:  MOVWF  1A
0437:  MOVLB  00
0438:  RETURN
*
04CF:  BCF    0A.0
04D0:  BCF    0A.1
04D1:  BSF    0A.2
04D2:  ADDWF  02,F
04D3:  GOTO   448
04D4:  GOTO   44D
04D5:  GOTO   452
04D6:  GOTO   457
04D7:  GOTO   45C
04D8:  GOTO   461
04D9:  GOTO   466
04DA:  GOTO   46B
04DB:  GOTO   470
04DC:  GOTO   493
04DD:  GOTO   493
04DE:  GOTO   493
04DF:  GOTO   493
04E0:  GOTO   493
04E1:  GOTO   493
04E2:  GOTO   493
04E3:  GOTO   475
04E4:  GOTO   47A
04E5:  GOTO   47F
04E6:  GOTO   484
04E7:  GOTO   489
04E8:  GOTO   48E
04E9:  BCF    0A.0
04EA:  BCF    0A.1
04EB:  BSF    0A.2
04EC:  ADDWF  02,F
04ED:  GOTO   49B
04EE:  GOTO   4A0
04EF:  GOTO   4A5
04F0:  GOTO   4AA
....................  
.................... #list 
....................  
.................... #device ADC=16 
....................  
.................... #FUSES NOWDT                    // no Watch Dog Timer 
.................... #FUSES NOBROWNOUT               // no brownout reset 
.................... #FUSES NOLVP                    // no low voltage programming, B3(PIC16) or B5(PIC18) used for I/O 
....................  
.................... #use delay(crystal=20000000)  // external crystal clock 
....................  
.................... // I/O pin configurations 
.................... #use STANDARD_IO( B ) 
.................... #use FIXED_IO( B_outputs=PIN_B4,PIN_B5 ) 
.................... #use STANDARD_IO( D ) 
.................... #use FIXED_IO( D_outputs=PIN_D3,PIN_D1 ) 
....................  
.................... // Pin definitions 
.................... #define USER_LED     PIN_B4 
.................... #define COMMS_LED    PIN_B5 
.................... #define CS_PIN       PIN_D3  
....................  
.................... #define PWM1_PIN     PIN_C2 
.................... #define PWM2_PIN     PIN_C1 
.................... #define PWM3_PIN     PIN_E0 
.................... #define PWM4_PIN     PIN_D1 
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
0372:  MOVLB  02
0373:  MOVF   2C,W
0374:  MOVWF  7A
0375:  MOVF   2B,W
0376:  MOVWF  04
0377:  MOVF   7A,W
0378:  MOVWF  05
0379:  MOVF   00,W
037A:  MOVWF  2F
037B:  MOVF   2E,W
037C:  MOVWF  7A
037D:  MOVF   2D,W
037E:  MOVWF  04
037F:  MOVF   7A,W
0380:  MOVWF  05
0381:  MOVF   00,W
0382:  SUBWF  2F,W
0383:  BTFSS  03.2
0384:  GOTO   39B
....................       if (*s1 == '\0') 
0385:  MOVF   2C,W
0386:  MOVWF  7A
0387:  MOVF   2B,W
0388:  MOVWF  04
0389:  MOVF   7A,W
038A:  MOVWF  05
038B:  MOVF   00,F
038C:  BTFSS  03.2
038D:  GOTO   391
....................          return(0); 
038E:  MOVLW  00
038F:  MOVWF  78
0390:  GOTO   3B1
0391:  MOVF   2C,W
0392:  MOVWF  7A
0393:  MOVF   2B,W
0394:  INCF   2B,F
0395:  BTFSC  03.2
0396:  INCF   2C,F
0397:  INCF   2D,F
0398:  BTFSC  03.2
0399:  INCF   2E,F
039A:  GOTO   373
....................    return((*s1 < *s2) ? -1: 1); 
039B:  MOVF   2C,W
039C:  MOVWF  7A
039D:  MOVF   2B,W
039E:  MOVWF  04
039F:  MOVF   2C,W
03A0:  MOVWF  05
03A1:  MOVF   00,W
03A2:  MOVWF  2F
03A3:  MOVF   2E,W
03A4:  MOVWF  7A
03A5:  MOVF   2D,W
03A6:  MOVWF  04
03A7:  MOVF   2E,W
03A8:  MOVWF  05
03A9:  MOVF   00,W
03AA:  SUBWF  2F,W
03AB:  BTFSC  03.0
03AC:  GOTO   3AF
03AD:  MOVLW  FF
03AE:  GOTO   3B0
03AF:  MOVLW  01
03B0:  MOVWF  78
03B1:  MOVLB  00
03B2:  RETURN
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... //#define __DEBUG__ 
....................  
.................... // Configuration of communication peripherals 
.................... #use rs232(baud=9600,xmit=PIN_C6,rcv=PIN_C7,bits=8,parity=N) 
.................... #use SPI (MASTER, SPI1, BAUD=5000000, MODE=2, BITS=8, STREAM=SPI_1, MSB_FIRST) 
....................  
.................... // Define variables 
.................... unsigned int16 desired_anout1_value = 500; // 0x0000 - 0x03FF 
.................... unsigned int16 desired_anout2_value = 800; // 0x0000 - 0x03FF 
....................  
.................... unsigned int16 pwm_counter = 0; // counter of timer2 timebase 
.................... unsigned int16 desired_pwm_period = 6579; // 100ms 
....................  
.................... unsigned int16 desired_dutycycle_pwm1 = 25; // 0-100% 
.................... unsigned int16 desired_dutycycle_pwm2 = 50; // 0-100% 
.................... unsigned int16 desired_dutycycle_pwm3 = 75; // 0-100% 
.................... unsigned int16 desired_dutycycle_pwm4 = 100; // 0-100% 
....................  
.................... // Variables to UART communications 
.................... unsigned char char_received = 0; // variable to save chars received by UART 
....................  
.................... unsigned char rx_msg[20] = {0}; // buffer to receive UART messages 
.................... unsigned int8 index_rx_msg = 0; // index to manage the rx_msg buffer 
....................  
.................... unsigned char identifier_msg[10] = {0}; // buffer to receive UART messages 
.................... unsigned int8 index_identifier_msg = 0; // index to manage the identifier_msg buffer 
....................  
.................... unsigned int8 index_reader = 0; // to read received commands 
....................  
.................... char value_msg[5] = {0}; // buffer to save <value> messages 
.................... unsigned int8 index_value_msg = 0; // index to manage the value_msg buffer 
....................  
.................... char desired_pwm_channel = 0; // variable to save the desired pwm channel in the command 
.................... char desired_anout_channel = 0; // variable to save the desired anout channel in the command 
....................  
.................... // StateMachine to UART Protocol 
.................... enum UART_STATES 
.................... { 
....................    ST_WAIT = 0, 
....................    ST_A = 1, 
....................    ST_MSG = 2 
.................... } uart_state; 
....................  
.................... // UART commands identifiers 
.................... char CMD_1[10] = "ANOUT"; 
.................... char CMD_1_1[10] = "anout"; 
.................... char CMD_2[10] = "PWMPERIOD"; 
.................... char CMD_2_2[10] = "pwmperiod";   
.................... char CMD_3[10] = "PWMDUTY"; 
.................... char CMD_3_3[10] = "pwmduty"; 
.................... char CMD_4[10] = "ABOUT"; 
.................... char CMD_4_4[10] = "about"; 
.................... char CMD_5[10] = "HELP"; 
.................... char CMD_5_5[10] = "help"; 
....................  
.................... // Flags to manage events 
.................... volatile int8 NEW_MSG_RECEIVED_FLAG = false; 
....................  
....................  
.................... #INT_TIMER2 
.................... /* 
.................... * ISR Function to generate PWM timebase 
.................... */ 
.................... void ISR_Timer_2(void) 
.................... {    
....................    // set pwm period 
....................    if (pwm_counter == desired_pwm_period) 
*
0088:  MOVF   31,W
0089:  SUBWF  2F,W
008A:  BTFSS  03.2
008B:  GOTO   093
008C:  MOVF   32,W
008D:  SUBWF  30,W
008E:  BTFSS  03.2
008F:  GOTO   093
....................    { 
....................       // reset the counter to get the desired period 
....................       pwm_counter = 0; 
0090:  CLRF   30
0091:  CLRF   2F
....................    } 
0092:  GOTO   097
....................    else 
....................    { 
....................       // count timebase 
....................       pwm_counter += 1; 
0093:  MOVLW  01
0094:  ADDWF  2F,F
0095:  MOVLW  00
0096:  ADDWFC 30,F
....................    } 
....................     
....................    // set pwm outputs 
....................    if (pwm_counter < (desired_pwm_period/100)*desired_dutycycle_pwm1) 
0097:  MOVF   32,W
0098:  MOVLB  02
0099:  MOVWF  3E
009A:  MOVLB  00
009B:  MOVF   31,W
009C:  MOVLB  02
009D:  MOVWF  3D
009E:  CLRF   40
009F:  MOVLW  64
00A0:  MOVWF  3F
00A1:  MOVLB  00
00A2:  CALL   04A
00A3:  MOVF   79,W
00A4:  MOVLB  02
00A5:  MOVWF  3E
00A6:  MOVF   78,W
00A7:  MOVWF  3D
00A8:  MOVF   3E,W
00A9:  MOVWF  40
00AA:  MOVF   3D,W
00AB:  MOVWF  3F
00AC:  MOVLB  00
00AD:  MOVF   34,W
00AE:  MOVLB  02
00AF:  MOVWF  42
00B0:  MOVLB  00
00B1:  MOVF   33,W
00B2:  MOVLB  02
00B3:  MOVWF  41
00B4:  MOVLB  00
00B5:  CALL   071
00B6:  MOVF   79,W
00B7:  MOVWF  7A
00B8:  MOVF   30,W
00B9:  SUBWF  7A,W
00BA:  BTFSS  03.0
00BB:  GOTO   0C8
00BC:  BTFSS  03.2
00BD:  GOTO   0C2
00BE:  MOVF   78,W
00BF:  SUBWF  2F,W
00C0:  BTFSC  03.0
00C1:  GOTO   0C8
....................    { 
....................       // activate pwm1 output 
....................       output_high(PWM1_PIN); 
00C2:  MOVLB  01
00C3:  BCF    0E.2
00C4:  MOVLB  02
00C5:  BSF    0E.2
....................    } 
00C6:  GOTO   0CC
00C7:  MOVLB  00
....................    else 
....................    { 
....................       output_low(PWM1_PIN); 
00C8:  MOVLB  01
00C9:  BCF    0E.2
00CA:  MOVLB  02
00CB:  BCF    0E.2
....................    } 
....................     
....................    if (pwm_counter < (desired_pwm_period/100)*desired_dutycycle_pwm2) 
00CC:  MOVLB  00
00CD:  MOVF   32,W
00CE:  MOVLB  02
00CF:  MOVWF  3E
00D0:  MOVLB  00
00D1:  MOVF   31,W
00D2:  MOVLB  02
00D3:  MOVWF  3D
00D4:  CLRF   40
00D5:  MOVLW  64
00D6:  MOVWF  3F
00D7:  MOVLB  00
00D8:  CALL   04A
00D9:  MOVF   79,W
00DA:  MOVLB  02
00DB:  MOVWF  3E
00DC:  MOVF   78,W
00DD:  MOVWF  3D
00DE:  MOVF   3E,W
00DF:  MOVWF  40
00E0:  MOVF   3D,W
00E1:  MOVWF  3F
00E2:  MOVLB  00
00E3:  MOVF   36,W
00E4:  MOVLB  02
00E5:  MOVWF  42
00E6:  MOVLB  00
00E7:  MOVF   35,W
00E8:  MOVLB  02
00E9:  MOVWF  41
00EA:  MOVLB  00
00EB:  CALL   071
00EC:  MOVF   79,W
00ED:  MOVWF  7A
00EE:  MOVF   30,W
00EF:  SUBWF  7A,W
00F0:  BTFSS  03.0
00F1:  GOTO   0FE
00F2:  BTFSS  03.2
00F3:  GOTO   0F8
00F4:  MOVF   78,W
00F5:  SUBWF  2F,W
00F6:  BTFSC  03.0
00F7:  GOTO   0FE
....................    { 
....................       // activate pwm2 output 
....................       output_high(PWM2_PIN); 
00F8:  MOVLB  01
00F9:  BCF    0E.1
00FA:  MOVLB  02
00FB:  BSF    0E.1
....................    } 
00FC:  GOTO   102
00FD:  MOVLB  00
....................    else 
....................    { 
....................       output_low(PWM2_PIN); 
00FE:  MOVLB  01
00FF:  BCF    0E.1
0100:  MOVLB  02
0101:  BCF    0E.1
....................    } 
....................     
....................    if (pwm_counter < (desired_pwm_period/100)*desired_dutycycle_pwm3) 
0102:  MOVLB  00
0103:  MOVF   32,W
0104:  MOVLB  02
0105:  MOVWF  3E
0106:  MOVLB  00
0107:  MOVF   31,W
0108:  MOVLB  02
0109:  MOVWF  3D
010A:  CLRF   40
010B:  MOVLW  64
010C:  MOVWF  3F
010D:  MOVLB  00
010E:  CALL   04A
010F:  MOVF   79,W
0110:  MOVLB  02
0111:  MOVWF  3E
0112:  MOVF   78,W
0113:  MOVWF  3D
0114:  MOVF   3E,W
0115:  MOVWF  40
0116:  MOVF   3D,W
0117:  MOVWF  3F
0118:  MOVLB  00
0119:  MOVF   38,W
011A:  MOVLB  02
011B:  MOVWF  42
011C:  MOVLB  00
011D:  MOVF   37,W
011E:  MOVLB  02
011F:  MOVWF  41
0120:  MOVLB  00
0121:  CALL   071
0122:  MOVF   79,W
0123:  MOVWF  7A
0124:  MOVF   30,W
0125:  SUBWF  7A,W
0126:  BTFSS  03.0
0127:  GOTO   134
0128:  BTFSS  03.2
0129:  GOTO   12E
012A:  MOVF   78,W
012B:  SUBWF  2F,W
012C:  BTFSC  03.0
012D:  GOTO   134
....................    { 
....................       // activate pwm3 output 
....................       output_high(PWM3_PIN); 
012E:  MOVLB  01
012F:  BCF    10.0
0130:  MOVLB  02
0131:  BSF    10.0
....................    } 
0132:  GOTO   138
0133:  MOVLB  00
....................    else 
....................    { 
....................       output_low(PWM3_PIN); 
0134:  MOVLB  01
0135:  BCF    10.0
0136:  MOVLB  02
0137:  BCF    10.0
....................    } 
....................     
....................    if (pwm_counter < (desired_pwm_period/100)*desired_dutycycle_pwm4) 
0138:  MOVLB  00
0139:  MOVF   32,W
013A:  MOVLB  02
013B:  MOVWF  3E
013C:  MOVLB  00
013D:  MOVF   31,W
013E:  MOVLB  02
013F:  MOVWF  3D
0140:  CLRF   40
0141:  MOVLW  64
0142:  MOVWF  3F
0143:  MOVLB  00
0144:  CALL   04A
0145:  MOVF   79,W
0146:  MOVLB  02
0147:  MOVWF  3E
0148:  MOVF   78,W
0149:  MOVWF  3D
014A:  MOVF   3E,W
014B:  MOVWF  40
014C:  MOVF   3D,W
014D:  MOVWF  3F
014E:  MOVLB  00
014F:  MOVF   3A,W
0150:  MOVLB  02
0151:  MOVWF  42
0152:  MOVLB  00
0153:  MOVF   39,W
0154:  MOVLB  02
0155:  MOVWF  41
0156:  MOVLB  00
0157:  CALL   071
0158:  MOVF   79,W
0159:  MOVWF  7A
015A:  MOVF   30,W
015B:  SUBWF  7A,W
015C:  BTFSS  03.0
015D:  GOTO   16B
015E:  BTFSS  03.2
015F:  GOTO   164
0160:  MOVF   78,W
0161:  SUBWF  2F,W
0162:  BTFSC  03.0
0163:  GOTO   16B
....................    { 
....................       // activate pwm4 output 
....................       output_high(PWM4_PIN); 
0164:  MOVLW  F5
0165:  MOVLB  01
0166:  MOVWF  0F
0167:  MOVLB  02
0168:  BSF    0F.1
....................    } 
0169:  GOTO   170
016A:  MOVLB  00
....................    else 
....................    { 
....................       output_low(PWM4_PIN); 
016B:  MOVLW  F5
016C:  MOVLB  01
016D:  MOVWF  0F
016E:  MOVLB  02
016F:  BCF    0F.1
....................    } 
.................... } 
....................  
....................  
0170:  MOVLB  00
0171:  BCF    11.1
0172:  MOVLP  00
0173:  GOTO   02D
.................... #INT_RDA 
.................... /* 
.................... * ISR Function to read UART messages 
.................... */ 
.................... void ISR_Receive_UART(void) 
.................... { 
....................    char_received = getc(); // read the received byte 
*
01C6:  BTFSS  11.5
01C7:  GOTO   1C6
01C8:  MOVLB  03
01C9:  MOVF   19,W
01CA:  MOVLB  00
01CB:  MOVWF  3B
....................     
....................    switch(uart_state) 
01CC:  MOVF   65,W
01CD:  BTFSC  03.2
01CE:  GOTO   1D6
01CF:  XORLW  01
01D0:  BTFSC  03.2
01D1:  GOTO   1EA
01D2:  XORLW  03
01D3:  BTFSC  03.2
01D4:  GOTO   1FE
01D5:  GOTO   214
....................    { 
....................       case ST_WAIT: // wait for AT command 
....................       { 
....................          if ( (char_received == 'A') || (char_received == 'a') ) 
01D6:  MOVF   3B,W
01D7:  SUBLW  41
01D8:  BTFSC  03.2
01D9:  GOTO   1DE
01DA:  MOVF   3B,W
01DB:  SUBLW  61
01DC:  BTFSS  03.2
01DD:  GOTO   1E1
....................          { 
....................             // next state 
....................             uart_state = ST_A; 
01DE:  MOVLW  01
01DF:  MOVWF  65
....................          } 
01E0:  GOTO   1E9
....................          else 
....................          { 
....................             // send error and continue in wait state 
....................             printf("ERROR\r\n"); 
01E1:  MOVLW  1E
01E2:  MOVLB  03
01E3:  MOVWF  11
01E4:  MOVLW  02
01E5:  MOVWF  12
01E6:  MOVLB  00
01E7:  CALL   174
....................             uart_state = ST_WAIT; 
01E8:  CLRF   65
....................          } 
....................           
....................          break; 
01E9:  GOTO   21B
....................       }; 
....................        
....................       case ST_A: // wait for AT command 
....................       { 
....................          if (char_received == 'T' || char_received == 't') 
01EA:  MOVF   3B,W
01EB:  SUBLW  54
01EC:  BTFSC  03.2
01ED:  GOTO   1F2
01EE:  MOVF   3B,W
01EF:  SUBLW  74
01F0:  BTFSS  03.2
01F1:  GOTO   1F5
....................          { 
....................             // next state 
....................             uart_state = ST_MSG; 
01F2:  MOVLW  02
01F3:  MOVWF  65
....................          } 
01F4:  GOTO   1FD
....................          else 
....................          { 
....................             // send error and return to wait state 
....................             printf("ERROR\r\n"); 
01F5:  MOVLW  22
01F6:  MOVLB  03
01F7:  MOVWF  11
01F8:  MOVLW  02
01F9:  MOVWF  12
01FA:  MOVLB  00
01FB:  CALL   174
....................             uart_state = ST_WAIT; 
01FC:  CLRF   65
....................          } 
....................           
....................          break; 
01FD:  GOTO   21B
....................       }; 
....................        
....................       case ST_MSG: 
....................       { 
....................          if (char_received == '\r') ///////// CHANGE THISSSSSS TO \n TO GET FINAL \r\n 
01FE:  MOVF   3B,W
01FF:  SUBLW  0D
0200:  BTFSS  03.2
0201:  GOTO   206
....................          { 
....................             // end of message flag 
....................             NEW_MSG_RECEIVED_FLAG = true; 
0202:  MOVLW  01
0203:  MOVWF  70
....................             // next state 
....................             uart_state = ST_WAIT;  
0204:  CLRF   65
....................          } 
0205:  GOTO   213
....................          else 
....................          { 
....................             // add character to buffer 
....................             rx_msg[index_rx_msg] = char_received; 
0206:  MOVLW  1C
0207:  ADDWF  50,W
0208:  MOVWF  04
0209:  MOVLW  20
020A:  MOVWF  05
020B:  BTFSC  03.0
020C:  INCF   05,F
020D:  MOVF   3B,W
020E:  MOVWF  00
....................             index_rx_msg += 1; 
020F:  MOVLW  01
0210:  ADDWF  50,F
....................             // next state 
....................             uart_state = ST_MSG;  
0211:  MOVLW  02
0212:  MOVWF  65
....................          } 
....................           
....................          break; 
0213:  GOTO   21B
....................       }; 
....................        
....................       default: 
....................       { 
....................          printf("ERROR\r\n"); 
0214:  MOVLW  26
0215:  MOVLB  03
0216:  MOVWF  11
0217:  MOVLW  02
0218:  MOVWF  12
0219:  MOVLB  00
021A:  CALL   174
....................          break; 
....................       }; 
....................    } 
021B:  BCF    11.5
021C:  MOVLP  00
021D:  GOTO   02D
.................... } 
....................  
....................  
.................... /* 
.................... * Function to calculate decimal numbers from hex char format 
.................... */ 
.................... int32 char_hex_to_dec(char car, int pos) 
*
0439:  MOVLB  02
043A:  CLRF   33
043B:  CLRF   32
043C:  CLRF   35
043D:  CLRF   34
043E:  CLRF   37
043F:  CLRF   36
.................... { 
....................    unsigned int16 ans = 0; 
....................    unsigned int16 base = 0; 
....................    unsigned int16 exp = 0; 
....................     
....................    switch (car) 
0440:  MOVLW  31
0441:  SUBWF  30,W
0442:  ADDLW  EA
0443:  BTFSC  03.0
0444:  GOTO   494
0445:  ADDLW  16
0446:  MOVLB  00
0447:  GOTO   4CF
....................    { 
....................       case '1': base = 1; 
0448:  MOVLB  02
0449:  CLRF   35
044A:  MOVLW  01
044B:  MOVWF  34
....................       break; 
044C:  GOTO   494
....................        
....................       case '2': base = 2; 
044D:  MOVLB  02
044E:  CLRF   35
044F:  MOVLW  02
0450:  MOVWF  34
....................       break; 
0451:  GOTO   494
....................        
....................       case '3': base = 3; 
0452:  MOVLB  02
0453:  CLRF   35
0454:  MOVLW  03
0455:  MOVWF  34
....................       break; 
0456:  GOTO   494
....................        
....................       case '4': base = 4; 
0457:  MOVLB  02
0458:  CLRF   35
0459:  MOVLW  04
045A:  MOVWF  34
....................       break; 
045B:  GOTO   494
....................        
....................       case '5': base = 5; 
045C:  MOVLB  02
045D:  CLRF   35
045E:  MOVLW  05
045F:  MOVWF  34
....................       break; 
0460:  GOTO   494
....................        
....................       case '6': base = 6; 
0461:  MOVLB  02
0462:  CLRF   35
0463:  MOVLW  06
0464:  MOVWF  34
....................       break; 
0465:  GOTO   494
....................        
....................       case '7': base = 7; 
0466:  MOVLB  02
0467:  CLRF   35
0468:  MOVLW  07
0469:  MOVWF  34
....................       break; 
046A:  GOTO   494
....................        
....................       case '8': base = 8; 
046B:  MOVLB  02
046C:  CLRF   35
046D:  MOVLW  08
046E:  MOVWF  34
....................       break; 
046F:  GOTO   494
....................        
....................       case '9': base = 9; 
0470:  MOVLB  02
0471:  CLRF   35
0472:  MOVLW  09
0473:  MOVWF  34
....................       break; 
0474:  GOTO   494
....................        
....................       case 'A': base = 10; 
0475:  MOVLB  02
0476:  CLRF   35
0477:  MOVLW  0A
0478:  MOVWF  34
....................       break; 
0479:  GOTO   494
....................        
....................       case 'B': base = 11; 
047A:  MOVLB  02
047B:  CLRF   35
047C:  MOVLW  0B
047D:  MOVWF  34
....................       break; 
047E:  GOTO   494
....................        
....................       case 'C': base = 12; 
047F:  MOVLB  02
0480:  CLRF   35
0481:  MOVLW  0C
0482:  MOVWF  34
....................       break; 
0483:  GOTO   494
....................        
....................       case 'D': base = 13; 
0484:  MOVLB  02
0485:  CLRF   35
0486:  MOVLW  0D
0487:  MOVWF  34
....................       break; 
0488:  GOTO   494
....................        
....................       case 'E': base = 14; 
0489:  MOVLB  02
048A:  CLRF   35
048B:  MOVLW  0E
048C:  MOVWF  34
....................       break; 
048D:  GOTO   494
....................        
....................       case 'F': base = 15; 
048E:  MOVLB  02
048F:  CLRF   35
0490:  MOVLW  0F
0491:  MOVWF  34
....................       break; 
0492:  GOTO   494
0493:  MOVLB  02
....................    } 
....................     
....................    switch (pos) 
0494:  MOVF   31,W
0495:  ADDLW  FC
0496:  BTFSC  03.0
0497:  GOTO   4B0
0498:  ADDLW  04
0499:  MOVLB  00
049A:  GOTO   4E9
....................    { 
....................       case 0: exp = 1; 
049B:  MOVLB  02
049C:  CLRF   37
049D:  MOVLW  01
049E:  MOVWF  36
....................       break; 
049F:  GOTO   4B0
....................        
....................       case 1: exp = 16; 
04A0:  MOVLB  02
04A1:  CLRF   37
04A2:  MOVLW  10
04A3:  MOVWF  36
....................       break; 
04A4:  GOTO   4B0
....................        
....................       case 2: exp = 256; 
04A5:  MOVLW  01
04A6:  MOVLB  02
04A7:  MOVWF  37
04A8:  CLRF   36
....................       break; 
04A9:  GOTO   4B0
....................        
....................       case 3: exp = 4096; 
04AA:  MOVLW  10
04AB:  MOVLB  02
04AC:  MOVWF  37
04AD:  CLRF   36
....................       break; 
04AE:  GOTO   4B0
04AF:  MOVLB  02
....................    } 
04B0:  MOVLB  00
04B1:  CLRF   28
04B2:  BTFSC  0B.7
04B3:  BSF    28.7
04B4:  BCF    0B.7
....................     
....................    ans = base*exp; 
04B5:  MOVLB  02
04B6:  MOVF   35,W
04B7:  MOVWF  40
04B8:  MOVF   34,W
04B9:  MOVWF  3F
04BA:  MOVF   37,W
04BB:  MOVWF  42
04BC:  MOVF   36,W
04BD:  MOVWF  41
04BE:  MOVLB  00
04BF:  CALL   071
04C0:  BTFSC  28.7
04C1:  BSF    0B.7
04C2:  MOVF   79,W
04C3:  MOVLB  02
04C4:  MOVWF  33
04C5:  MOVF   78,W
04C6:  MOVWF  32
....................     
....................    return ans; 
04C7:  MOVF   32,W
04C8:  MOVWF  77
04C9:  MOVF   33,W
04CA:  MOVWF  78
04CB:  CLRF   79
04CC:  CLRF   7A
04CD:  MOVLB  00
04CE:  RETURN
.................... } 
....................  
....................  
.................... /* 
.................... * Function to manage ANOUT command 
.................... */ 
.................... void Manage_ANOUT_Command(void) 
*
04F1:  MOVLB  02
04F2:  CLRF   2B
.................... { 
....................    int8 i = 0; // general purpose index 
....................     
....................    if (rx_msg[index_reader] == '?') // case 2 of ANOUT command 
04F3:  MOVLW  1C
04F4:  MOVLB  00
04F5:  ADDWF  5C,W
04F6:  MOVWF  04
04F7:  MOVLW  20
04F8:  MOVWF  05
04F9:  BTFSC  03.0
04FA:  INCF   05,F
04FB:  MOVF   00,W
04FC:  SUBLW  3F
04FD:  BTFSS  03.2
04FE:  GOTO   558
....................    { 
....................       // answer the command 
....................       printf("+PWMDUTY:1,%X%X,2,%X%X\r\n", (int)(desired_anout1_value>>8), (int)(desired_anout1_value),  
....................                                            (int)(desired_anout2_value>>8), (int)(desired_anout2_value)); 
04FF:  MOVF   2C,W
0500:  CLRF   7A
0501:  MOVLB  02
0502:  MOVWF  2E
0503:  MOVLB  00
0504:  MOVF   2E,W
0505:  CLRF   7A
0506:  MOVLB  02
0507:  MOVWF  2F
0508:  MOVLW  2A
0509:  MOVLB  03
050A:  MOVWF  11
050B:  MOVLW  02
050C:  MOVWF  12
050D:  BCF    03.0
050E:  MOVLW  0B
050F:  MOVLB  02
0510:  MOVWF  32
0511:  MOVLB  00
0512:  CALL   3B3
0513:  MOVLB  02
0514:  MOVF   2E,W
0515:  MOVWF  32
0516:  MOVLW  37
0517:  MOVWF  33
0518:  MOVLB  00
0519:  CALL   40F
051A:  MOVF   2B,W
051B:  MOVLB  02
051C:  MOVWF  32
051D:  MOVLW  37
051E:  MOVWF  33
051F:  MOVLB  00
0520:  CALL   40F
0521:  MOVLW  2C
0522:  BTFSS  11.4
0523:  GOTO   522
0524:  MOVLB  03
0525:  MOVWF  1A
0526:  MOVLW  32
0527:  MOVLB  00
0528:  BTFSS  11.4
0529:  GOTO   528
052A:  MOVLB  03
052B:  MOVWF  1A
052C:  MOVLW  2C
052D:  MOVLB  00
052E:  BTFSS  11.4
052F:  GOTO   52E
0530:  MOVLB  03
0531:  MOVWF  1A
0532:  MOVLB  02
0533:  MOVF   2F,W
0534:  MOVWF  32
0535:  MOVLW  37
0536:  MOVWF  33
0537:  MOVLB  00
0538:  CALL   40F
0539:  MOVF   2D,W
053A:  MOVLB  02
053B:  MOVWF  32
053C:  MOVLW  37
053D:  MOVWF  33
053E:  MOVLB  00
053F:  CALL   40F
0540:  MOVLW  0D
0541:  BTFSS  11.4
0542:  GOTO   541
0543:  MOVLB  03
0544:  MOVWF  1A
0545:  MOVLW  0A
0546:  MOVLB  00
0547:  BTFSS  11.4
0548:  GOTO   547
0549:  MOVLB  03
054A:  MOVWF  1A
....................       printf("OK\r\n"); 
054B:  MOVLW  37
054C:  MOVWF  11
054D:  MOVLW  02
054E:  MOVWF  12
054F:  MOVLB  00
0550:  CLRF   28
0551:  BTFSC  0B.7
0552:  BSF    28.7
0553:  BCF    0B.7
0554:  CALL   174
0555:  BTFSC  28.7
0556:  BSF    0B.7
....................    } 
0557:  GOTO   690
....................    else if ((rx_msg[index_reader] == '=') && (rx_msg[index_reader+2] == '?')) // case 3 of ANOUT command 
0558:  MOVLW  1C
0559:  ADDWF  5C,W
055A:  MOVWF  04
055B:  MOVLW  20
055C:  MOVWF  05
055D:  BTFSC  03.0
055E:  INCF   05,F
055F:  MOVF   00,W
0560:  SUBLW  3D
0561:  BTFSS  03.2
0562:  GOTO   5E5
0563:  MOVLW  02
0564:  ADDWF  5C,W
0565:  ADDLW  1C
0566:  MOVWF  04
0567:  MOVLW  20
0568:  MOVWF  05
0569:  BTFSC  03.0
056A:  INCF   05,F
056B:  MOVF   00,W
056C:  SUBLW  3F
056D:  BTFSS  03.2
056E:  GOTO   5E5
....................    { 
....................       // read the channel 
....................       desired_anout_channel = rx_msg[index_reader+1]; 
056F:  MOVLW  01
0570:  ADDWF  5C,W
0571:  ADDLW  1C
0572:  MOVWF  04
0573:  MOVLW  20
0574:  MOVWF  05
0575:  BTFSC  03.0
0576:  INCF   05,F
0577:  MOVF   00,W
0578:  MOVWF  64
....................        
....................       // answer the command 
....................       if (desired_anout_channel == '1') 
0579:  MOVF   64,W
057A:  SUBLW  31
057B:  BTFSS  03.2
057C:  GOTO   5A7
....................       { 
....................          printf("+ANOUT1:%X%X\r\n", (int)(desired_anout1_value>>8), (int)(desired_anout1_value)); 
057D:  MOVF   2C,W
057E:  CLRF   7A
057F:  MOVLB  02
0580:  MOVWF  2E
0581:  MOVLW  3A
0582:  MOVLB  03
0583:  MOVWF  11
0584:  MOVLW  02
0585:  MOVWF  12
0586:  BCF    03.0
0587:  MOVLW  08
0588:  MOVLB  02
0589:  MOVWF  32
058A:  MOVLB  00
058B:  CALL   3B3
058C:  MOVLB  02
058D:  MOVF   2E,W
058E:  MOVWF  32
058F:  MOVLW  37
0590:  MOVWF  33
0591:  MOVLB  00
0592:  CALL   40F
0593:  MOVF   2B,W
0594:  MOVLB  02
0595:  MOVWF  32
0596:  MOVLW  37
0597:  MOVWF  33
0598:  MOVLB  00
0599:  CALL   40F
059A:  MOVLW  0D
059B:  BTFSS  11.4
059C:  GOTO   59B
059D:  MOVLB  03
059E:  MOVWF  1A
059F:  MOVLW  0A
05A0:  MOVLB  00
05A1:  BTFSS  11.4
05A2:  GOTO   5A1
05A3:  MOVLB  03
05A4:  MOVWF  1A
....................       } 
05A5:  GOTO   5E3
05A6:  MOVLB  00
....................       else if (desired_anout_channel == '2') 
05A7:  MOVF   64,W
05A8:  SUBLW  32
05A9:  BTFSS  03.2
05AA:  GOTO   5D5
....................       { 
....................          printf("+ANOUT2:%X%X\r\n", (int)(desired_anout2_value>>8), (int)(desired_anout2_value)); 
05AB:  MOVF   2E,W
05AC:  CLRF   7A
05AD:  MOVLB  02
05AE:  MOVWF  2E
05AF:  MOVLW  42
05B0:  MOVLB  03
05B1:  MOVWF  11
05B2:  MOVLW  02
05B3:  MOVWF  12
05B4:  BCF    03.0
05B5:  MOVLW  08
05B6:  MOVLB  02
05B7:  MOVWF  32
05B8:  MOVLB  00
05B9:  CALL   3B3
05BA:  MOVLB  02
05BB:  MOVF   2E,W
05BC:  MOVWF  32
05BD:  MOVLW  37
05BE:  MOVWF  33
05BF:  MOVLB  00
05C0:  CALL   40F
05C1:  MOVF   2D,W
05C2:  MOVLB  02
05C3:  MOVWF  32
05C4:  MOVLW  37
05C5:  MOVWF  33
05C6:  MOVLB  00
05C7:  CALL   40F
05C8:  MOVLW  0D
05C9:  BTFSS  11.4
05CA:  GOTO   5C9
05CB:  MOVLB  03
05CC:  MOVWF  1A
05CD:  MOVLW  0A
05CE:  MOVLB  00
05CF:  BTFSS  11.4
05D0:  GOTO   5CF
05D1:  MOVLB  03
05D2:  MOVWF  1A
....................       } 
05D3:  GOTO   5E3
05D4:  MOVLB  00
....................       else 
....................       { 
....................          // the command is not recognized 
....................          printf("ERROR\r\n"); 
05D5:  MOVLW  4A
05D6:  MOVLB  03
05D7:  MOVWF  11
05D8:  MOVLW  02
05D9:  MOVWF  12
05DA:  MOVLB  00
05DB:  CLRF   28
05DC:  BTFSC  0B.7
05DD:  BSF    28.7
05DE:  BCF    0B.7
05DF:  CALL   174
05E0:  BTFSC  28.7
05E1:  BSF    0B.7
05E2:  MOVLB  03
....................       } 
....................    } 
05E3:  GOTO   691
05E4:  MOVLB  00
....................    else if (rx_msg[index_reader] == '=') // case 1 of ANOUT command 
05E5:  MOVLW  1C
05E6:  ADDWF  5C,W
05E7:  MOVWF  04
05E8:  MOVLW  20
05E9:  MOVWF  05
05EA:  BTFSC  03.0
05EB:  INCF   05,F
05EC:  MOVF   00,W
05ED:  SUBLW  3D
05EE:  BTFSS  03.2
05EF:  GOTO   683
....................    { 
....................       // read the channel 
....................       desired_anout_channel = rx_msg[index_reader+1]; 
05F0:  MOVLW  01
05F1:  ADDWF  5C,W
05F2:  ADDLW  1C
05F3:  MOVWF  04
05F4:  MOVLW  20
05F5:  MOVWF  05
05F6:  BTFSC  03.0
05F7:  INCF   05,F
05F8:  MOVF   00,W
05F9:  MOVWF  64
....................        
....................       // read the value 
....................       for (i = index_reader+3; i <= index_rx_msg; i++) ///////// CHANGE THISSSSSS TO JUST < TO GET FINAL \r\n 
05FA:  MOVLW  03
05FB:  ADDWF  5C,W
05FC:  MOVLB  02
05FD:  MOVWF  2B
05FE:  MOVF   2B,W
05FF:  MOVLB  00
0600:  SUBWF  50,W
0601:  BTFSS  03.0
0602:  GOTO   625
....................       { 
....................          // add character to value buffer 
....................          value_msg[index_value_msg] = rx_msg[i]; 
0603:  MOVLW  3D
0604:  ADDWF  62,W
0605:  MOVWF  78
0606:  MOVLW  20
0607:  MOVWF  7A
0608:  BTFSC  03.0
0609:  INCF   7A,F
060A:  MOVF   78,W
060B:  MOVLB  02
060C:  MOVWF  2E
060D:  MOVF   7A,W
060E:  MOVWF  2F
060F:  MOVLW  1C
0610:  ADDWF  2B,W
0611:  MOVWF  04
0612:  MOVLW  20
0613:  MOVWF  05
0614:  BTFSC  03.0
0615:  INCF   05,F
0616:  MOVF   00,W
0617:  MOVWF  30
0618:  MOVF   2F,W
0619:  MOVWF  05
061A:  MOVF   2E,W
061B:  MOVWF  04
061C:  MOVF   30,W
061D:  MOVWF  00
....................          index_value_msg += 1; 
061E:  MOVLW  01
061F:  MOVLB  00
0620:  ADDWF  62,F
0621:  MOVLB  02
0622:  INCF   2B,F
0623:  GOTO   5FE
0624:  MOVLB  00
....................       } 
....................        
....................       // end of value (read buffer to get the number) 
....................       unsigned int16 temp_desired_anout = 0; 
0625:  MOVLB  02
0626:  CLRF   2D
0627:  CLRF   2C
....................       for (i = 0; i < index_value_msg; i++) 
0628:  CLRF   2B
0629:  MOVLB  00
062A:  MOVF   62,W
062B:  MOVLB  02
062C:  SUBWF  2B,W
062D:  BTFSC  03.0
062E:  GOTO   64D
....................       { 
....................          temp_desired_anout += char_hex_to_dec(value_msg[i],index_value_msg-2-i); 
062F:  MOVLW  3D
0630:  ADDWF  2B,W
0631:  MOVWF  04
0632:  MOVLW  20
0633:  MOVWF  05
0634:  BTFSC  03.0
0635:  INCF   05,F
0636:  MOVF   00,W
0637:  MOVWF  2E
0638:  MOVLW  02
0639:  MOVLB  00
063A:  SUBWF  62,W
063B:  MOVWF  78
063C:  MOVLB  02
063D:  MOVF   2B,W
063E:  SUBWF  78,W
063F:  MOVWF  2F
0640:  MOVF   2E,W
0641:  MOVWF  30
0642:  MOVF   2F,W
0643:  MOVWF  31
0644:  MOVLB  00
0645:  CALL   439
0646:  MOVF   77,W
0647:  MOVLB  02
0648:  ADDWF  2C,F
0649:  MOVF   78,W
064A:  ADDWFC 2D,F
064B:  INCF   2B,F
064C:  GOTO   629
....................       } 
....................        
....................       // answer the command 
....................       if (desired_anout_channel == '1') 
064D:  MOVLB  00
064E:  MOVF   64,W
064F:  SUBLW  31
0650:  BTFSS  03.2
0651:  GOTO   65B
....................       { 
....................          desired_anout1_value = temp_desired_anout; // assig final value of ANOUT 
0652:  MOVLB  02
0653:  MOVF   2D,W
0654:  MOVLB  00
0655:  MOVWF  2C
0656:  MOVLB  02
0657:  MOVF   2C,W
0658:  MOVLB  00
0659:  MOVWF  2B
....................       } 
065A:  GOTO   675
....................       else if (desired_anout_channel == '2') 
065B:  MOVF   64,W
065C:  SUBLW  32
065D:  BTFSS  03.2
065E:  GOTO   668
....................       { 
....................          desired_anout2_value = temp_desired_anout; // assig final value of ANOUT 
065F:  MOVLB  02
0660:  MOVF   2D,W
0661:  MOVLB  00
0662:  MOVWF  2E
0663:  MOVLB  02
0664:  MOVF   2C,W
0665:  MOVLB  00
0666:  MOVWF  2D
....................       } 
0667:  GOTO   675
....................       else 
....................       { 
....................          // the command is not recognized 
....................          printf("ERROR\r\n"); 
0668:  MOVLW  4E
0669:  MOVLB  03
066A:  MOVWF  11
066B:  MOVLW  02
066C:  MOVWF  12
066D:  MOVLB  00
066E:  CLRF   28
066F:  BTFSC  0B.7
0670:  BSF    28.7
0671:  BCF    0B.7
0672:  CALL   174
0673:  BTFSC  28.7
0674:  BSF    0B.7
....................       } 
....................        
....................       printf("OK\r\n"); 
0675:  MOVLW  52
0676:  MOVLB  03
0677:  MOVWF  11
0678:  MOVLW  02
0679:  MOVWF  12
067A:  MOVLB  00
067B:  CLRF   28
067C:  BTFSC  0B.7
067D:  BSF    28.7
067E:  BCF    0B.7
067F:  CALL   174
0680:  BTFSC  28.7
0681:  BSF    0B.7
....................    } 
0682:  GOTO   690
....................    else 
....................    { 
....................       // the command is not recognized 
....................       printf("ERROR\r\n"); 
0683:  MOVLW  55
0684:  MOVLB  03
0685:  MOVWF  11
0686:  MOVLW  02
0687:  MOVWF  12
0688:  MOVLB  00
0689:  CLRF   28
068A:  BTFSC  0B.7
068B:  BSF    28.7
068C:  BCF    0B.7
068D:  CALL   174
068E:  BTFSC  28.7
068F:  BSF    0B.7
0690:  MOVLB  03
....................    }    
0691:  MOVLP  08
0692:  MOVLB  00
0693:  GOTO   4C8 (RETURN)
.................... } 
....................  
....................  
.................... /* 
.................... * Function to manage PWMPERIOD command 
.................... */ 
.................... void Manage_PWMPERIOD_Command(void) 
0694:  MOVLB  02
0695:  CLRF   2B
.................... { 
....................    int8 i = 0; // general purpose index 
....................  
....................    if (rx_msg[index_reader] == '?') // case 2 of PWMPERIOD command 
0696:  MOVLW  1C
0697:  MOVLB  00
0698:  ADDWF  5C,W
0699:  MOVWF  04
069A:  MOVLW  20
069B:  MOVWF  05
069C:  BTFSC  03.0
069D:  INCF   05,F
069E:  MOVF   00,W
069F:  SUBLW  3F
06A0:  BTFSS  03.2
06A1:  GOTO   6D7
....................    { 
....................       // answer the command 
....................       printf("+PWMPERIOD:%X%X\r\n", (int)(desired_pwm_period>>8), (int)(desired_pwm_period)); 
06A2:  MOVF   32,W
06A3:  CLRF   7A
06A4:  MOVLB  02
06A5:  MOVWF  2E
06A6:  MOVLW  59
06A7:  MOVLB  03
06A8:  MOVWF  11
06A9:  MOVLW  02
06AA:  MOVWF  12
06AB:  BCF    03.0
06AC:  MOVLW  0B
06AD:  MOVLB  02
06AE:  MOVWF  32
06AF:  MOVLB  00
06B0:  CALL   3B3
06B1:  MOVLB  02
06B2:  MOVF   2E,W
06B3:  MOVWF  32
06B4:  MOVLW  37
06B5:  MOVWF  33
06B6:  MOVLB  00
06B7:  CALL   40F
06B8:  MOVF   31,W
06B9:  MOVLB  02
06BA:  MOVWF  32
06BB:  MOVLW  37
06BC:  MOVWF  33
06BD:  MOVLB  00
06BE:  CALL   40F
06BF:  MOVLW  0D
06C0:  BTFSS  11.4
06C1:  GOTO   6C0
06C2:  MOVLB  03
06C3:  MOVWF  1A
06C4:  MOVLW  0A
06C5:  MOVLB  00
06C6:  BTFSS  11.4
06C7:  GOTO   6C6
06C8:  MOVLB  03
06C9:  MOVWF  1A
....................       printf("OK\r\n"); 
06CA:  MOVLW  62
06CB:  MOVWF  11
06CC:  MOVLW  02
06CD:  MOVWF  12
06CE:  MOVLB  00
06CF:  CLRF   28
06D0:  BTFSC  0B.7
06D1:  BSF    28.7
06D2:  BCF    0B.7
06D3:  CALL   174
06D4:  BTFSC  28.7
06D5:  BSF    0B.7
....................    } 
06D6:  GOTO   798
....................    else if ((rx_msg[index_reader] == '=') && (rx_msg[index_reader+1] == '?')) // case 3 of PWMPERIOD command 
06D7:  MOVLW  1C
06D8:  ADDWF  5C,W
06D9:  MOVWF  04
06DA:  MOVLW  20
06DB:  MOVWF  05
06DC:  BTFSC  03.0
06DD:  INCF   05,F
06DE:  MOVF   00,W
06DF:  SUBLW  3D
06E0:  BTFSS  03.2
06E1:  GOTO   718
06E2:  MOVLW  01
06E3:  ADDWF  5C,W
06E4:  ADDLW  1C
06E5:  MOVWF  04
06E6:  MOVLW  20
06E7:  MOVWF  05
06E8:  BTFSC  03.0
06E9:  INCF   05,F
06EA:  MOVF   00,W
06EB:  SUBLW  3F
06EC:  BTFSS  03.2
06ED:  GOTO   718
....................    { 
....................       // answer the command 
....................       printf("+PWMPERIOD:%X%X\r\n", (int)(desired_pwm_period>>8), (int)(desired_pwm_period)); 
06EE:  MOVF   32,W
06EF:  CLRF   7A
06F0:  MOVLB  02
06F1:  MOVWF  2E
06F2:  MOVLW  65
06F3:  MOVLB  03
06F4:  MOVWF  11
06F5:  MOVLW  02
06F6:  MOVWF  12
06F7:  BCF    03.0
06F8:  MOVLW  0B
06F9:  MOVLB  02
06FA:  MOVWF  32
06FB:  MOVLB  00
06FC:  CALL   3B3
06FD:  MOVLB  02
06FE:  MOVF   2E,W
06FF:  MOVWF  32
0700:  MOVLW  37
0701:  MOVWF  33
0702:  MOVLB  00
0703:  CALL   40F
0704:  MOVF   31,W
0705:  MOVLB  02
0706:  MOVWF  32
0707:  MOVLW  37
0708:  MOVWF  33
0709:  MOVLB  00
070A:  CALL   40F
070B:  MOVLW  0D
070C:  BTFSS  11.4
070D:  GOTO   70C
070E:  MOVLB  03
070F:  MOVWF  1A
0710:  MOVLW  0A
0711:  MOVLB  00
0712:  BTFSS  11.4
0713:  GOTO   712
0714:  MOVLB  03
0715:  MOVWF  1A
....................    } 
0716:  GOTO   799
0717:  MOVLB  00
....................    else if (rx_msg[index_reader] == '=') // case 1 of PWMPERIOD command 
0718:  MOVLW  1C
0719:  ADDWF  5C,W
071A:  MOVWF  04
071B:  MOVLW  20
071C:  MOVWF  05
071D:  BTFSC  03.0
071E:  INCF   05,F
071F:  MOVF   00,W
0720:  SUBLW  3D
0721:  BTFSS  03.2
0722:  GOTO   78B
....................    { 
....................       // read the value 
....................       for (i = index_reader+1; i <= index_rx_msg; i++) ///////// CHANGE THISSSSSS TO JUST < TO GET FINAL \r\n 
0723:  MOVLW  01
0724:  ADDWF  5C,W
0725:  MOVLB  02
0726:  MOVWF  2B
0727:  MOVF   2B,W
0728:  MOVLB  00
0729:  SUBWF  50,W
072A:  BTFSS  03.0
072B:  GOTO   74E
....................       { 
....................          // add character to value buffer 
....................          value_msg[index_value_msg] = rx_msg[i]; 
072C:  MOVLW  3D
072D:  ADDWF  62,W
072E:  MOVWF  78
072F:  MOVLW  20
0730:  MOVWF  7A
0731:  BTFSC  03.0
0732:  INCF   7A,F
0733:  MOVF   78,W
0734:  MOVLB  02
0735:  MOVWF  2E
0736:  MOVF   7A,W
0737:  MOVWF  2F
0738:  MOVLW  1C
0739:  ADDWF  2B,W
073A:  MOVWF  04
073B:  MOVLW  20
073C:  MOVWF  05
073D:  BTFSC  03.0
073E:  INCF   05,F
073F:  MOVF   00,W
0740:  MOVWF  30
0741:  MOVF   2F,W
0742:  MOVWF  05
0743:  MOVF   2E,W
0744:  MOVWF  04
0745:  MOVF   30,W
0746:  MOVWF  00
....................          index_value_msg += 1; 
0747:  MOVLW  01
0748:  MOVLB  00
0749:  ADDWF  62,F
074A:  MOVLB  02
074B:  INCF   2B,F
074C:  GOTO   727
074D:  MOVLB  00
....................       } 
....................        
....................       // end of value (read buffer to get the number) 
....................       unsigned int16 temp_desired_pwm_period = 0; 
074E:  MOVLB  02
074F:  CLRF   2D
0750:  CLRF   2C
....................       for (i = 0; i < index_value_msg; i++) 
0751:  CLRF   2B
0752:  MOVLB  00
0753:  MOVF   62,W
0754:  MOVLB  02
0755:  SUBWF  2B,W
0756:  BTFSC  03.0
0757:  GOTO   776
....................       { 
....................          temp_desired_pwm_period += char_hex_to_dec(value_msg[i],index_value_msg-2-i); 
0758:  MOVLW  3D
0759:  ADDWF  2B,W
075A:  MOVWF  04
075B:  MOVLW  20
075C:  MOVWF  05
075D:  BTFSC  03.0
075E:  INCF   05,F
075F:  MOVF   00,W
0760:  MOVWF  2E
0761:  MOVLW  02
0762:  MOVLB  00
0763:  SUBWF  62,W
0764:  MOVWF  78
0765:  MOVLB  02
0766:  MOVF   2B,W
0767:  SUBWF  78,W
0768:  MOVWF  2F
0769:  MOVF   2E,W
076A:  MOVWF  30
076B:  MOVF   2F,W
076C:  MOVWF  31
076D:  MOVLB  00
076E:  CALL   439
076F:  MOVF   77,W
0770:  MOVLB  02
0771:  ADDWF  2C,F
0772:  MOVF   78,W
0773:  ADDWFC 2D,F
0774:  INCF   2B,F
0775:  GOTO   752
....................       } 
....................       desired_pwm_period = temp_desired_pwm_period; // assig final value of PWM period 
0776:  MOVF   2D,W
0777:  MOVLB  00
0778:  MOVWF  32
0779:  MOVLB  02
077A:  MOVF   2C,W
077B:  MOVLB  00
077C:  MOVWF  31
....................       printf("OK\r\n"); 
077D:  MOVLW  6E
077E:  MOVLB  03
077F:  MOVWF  11
0780:  MOVLW  02
0781:  MOVWF  12
0782:  MOVLB  00
0783:  CLRF   28
0784:  BTFSC  0B.7
0785:  BSF    28.7
0786:  BCF    0B.7
0787:  CALL   174
0788:  BTFSC  28.7
0789:  BSF    0B.7
....................    } 
078A:  GOTO   798
....................    else 
....................    { 
....................       // the command is not recognized 
....................       printf("ERROR\r\n"); 
078B:  MOVLW  71
078C:  MOVLB  03
078D:  MOVWF  11
078E:  MOVLW  02
078F:  MOVWF  12
0790:  MOVLB  00
0791:  CLRF   28
0792:  BTFSC  0B.7
0793:  BSF    28.7
0794:  BCF    0B.7
0795:  CALL   174
0796:  BTFSC  28.7
0797:  BSF    0B.7
0798:  MOVLB  03
....................    } 
0799:  MOVLP  08
079A:  MOVLB  00
079B:  GOTO   4EC (RETURN)
.................... } 
....................  
....................  
.................... /* 
.................... * Function to manage PWMDUTY command 
.................... */ 
.................... void Manage_PWMDUTY_Command(void) 
*
0800:  MOVLB  02
0801:  CLRF   2B
.................... { 
....................    int8 i = 0; // general purpose index 
....................  
....................    if (rx_msg[index_reader] == '?') // case 2 of PWMDUTY command 
0802:  MOVLW  1C
0803:  MOVLB  00
0804:  ADDWF  5C,W
0805:  MOVWF  04
0806:  MOVLW  20
0807:  MOVWF  05
0808:  BTFSC  03.0
0809:  INCF   05,F
080A:  MOVF   00,W
080B:  SUBLW  3F
080C:  BTFSS  03.2
080D:  GOTO   0C3
....................    { 
....................       // answer the command 
....................       printf("+PWMDUTY:1,%X%X,2,%X%X,3,%X%X,4,%X%X\r\n", (int)(desired_dutycycle_pwm1>>8), (int)(desired_dutycycle_pwm1),  
....................                                                          (int)(desired_dutycycle_pwm2>>8), (int)(desired_dutycycle_pwm2), 
....................                                                          (int)(desired_dutycycle_pwm3>>8), (int)(desired_dutycycle_pwm3), 
....................                                                          (int)(desired_dutycycle_pwm4>>8), (int)(desired_dutycycle_pwm4)); 
080E:  MOVF   34,W
080F:  CLRF   7A
0810:  MOVLB  02
0811:  MOVWF  2E
0812:  MOVLB  00
0813:  MOVF   36,W
0814:  CLRF   7A
0815:  MOVLB  02
0816:  MOVWF  2F
0817:  MOVLB  00
0818:  MOVF   38,W
0819:  CLRF   7A
081A:  MOVLB  02
081B:  MOVWF  30
081C:  MOVLB  00
081D:  MOVF   3A,W
081E:  CLRF   7A
081F:  MOVLB  02
0820:  MOVWF  31
0821:  MOVLW  75
0822:  MOVLB  03
0823:  MOVWF  11
0824:  MOVLW  02
0825:  MOVWF  12
0826:  BCF    03.0
0827:  MOVLW  0B
0828:  MOVLB  02
0829:  MOVWF  32
082A:  MOVLP  00
082B:  MOVLB  00
082C:  CALL   3B3
082D:  MOVLP  08
082E:  MOVLB  02
082F:  MOVF   2E,W
0830:  MOVWF  32
0831:  MOVLW  37
0832:  MOVWF  33
0833:  MOVLP  00
0834:  MOVLB  00
0835:  CALL   40F
0836:  MOVLP  08
0837:  MOVF   33,W
0838:  MOVLB  02
0839:  MOVWF  32
083A:  MOVLW  37
083B:  MOVWF  33
083C:  MOVLP  00
083D:  MOVLB  00
083E:  CALL   40F
083F:  MOVLP  08
0840:  MOVLW  2C
0841:  BTFSS  11.4
0842:  GOTO   041
0843:  MOVLB  03
0844:  MOVWF  1A
0845:  MOVLW  32
0846:  MOVLB  00
0847:  BTFSS  11.4
0848:  GOTO   047
0849:  MOVLB  03
084A:  MOVWF  1A
084B:  MOVLW  2C
084C:  MOVLB  00
084D:  BTFSS  11.4
084E:  GOTO   04D
084F:  MOVLB  03
0850:  MOVWF  1A
0851:  MOVLB  02
0852:  MOVF   2F,W
0853:  MOVWF  32
0854:  MOVLW  37
0855:  MOVWF  33
0856:  MOVLP  00
0857:  MOVLB  00
0858:  CALL   40F
0859:  MOVLP  08
085A:  MOVF   35,W
085B:  MOVLB  02
085C:  MOVWF  32
085D:  MOVLW  37
085E:  MOVWF  33
085F:  MOVLP  00
0860:  MOVLB  00
0861:  CALL   40F
0862:  MOVLP  08
0863:  MOVLW  2C
0864:  BTFSS  11.4
0865:  GOTO   064
0866:  MOVLB  03
0867:  MOVWF  1A
0868:  MOVLW  33
0869:  MOVLB  00
086A:  BTFSS  11.4
086B:  GOTO   06A
086C:  MOVLB  03
086D:  MOVWF  1A
086E:  MOVLW  2C
086F:  MOVLB  00
0870:  BTFSS  11.4
0871:  GOTO   070
0872:  MOVLB  03
0873:  MOVWF  1A
0874:  MOVLB  02
0875:  MOVF   30,W
0876:  MOVWF  32
0877:  MOVLW  37
0878:  MOVWF  33
0879:  MOVLP  00
087A:  MOVLB  00
087B:  CALL   40F
087C:  MOVLP  08
087D:  MOVF   37,W
087E:  MOVLB  02
087F:  MOVWF  32
0880:  MOVLW  37
0881:  MOVWF  33
0882:  MOVLP  00
0883:  MOVLB  00
0884:  CALL   40F
0885:  MOVLP  08
0886:  MOVLW  2C
0887:  BTFSS  11.4
0888:  GOTO   087
0889:  MOVLB  03
088A:  MOVWF  1A
088B:  MOVLW  34
088C:  MOVLB  00
088D:  BTFSS  11.4
088E:  GOTO   08D
088F:  MOVLB  03
0890:  MOVWF  1A
0891:  MOVLW  2C
0892:  MOVLB  00
0893:  BTFSS  11.4
0894:  GOTO   093
0895:  MOVLB  03
0896:  MOVWF  1A
0897:  MOVLB  02
0898:  MOVF   31,W
0899:  MOVWF  32
089A:  MOVLW  37
089B:  MOVWF  33
089C:  MOVLP  00
089D:  MOVLB  00
089E:  CALL   40F
089F:  MOVLP  08
08A0:  MOVF   39,W
08A1:  MOVLB  02
08A2:  MOVWF  32
08A3:  MOVLW  37
08A4:  MOVWF  33
08A5:  MOVLP  00
08A6:  MOVLB  00
08A7:  CALL   40F
08A8:  MOVLP  08
08A9:  MOVLW  0D
08AA:  BTFSS  11.4
08AB:  GOTO   0AA
08AC:  MOVLB  03
08AD:  MOVWF  1A
08AE:  MOVLW  0A
08AF:  MOVLB  00
08B0:  BTFSS  11.4
08B1:  GOTO   0B0
08B2:  MOVLB  03
08B3:  MOVWF  1A
....................       printf("OK\r\n"); 
08B4:  MOVLW  89
08B5:  MOVWF  11
08B6:  MOVLW  02
08B7:  MOVWF  12
08B8:  MOVLB  00
08B9:  CLRF   28
08BA:  BTFSC  0B.7
08BB:  BSF    28.7
08BC:  BCF    0B.7
08BD:  MOVLP  00
08BE:  CALL   174
08BF:  MOVLP  08
08C0:  BTFSC  28.7
08C1:  BSF    0B.7
....................    } 
08C2:  GOTO   28F
....................    else if ((rx_msg[index_reader] == '=') && (rx_msg[index_reader+2] == '?')) // case 3 of PWMDUTY command 
08C3:  MOVLW  1C
08C4:  ADDWF  5C,W
08C5:  MOVWF  04
08C6:  MOVLW  20
08C7:  MOVWF  05
08C8:  BTFSC  03.0
08C9:  INCF   05,F
08CA:  MOVF   00,W
08CB:  SUBLW  3D
08CC:  BTFSS  03.2
08CD:  GOTO   1C6
08CE:  MOVLW  02
08CF:  ADDWF  5C,W
08D0:  ADDLW  1C
08D1:  MOVWF  04
08D2:  MOVLW  20
08D3:  MOVWF  05
08D4:  BTFSC  03.0
08D5:  INCF   05,F
08D6:  MOVF   00,W
08D7:  SUBLW  3F
08D8:  BTFSS  03.2
08D9:  GOTO   1C6
....................    { 
....................       // read the channel 
....................       desired_pwm_channel = rx_msg[index_reader+1]; 
08DA:  MOVLW  01
08DB:  ADDWF  5C,W
08DC:  ADDLW  1C
08DD:  MOVWF  04
08DE:  MOVLW  20
08DF:  MOVWF  05
08E0:  BTFSC  03.0
08E1:  INCF   05,F
08E2:  MOVF   00,W
08E3:  MOVWF  63
....................        
....................       // answer the command 
....................       if (desired_pwm_channel == '1') 
08E4:  MOVF   63,W
08E5:  SUBLW  31
08E6:  BTFSS  03.2
08E7:  GOTO   118
....................       { 
....................          printf("+PWMDUTY1:%X%X\r\n", (int)(desired_dutycycle_pwm1>>8), (int)(desired_dutycycle_pwm1)); 
08E8:  MOVF   34,W
08E9:  CLRF   7A
08EA:  MOVLB  02
08EB:  MOVWF  2E
08EC:  MOVLW  8C
08ED:  MOVLB  03
08EE:  MOVWF  11
08EF:  MOVLW  02
08F0:  MOVWF  12
08F1:  BCF    03.0
08F2:  MOVLW  0A
08F3:  MOVLB  02
08F4:  MOVWF  32
08F5:  MOVLP  00
08F6:  MOVLB  00
08F7:  CALL   3B3
08F8:  MOVLP  08
08F9:  MOVLB  02
08FA:  MOVF   2E,W
08FB:  MOVWF  32
08FC:  MOVLW  37
08FD:  MOVWF  33
08FE:  MOVLP  00
08FF:  MOVLB  00
0900:  CALL   40F
0901:  MOVLP  08
0902:  MOVF   33,W
0903:  MOVLB  02
0904:  MOVWF  32
0905:  MOVLW  37
0906:  MOVWF  33
0907:  MOVLP  00
0908:  MOVLB  00
0909:  CALL   40F
090A:  MOVLP  08
090B:  MOVLW  0D
090C:  BTFSS  11.4
090D:  GOTO   10C
090E:  MOVLB  03
090F:  MOVWF  1A
0910:  MOVLW  0A
0911:  MOVLB  00
0912:  BTFSS  11.4
0913:  GOTO   112
0914:  MOVLB  03
0915:  MOVWF  1A
....................       } 
0916:  GOTO   1C4
0917:  MOVLB  00
....................       else if (desired_pwm_channel == '2') 
0918:  MOVF   63,W
0919:  SUBLW  32
091A:  BTFSS  03.2
091B:  GOTO   14C
....................       { 
....................          printf("+PWMDUTY2:%X%X\r\n", (int)(desired_dutycycle_pwm2>>8), (int)(desired_dutycycle_pwm2)); 
091C:  MOVF   36,W
091D:  CLRF   7A
091E:  MOVLB  02
091F:  MOVWF  2E
0920:  MOVLW  95
0921:  MOVLB  03
0922:  MOVWF  11
0923:  MOVLW  02
0924:  MOVWF  12
0925:  BCF    03.0
0926:  MOVLW  0A
0927:  MOVLB  02
0928:  MOVWF  32
0929:  MOVLP  00
092A:  MOVLB  00
092B:  CALL   3B3
092C:  MOVLP  08
092D:  MOVLB  02
092E:  MOVF   2E,W
092F:  MOVWF  32
0930:  MOVLW  37
0931:  MOVWF  33
0932:  MOVLP  00
0933:  MOVLB  00
0934:  CALL   40F
0935:  MOVLP  08
0936:  MOVF   35,W
0937:  MOVLB  02
0938:  MOVWF  32
0939:  MOVLW  37
093A:  MOVWF  33
093B:  MOVLP  00
093C:  MOVLB  00
093D:  CALL   40F
093E:  MOVLP  08
093F:  MOVLW  0D
0940:  BTFSS  11.4
0941:  GOTO   140
0942:  MOVLB  03
0943:  MOVWF  1A
0944:  MOVLW  0A
0945:  MOVLB  00
0946:  BTFSS  11.4
0947:  GOTO   146
0948:  MOVLB  03
0949:  MOVWF  1A
....................       } 
094A:  GOTO   1C4
094B:  MOVLB  00
....................       else if (desired_pwm_channel == '3') 
094C:  MOVF   63,W
094D:  SUBLW  33
094E:  BTFSS  03.2
094F:  GOTO   180
....................       { 
....................          printf("+PWMDUTY3:%X%X\r\n", (int)(desired_dutycycle_pwm3>>8), (int)(desired_dutycycle_pwm3)); 
0950:  MOVF   38,W
0951:  CLRF   7A
0952:  MOVLB  02
0953:  MOVWF  2E
0954:  MOVLW  9E
0955:  MOVLB  03
0956:  MOVWF  11
0957:  MOVLW  02
0958:  MOVWF  12
0959:  BCF    03.0
095A:  MOVLW  0A
095B:  MOVLB  02
095C:  MOVWF  32
095D:  MOVLP  00
095E:  MOVLB  00
095F:  CALL   3B3
0960:  MOVLP  08
0961:  MOVLB  02
0962:  MOVF   2E,W
0963:  MOVWF  32
0964:  MOVLW  37
0965:  MOVWF  33
0966:  MOVLP  00
0967:  MOVLB  00
0968:  CALL   40F
0969:  MOVLP  08
096A:  MOVF   37,W
096B:  MOVLB  02
096C:  MOVWF  32
096D:  MOVLW  37
096E:  MOVWF  33
096F:  MOVLP  00
0970:  MOVLB  00
0971:  CALL   40F
0972:  MOVLP  08
0973:  MOVLW  0D
0974:  BTFSS  11.4
0975:  GOTO   174
0976:  MOVLB  03
0977:  MOVWF  1A
0978:  MOVLW  0A
0979:  MOVLB  00
097A:  BTFSS  11.4
097B:  GOTO   17A
097C:  MOVLB  03
097D:  MOVWF  1A
....................       } 
097E:  GOTO   1C4
097F:  MOVLB  00
....................       else if (desired_pwm_channel == '4') 
0980:  MOVF   63,W
0981:  SUBLW  34
0982:  BTFSS  03.2
0983:  GOTO   1B4
....................       { 
....................          printf("+PWMDUTY4:%X%X\r\n", (int)(desired_dutycycle_pwm4>>8), (int)(desired_dutycycle_pwm4)); 
0984:  MOVF   3A,W
0985:  CLRF   7A
0986:  MOVLB  02
0987:  MOVWF  2E
0988:  MOVLW  A7
0989:  MOVLB  03
098A:  MOVWF  11
098B:  MOVLW  02
098C:  MOVWF  12
098D:  BCF    03.0
098E:  MOVLW  0A
098F:  MOVLB  02
0990:  MOVWF  32
0991:  MOVLP  00
0992:  MOVLB  00
0993:  CALL   3B3
0994:  MOVLP  08
0995:  MOVLB  02
0996:  MOVF   2E,W
0997:  MOVWF  32
0998:  MOVLW  37
0999:  MOVWF  33
099A:  MOVLP  00
099B:  MOVLB  00
099C:  CALL   40F
099D:  MOVLP  08
099E:  MOVF   39,W
099F:  MOVLB  02
09A0:  MOVWF  32
09A1:  MOVLW  37
09A2:  MOVWF  33
09A3:  MOVLP  00
09A4:  MOVLB  00
09A5:  CALL   40F
09A6:  MOVLP  08
09A7:  MOVLW  0D
09A8:  BTFSS  11.4
09A9:  GOTO   1A8
09AA:  MOVLB  03
09AB:  MOVWF  1A
09AC:  MOVLW  0A
09AD:  MOVLB  00
09AE:  BTFSS  11.4
09AF:  GOTO   1AE
09B0:  MOVLB  03
09B1:  MOVWF  1A
....................       } 
09B2:  GOTO   1C4
09B3:  MOVLB  00
....................       else 
....................       { 
....................          // the command is not recognized 
....................          printf("ERROR\r\n"); 
09B4:  MOVLW  B0
09B5:  MOVLB  03
09B6:  MOVWF  11
09B7:  MOVLW  02
09B8:  MOVWF  12
09B9:  MOVLB  00
09BA:  CLRF   28
09BB:  BTFSC  0B.7
09BC:  BSF    28.7
09BD:  BCF    0B.7
09BE:  MOVLP  00
09BF:  CALL   174
09C0:  MOVLP  08
09C1:  BTFSC  28.7
09C2:  BSF    0B.7
09C3:  MOVLB  03
....................       } 
....................    } 
09C4:  GOTO   290
09C5:  MOVLB  00
....................    else if (rx_msg[index_reader] == '=') // case 1 of PWMDUTY command 
09C6:  MOVLW  1C
09C7:  ADDWF  5C,W
09C8:  MOVWF  04
09C9:  MOVLW  20
09CA:  MOVWF  05
09CB:  BTFSC  03.0
09CC:  INCF   05,F
09CD:  MOVF   00,W
09CE:  SUBLW  3D
09CF:  BTFSS  03.2
09D0:  GOTO   280
....................    { 
....................       // read the channel 
....................       desired_pwm_channel = rx_msg[index_reader+1]; 
09D1:  MOVLW  01
09D2:  ADDWF  5C,W
09D3:  ADDLW  1C
09D4:  MOVWF  04
09D5:  MOVLW  20
09D6:  MOVWF  05
09D7:  BTFSC  03.0
09D8:  INCF   05,F
09D9:  MOVF   00,W
09DA:  MOVWF  63
....................        
....................       // read the value 
....................       for (i = index_reader+3; i <= index_rx_msg; i++) ///////// CHANGE THISSSSSS TO JUST < TO GET FINAL \r\n 
09DB:  MOVLW  03
09DC:  ADDWF  5C,W
09DD:  MOVLB  02
09DE:  MOVWF  2B
09DF:  MOVF   2B,W
09E0:  MOVLB  00
09E1:  SUBWF  50,W
09E2:  BTFSS  03.0
09E3:  GOTO   202
....................       { 
....................          // add character to value buffer 
....................          value_msg[index_value_msg] = rx_msg[i]; 
09E4:  MOVLW  3D
09E5:  ADDWF  62,W
09E6:  MOVLB  02
09E7:  MOVWF  2E
09E8:  MOVLW  20
09E9:  MOVWF  2F
09EA:  BTFSC  03.0
09EB:  INCF   2F,F
09EC:  MOVLW  1C
09ED:  ADDWF  2B,W
09EE:  MOVWF  04
09EF:  MOVLW  20
09F0:  MOVWF  05
09F1:  BTFSC  03.0
09F2:  INCF   05,F
09F3:  MOVF   00,W
09F4:  MOVWF  30
09F5:  MOVF   2F,W
09F6:  MOVWF  05
09F7:  MOVF   2E,W
09F8:  MOVWF  04
09F9:  MOVF   30,W
09FA:  MOVWF  00
....................          index_value_msg += 1; 
09FB:  MOVLW  01
09FC:  MOVLB  00
09FD:  ADDWF  62,F
09FE:  MOVLB  02
09FF:  INCF   2B,F
0A00:  GOTO   1DF
0A01:  MOVLB  00
....................       } 
....................        
....................       // end of value (read buffer to get the number) 
....................       unsigned int16 temp_desired_pwm_dutycyle = 0; 
0A02:  MOVLB  02
0A03:  CLRF   2D
0A04:  CLRF   2C
....................       for (i = 0; i < index_value_msg; i++) 
0A05:  CLRF   2B
0A06:  MOVLB  00
0A07:  MOVF   62,W
0A08:  MOVLB  02
0A09:  SUBWF  2B,W
0A0A:  BTFSC  03.0
0A0B:  GOTO   22C
....................       { 
....................          temp_desired_pwm_dutycyle += char_hex_to_dec(value_msg[i],index_value_msg-2-i); 
0A0C:  MOVLW  3D
0A0D:  ADDWF  2B,W
0A0E:  MOVWF  04
0A0F:  MOVLW  20
0A10:  MOVWF  05
0A11:  BTFSC  03.0
0A12:  INCF   05,F
0A13:  MOVF   00,W
0A14:  MOVWF  2E
0A15:  MOVLW  02
0A16:  MOVLB  00
0A17:  SUBWF  62,W
0A18:  MOVWF  78
0A19:  MOVLB  02
0A1A:  MOVF   2B,W
0A1B:  SUBWF  78,W
0A1C:  MOVWF  2F
0A1D:  MOVF   2E,W
0A1E:  MOVWF  30
0A1F:  MOVF   2F,W
0A20:  MOVWF  31
0A21:  MOVLP  00
0A22:  MOVLB  00
0A23:  CALL   439
0A24:  MOVLP  08
0A25:  MOVF   77,W
0A26:  MOVLB  02
0A27:  ADDWF  2C,F
0A28:  MOVF   78,W
0A29:  ADDWFC 2D,F
0A2A:  INCF   2B,F
0A2B:  GOTO   206
....................       } 
....................        
....................       // answer the command 
....................       if (desired_pwm_channel == '1') 
0A2C:  MOVLB  00
0A2D:  MOVF   63,W
0A2E:  SUBLW  31
0A2F:  BTFSS  03.2
0A30:  GOTO   23A
....................       { 
....................          desired_dutycycle_pwm1 = temp_desired_pwm_dutycyle; // assig final value of PWM dutycycle 
0A31:  MOVLB  02
0A32:  MOVF   2D,W
0A33:  MOVLB  00
0A34:  MOVWF  34
0A35:  MOVLB  02
0A36:  MOVF   2C,W
0A37:  MOVLB  00
0A38:  MOVWF  33
....................       } 
0A39:  GOTO   270
....................       else if (desired_pwm_channel == '2') 
0A3A:  MOVF   63,W
0A3B:  SUBLW  32
0A3C:  BTFSS  03.2
0A3D:  GOTO   247
....................       { 
....................          desired_dutycycle_pwm2 = temp_desired_pwm_dutycyle; // assig final value of PWM dutycycle 
0A3E:  MOVLB  02
0A3F:  MOVF   2D,W
0A40:  MOVLB  00
0A41:  MOVWF  36
0A42:  MOVLB  02
0A43:  MOVF   2C,W
0A44:  MOVLB  00
0A45:  MOVWF  35
....................       } 
0A46:  GOTO   270
....................       else if (desired_pwm_channel == '3') 
0A47:  MOVF   63,W
0A48:  SUBLW  33
0A49:  BTFSS  03.2
0A4A:  GOTO   254
....................       { 
....................          desired_dutycycle_pwm3 = temp_desired_pwm_dutycyle; // assig final value of PWM dutycycle 
0A4B:  MOVLB  02
0A4C:  MOVF   2D,W
0A4D:  MOVLB  00
0A4E:  MOVWF  38
0A4F:  MOVLB  02
0A50:  MOVF   2C,W
0A51:  MOVLB  00
0A52:  MOVWF  37
....................       } 
0A53:  GOTO   270
....................       else if (desired_pwm_channel == '4') 
0A54:  MOVF   63,W
0A55:  SUBLW  34
0A56:  BTFSS  03.2
0A57:  GOTO   261
....................       { 
....................          desired_dutycycle_pwm4 = temp_desired_pwm_dutycyle; // assig final value of PWM dutycycle 
0A58:  MOVLB  02
0A59:  MOVF   2D,W
0A5A:  MOVLB  00
0A5B:  MOVWF  3A
0A5C:  MOVLB  02
0A5D:  MOVF   2C,W
0A5E:  MOVLB  00
0A5F:  MOVWF  39
....................       } 
0A60:  GOTO   270
....................       else 
....................       { 
....................          // the command is not recognized 
....................          printf("ERROR\r\n"); 
0A61:  MOVLW  B4
0A62:  MOVLB  03
0A63:  MOVWF  11
0A64:  MOVLW  02
0A65:  MOVWF  12
0A66:  MOVLB  00
0A67:  CLRF   28
0A68:  BTFSC  0B.7
0A69:  BSF    28.7
0A6A:  BCF    0B.7
0A6B:  MOVLP  00
0A6C:  CALL   174
0A6D:  MOVLP  08
0A6E:  BTFSC  28.7
0A6F:  BSF    0B.7
....................       } 
....................        
....................       printf("OK\r\n"); 
0A70:  MOVLW  B8
0A71:  MOVLB  03
0A72:  MOVWF  11
0A73:  MOVLW  02
0A74:  MOVWF  12
0A75:  MOVLB  00
0A76:  CLRF   28
0A77:  BTFSC  0B.7
0A78:  BSF    28.7
0A79:  BCF    0B.7
0A7A:  MOVLP  00
0A7B:  CALL   174
0A7C:  MOVLP  08
0A7D:  BTFSC  28.7
0A7E:  BSF    0B.7
....................    } 
0A7F:  GOTO   28F
....................    else 
....................    { 
....................       // the command is not recognized 
....................       printf("ERROR\r\n"); 
0A80:  MOVLW  BB
0A81:  MOVLB  03
0A82:  MOVWF  11
0A83:  MOVLW  02
0A84:  MOVWF  12
0A85:  MOVLB  00
0A86:  CLRF   28
0A87:  BTFSC  0B.7
0A88:  BSF    28.7
0A89:  BCF    0B.7
0A8A:  MOVLP  00
0A8B:  CALL   174
0A8C:  MOVLP  08
0A8D:  BTFSC  28.7
0A8E:  BSF    0B.7
0A8F:  MOVLB  03
....................    } 
0A90:  MOVLP  08
0A91:  MOVLB  00
0A92:  GOTO   50F (RETURN)
.................... } 
....................  
....................  
.................... /* 
.................... * Function to manage ABOUT command 
.................... */ 
.................... void Manage_ABOUT_Command(void) 
.................... { 
....................    // answer the command 
....................    printf("Version: 1.0\r\n"); 
*
079C:  MOVLW  BF
079D:  MOVLB  03
079E:  MOVWF  11
079F:  MOVLW  02
07A0:  MOVWF  12
07A1:  MOVLB  00
07A2:  CLRF   28
07A3:  BTFSC  0B.7
07A4:  BSF    28.7
07A5:  BCF    0B.7
07A6:  CALL   174
07A7:  BTFSC  28.7
07A8:  BSF    0B.7
....................    printf("Date: 26/08/2022\r\n"); 
07A9:  MOVLW  C7
07AA:  MOVLB  03
07AB:  MOVWF  11
07AC:  MOVLW  02
07AD:  MOVWF  12
07AE:  MOVLB  00
07AF:  CLRF   28
07B0:  BTFSC  0B.7
07B1:  BSF    28.7
07B2:  BCF    0B.7
07B3:  CALL   174
07B4:  BTFSC  28.7
07B5:  BSF    0B.7
....................    printf("OK\r\n"); 
07B6:  MOVLW  D1
07B7:  MOVLB  03
07B8:  MOVWF  11
07B9:  MOVLW  02
07BA:  MOVWF  12
07BB:  MOVLB  00
07BC:  CLRF   28
07BD:  BTFSC  0B.7
07BE:  BSF    28.7
07BF:  BCF    0B.7
07C0:  CALL   174
07C1:  BTFSC  28.7
07C2:  BSF    0B.7
07C3:  MOVLP  08
07C4:  GOTO   532 (RETURN)
.................... } 
....................  
....................  
.................... /* 
.................... * Function to manage HELP command 
.................... */ 
.................... void Manage_HELP_Command(void) 
.................... { 
....................    // answer the command 
....................    printf("AT  Comando de prueba\r\n"); 
*
0A93:  MOVLW  D4
0A94:  MOVLB  03
0A95:  MOVWF  11
0A96:  MOVLW  02
0A97:  MOVWF  12
0A98:  MOVLB  00
0A99:  CLRF   28
0A9A:  BTFSC  0B.7
0A9B:  BSF    28.7
0A9C:  BCF    0B.7
0A9D:  MOVLP  00
0A9E:  CALL   174
0A9F:  MOVLP  08
0AA0:  BTFSC  28.7
0AA1:  BSF    0B.7
....................    printf("AT+ANOUT  Para establecer salidas analogas\r\n"); 
0AA2:  MOVLW  E0
0AA3:  MOVLB  03
0AA4:  MOVWF  11
0AA5:  MOVLW  02
0AA6:  MOVWF  12
0AA7:  MOVLB  00
0AA8:  CLRF   28
0AA9:  BTFSC  0B.7
0AAA:  BSF    28.7
0AAB:  BCF    0B.7
0AAC:  MOVLP  00
0AAD:  CALL   174
0AAE:  MOVLP  08
0AAF:  BTFSC  28.7
0AB0:  BSF    0B.7
....................    printf("AT+PWMPERIOD  Para establecer periodo de canales PWM\r\n"); 
0AB1:  MOVLW  F7
0AB2:  MOVLB  03
0AB3:  MOVWF  11
0AB4:  MOVLW  02
0AB5:  MOVWF  12
0AB6:  MOVLB  00
0AB7:  CLRF   28
0AB8:  BTFSC  0B.7
0AB9:  BSF    28.7
0ABA:  BCF    0B.7
0ABB:  MOVLP  00
0ABC:  CALL   174
0ABD:  MOVLP  08
0ABE:  BTFSC  28.7
0ABF:  BSF    0B.7
....................    printf("AT+PWMDUTY  Para establecer ciclo de trabajo de canales PWM\r\n"); 
0AC0:  MOVLW  13
0AC1:  MOVLB  03
0AC2:  MOVWF  11
0AC3:  MOVLW  03
0AC4:  MOVWF  12
0AC5:  MOVLB  00
0AC6:  CLRF   28
0AC7:  BTFSC  0B.7
0AC8:  BSF    28.7
0AC9:  BCF    0B.7
0ACA:  MOVLP  00
0ACB:  CALL   174
0ACC:  MOVLP  08
0ACD:  BTFSC  28.7
0ACE:  BSF    0B.7
....................    printf("AT+ABOUT  Para mostrar informacion del producto\r\n"); 
0ACF:  MOVLW  32
0AD0:  MOVLB  03
0AD1:  MOVWF  11
0AD2:  MOVLW  03
0AD3:  MOVWF  12
0AD4:  MOVLB  00
0AD5:  CLRF   28
0AD6:  BTFSC  0B.7
0AD7:  BSF    28.7
0AD8:  BCF    0B.7
0AD9:  MOVLP  00
0ADA:  CALL   174
0ADB:  MOVLP  08
0ADC:  BTFSC  28.7
0ADD:  BSF    0B.7
....................    printf("AT+HELP  Para mostrar lista de comandos\r\n"); 
0ADE:  MOVLW  4B
0ADF:  MOVLB  03
0AE0:  MOVWF  11
0AE1:  MOVLW  03
0AE2:  MOVWF  12
0AE3:  MOVLB  00
0AE4:  CLRF   28
0AE5:  BTFSC  0B.7
0AE6:  BSF    28.7
0AE7:  BCF    0B.7
0AE8:  MOVLP  00
0AE9:  CALL   174
0AEA:  MOVLP  08
0AEB:  BTFSC  28.7
0AEC:  BSF    0B.7
....................    printf("OK\r\n"); 
0AED:  MOVLW  60
0AEE:  MOVLB  03
0AEF:  MOVWF  11
0AF0:  MOVLW  03
0AF1:  MOVWF  12
0AF2:  MOVLB  00
0AF3:  CLRF   28
0AF4:  BTFSC  0B.7
0AF5:  BSF    28.7
0AF6:  BCF    0B.7
0AF7:  MOVLP  00
0AF8:  CALL   174
0AF9:  MOVLP  08
0AFA:  BTFSC  28.7
0AFB:  BSF    0B.7
0AFC:  MOVLP  08
0AFD:  GOTO   555 (RETURN)
.................... } 
....................  
....................  
.................... /*  
.................... * Function to clear buffers of UART communications 
.................... */ 
.................... void Clear_Buffers(void) 
.................... { 
....................    for (int8 j = 0; j < index_rx_msg; j++) 
0AFE:  MOVLB  02
0AFF:  CLRF   2B
0B00:  MOVLB  00
0B01:  MOVF   50,W
0B02:  MOVLB  02
0B03:  SUBWF  2B,W
0B04:  BTFSC  03.0
0B05:  GOTO   310
....................    { 
....................       rx_msg[j] = 0;  
0B06:  MOVLW  1C
0B07:  ADDWF  2B,W
0B08:  MOVWF  04
0B09:  MOVLW  20
0B0A:  MOVWF  05
0B0B:  BTFSC  03.0
0B0C:  INCF   05,F
0B0D:  CLRF   00
0B0E:  INCF   2B,F
0B0F:  GOTO   300
....................    } 
....................    index_rx_msg = 0; // reset the buffer index 
0B10:  MOVLB  00
0B11:  CLRF   50
....................     
....................    for (j = 0; j < index_identifier_msg; j++) 
0B12:  MOVLB  02
0B13:  CLRF   2B
0B14:  MOVLB  00
0B15:  MOVF   5B,W
0B16:  MOVLB  02
0B17:  SUBWF  2B,W
0B18:  BTFSC  03.0
0B19:  GOTO   324
....................    { 
....................       identifier_msg[j] = 0;  
0B1A:  MOVLW  31
0B1B:  ADDWF  2B,W
0B1C:  MOVWF  04
0B1D:  MOVLW  20
0B1E:  MOVWF  05
0B1F:  BTFSC  03.0
0B20:  INCF   05,F
0B21:  CLRF   00
0B22:  INCF   2B,F
0B23:  GOTO   314
....................    } 
....................    index_identifier_msg = 0; // reset the buffer index 
0B24:  MOVLB  00
0B25:  CLRF   5B
....................     
....................    for (j = 0; j < index_value_msg; j++) 
0B26:  MOVLB  02
0B27:  CLRF   2B
0B28:  MOVLB  00
0B29:  MOVF   62,W
0B2A:  MOVLB  02
0B2B:  SUBWF  2B,W
0B2C:  BTFSC  03.0
0B2D:  GOTO   338
....................    { 
....................       value_msg[j] = 0;  
0B2E:  MOVLW  3D
0B2F:  ADDWF  2B,W
0B30:  MOVWF  04
0B31:  MOVLW  20
0B32:  MOVWF  05
0B33:  BTFSC  03.0
0B34:  INCF   05,F
0B35:  CLRF   00
0B36:  INCF   2B,F
0B37:  GOTO   328
....................    } 
....................    index_value_msg = 0; // reset the buffer index 
0B38:  MOVLB  00
0B39:  CLRF   62
0B3A:  MOVLP  08
0B3B:  GOTO   576 (RETURN)
.................... } 
....................  
....................  
.................... #ifdef __DEBUG__ 
.................... void Print_Buffers(void) 
.................... { 
....................    // print the message received 
....................    for (int8 k = 0; k < index_rx_msg; k++) 
....................    { 
....................       putc(rx_msg[k]);  
....................    } 
....................    printf("\r\n"); 
....................     
....................    // print the identifier received 
....................    for (k = 0; k < index_identifier_msg; k++) 
....................    { 
....................       putc(identifier_msg[k]);  
....................    } 
....................    printf("\r\n"); 
....................     
....................    // print the value received 
....................    for (k = 0; k < index_value_msg; k++) 
....................    { 
....................       putc(value_msg[k]);  
....................    } 
....................    printf("\r\n"); 
.................... } 
.................... #endif 
....................  
....................  
.................... void main() 
0B3C:  MOVLB  03
0B3D:  BSF    1F.3
0B3E:  MOVLW  08
0B3F:  MOVWF  1B
0B40:  MOVLW  02
0B41:  MOVWF  1C
0B42:  MOVLW  A6
0B43:  MOVWF  1E
0B44:  MOVLW  90
0B45:  MOVWF  1D
0B46:  MOVLB  04
0B47:  BCF    15.5
0B48:  MOVLW  40
0B49:  MOVWF  14
0B4A:  MOVLW  0B
0B4B:  MOVWF  12
0B4C:  MOVLW  3A
0B4D:  MOVWF  15
0B4E:  MOVLB  01
0B4F:  BCF    0E.5
0B50:  BSF    0E.4
0B51:  BCF    0E.3
0B52:  MOVLW  01
0B53:  MOVLB  00
0B54:  MOVWF  2C
0B55:  MOVLW  F4
0B56:  MOVWF  2B
0B57:  MOVLW  03
0B58:  MOVWF  2E
0B59:  MOVLW  20
0B5A:  MOVWF  2D
0B5B:  CLRF   30
0B5C:  CLRF   2F
0B5D:  MOVLW  19
0B5E:  MOVWF  32
0B5F:  MOVLW  B3
0B60:  MOVWF  31
0B61:  CLRF   34
0B62:  MOVLW  19
0B63:  MOVWF  33
0B64:  CLRF   36
0B65:  MOVLW  32
0B66:  MOVWF  35
0B67:  CLRF   38
0B68:  MOVLW  4B
0B69:  MOVWF  37
0B6A:  CLRF   3A
0B6B:  MOVLW  64
0B6C:  MOVWF  39
0B6D:  CLRF   3B
0B6E:  CLRF   50
0B6F:  CLRF   5B
0B70:  CLRF   5C
0B71:  CLRF   62
0B72:  CLRF   63
0B73:  CLRF   64
0B74:  CLRF   70
0B75:  MOVLB  0F
0B76:  CLRF   11
0B77:  CLRF   12
0B78:  CLRF   18
0B79:  CLRF   19
0B7A:  CLRF   1A
0B7B:  MOVLB  03
0B7C:  CLRF   0C
0B7D:  CLRF   0D
0B7E:  CLRF   0F
0B7F:  CLRF   10
0B80:  MOVLB  02
0B81:  CLRF   12
0B82:  CLRF   11
0B83:  CLRF   14
0B84:  CLRF   13
0B85:  GOTO   3F6
0B86:  DATA 02,34
0B87:  DATA 00,34
0B88:  DATA 29,34
0B89:  DATA 00,34
0B8A:  DATA 00,34
0B8B:  DATA 14,34
0B8C:  DATA 40,34
0B8D:  DATA 3C,34
0B8E:  DATA 00,34
0B8F:  DATA 0A,34
0B90:  DATA 40,34
0B91:  DATA 51,34
0B92:  DATA 00,34
0B93:  DATA 05,34
0B94:  DATA 40,34
0B95:  DATA 5D,34
0B96:  DATA 00,34
0B97:  DATA 06,34
0B98:  DATA 00,34
0B99:  DATA 66,34
0B9A:  DATA 41,34
0B9B:  DATA 4E,34
0B9C:  DATA 4F,34
0B9D:  DATA 55,34
0B9E:  DATA 54,34
0B9F:  DATA 00,34
0BA0:  DATA 06,34
0BA1:  DATA 00,34
0BA2:  DATA A0,34
0BA3:  DATA 61,34
0BA4:  DATA 6E,34
0BA5:  DATA 6F,34
0BA6:  DATA 75,34
0BA7:  DATA 74,34
0BA8:  DATA 00,34
0BA9:  DATA 1C,34
0BAA:  DATA 00,34
0BAB:  DATA AA,34
0BAC:  DATA 50,34
0BAD:  DATA 57,34
0BAE:  DATA 4D,34
0BAF:  DATA 50,34
0BB0:  DATA 45,34
0BB1:  DATA 52,34
0BB2:  DATA 49,34
0BB3:  DATA 4F,34
0BB4:  DATA 44,34
0BB5:  DATA 00,34
0BB6:  DATA 70,34
0BB7:  DATA 77,34
0BB8:  DATA 6D,34
0BB9:  DATA 70,34
0BBA:  DATA 65,34
0BBB:  DATA 72,34
0BBC:  DATA 69,34
0BBD:  DATA 6F,34
0BBE:  DATA 64,34
0BBF:  DATA 00,34
0BC0:  DATA 50,34
0BC1:  DATA 57,34
0BC2:  DATA 4D,34
0BC3:  DATA 44,34
0BC4:  DATA 55,34
0BC5:  DATA 54,34
0BC6:  DATA 59,34
0BC7:  DATA 00,34
0BC8:  DATA 08,34
0BC9:  DATA 00,34
0BCA:  DATA C8,34
0BCB:  DATA 70,34
0BCC:  DATA 77,34
0BCD:  DATA 6D,34
0BCE:  DATA 64,34
0BCF:  DATA 75,34
0BD0:  DATA 74,34
0BD1:  DATA 79,34
0BD2:  DATA 00,34
0BD3:  DATA 06,34
0BD4:  DATA 00,34
0BD5:  DATA D2,34
0BD6:  DATA 41,34
0BD7:  DATA 42,34
0BD8:  DATA 4F,34
0BD9:  DATA 55,34
0BDA:  DATA 54,34
0BDB:  DATA 00,34
0BDC:  DATA 06,34
0BDD:  DATA 00,34
0BDE:  DATA DC,34
0BDF:  DATA 61,34
0BE0:  DATA 62,34
0BE1:  DATA 6F,34
0BE2:  DATA 75,34
0BE3:  DATA 74,34
0BE4:  DATA 00,34
0BE5:  DATA 05,34
0BE6:  DATA 00,34
0BE7:  DATA E6,34
0BE8:  DATA 48,34
0BE9:  DATA 45,34
0BEA:  DATA 4C,34
0BEB:  DATA 50,34
0BEC:  DATA 00,34
0BED:  DATA 05,34
0BEE:  DATA 01,34
0BEF:  DATA 20,34
0BF0:  DATA 68,34
0BF1:  DATA 65,34
0BF2:  DATA 6C,34
0BF3:  DATA 70,34
0BF4:  DATA 00,34
0BF5:  DATA 00,34
0BF6:  MOVLW  0B
0BF7:  MOVWF  05
0BF8:  MOVLW  86
0BF9:  MOVWF  04
0BFA:  BSF    05.7
0BFB:  MOVIW  [FSR0++],W
0BFC:  MOVWF  77
0BFD:  XORLW  00
0BFE:  BTFSC  03.2
0BFF:  GOTO   410
0C00:  MOVIW  [FSR0++],W
0C01:  MOVWF  78
0C02:  BTFSC  78.7
0C03:  GOTO   408
0C04:  ANDLW  0F
0C05:  MOVWF  07
0C06:  MOVIW  [FSR0++],W
0C07:  MOVWF  06
0C08:  BTFSC  78.6
0C09:  MOVIW  [FSR0++],W
0C0A:  BTFSS  78.6
0C0B:  MOVIW  [FSR0++],W
0C0C:  MOVWI  W,[FSR1++]
0C0D:  DECFSZ 77,F
0C0E:  GOTO   40A
0C0F:  GOTO   3FB
.................... { 
....................    // Set initial state of IO pins 
....................    output_low(USER_LED); // start with led turn off 
0C10:  MOVLW  CF
0C11:  TRIS   6
0C12:  BCF    0D.4
....................    output_low(COMMS_LED); // start with led turn off 
0C13:  TRIS   6
0C14:  BCF    0D.5
....................    output_high(CS_PIN); // start in high to disable the slave 
0C15:  MOVLW  F5
0C16:  MOVLB  01
0C17:  MOVWF  0F
0C18:  MOVLB  02
0C19:  BSF    0F.3
....................     
....................    // Set initial state of PWM pins 
....................    output_low(PWM1_PIN); 
0C1A:  MOVLB  01
0C1B:  BCF    0E.2
0C1C:  MOVLB  02
0C1D:  BCF    0E.2
....................    output_low(PWM2_PIN); 
0C1E:  MOVLB  01
0C1F:  BCF    0E.1
0C20:  MOVLB  02
0C21:  BCF    0E.1
....................    output_low(PWM3_PIN); 
0C22:  MOVLB  01
0C23:  BCF    10.0
0C24:  MOVLB  02
0C25:  BCF    10.0
....................    output_low(PWM4_PIN); 
0C26:  MOVLB  01
0C27:  MOVWF  0F
0C28:  MOVLB  02
0C29:  BCF    0F.1
....................     
....................    // Set initial 0V at DAC output channels 
....................     
....................     
....................    // Configure TIM2 to PWM timebase 
....................    setup_timer_2(T2_DIV_BY_1,75,1);      // 15,2 us overflow, 15,2 us interrupt 
0C2A:  MOVLW  00
0C2B:  MOVWF  78
0C2C:  IORLW  04
0C2D:  MOVLB  00
0C2E:  MOVWF  1C
0C2F:  MOVLW  4B
0C30:  MOVWF  1B
....................     
....................    // Configure interrupts 
....................    enable_interrupts(INT_TIMER2); // timer 2 interrupt 
0C31:  MOVLB  01
0C32:  BSF    11.1
....................    enable_interrupts(INT_RDA); // UART interrupt 
0C33:  BSF    11.5
....................    enable_interrupts(GLOBAL); 
0C34:  MOVLW  C0
0C35:  IORWF  0B,F
....................     
....................    // Start UART communication 
....................    uart_state = ST_WAIT; 
0C36:  MOVLB  00
0C37:  CLRF   65
....................    printf("READY\r\n"); 
0C38:  MOVLW  63
0C39:  MOVLB  03
0C3A:  MOVWF  11
0C3B:  MOVLW  03
0C3C:  MOVWF  12
0C3D:  MOVLB  00
0C3E:  CLRF   28
0C3F:  BTFSC  0B.7
0C40:  BSF    28.7
0C41:  BCF    0B.7
0C42:  MOVLP  00
0C43:  CALL   174
0C44:  MOVLP  08
0C45:  BTFSC  28.7
0C46:  BSF    0B.7
....................  
....................    while(TRUE) 
....................    { 
....................       if (NEW_MSG_RECEIVED_FLAG == true) 
0C47:  DECFSZ 70,W
0C48:  GOTO   577
....................       { 
....................          // manage the event 
....................          if (rx_msg[0] == 0) // simple AT command 
0C49:  MOVF   3C,F
0C4A:  BTFSS  03.2
0C4B:  GOTO   45C
....................          { 
....................             printf("OK\r\n");  
0C4C:  MOVLW  67
0C4D:  MOVLB  03
0C4E:  MOVWF  11
0C4F:  MOVLW  03
0C50:  MOVWF  12
0C51:  MOVLB  00
0C52:  CLRF   28
0C53:  BTFSC  0B.7
0C54:  BSF    28.7
0C55:  BCF    0B.7
0C56:  MOVLP  00
0C57:  CALL   174
0C58:  MOVLP  08
0C59:  BTFSC  28.7
0C5A:  BSF    0B.7
....................          } 
0C5B:  GOTO   575
....................          else if (rx_msg[0] == '+') // complex AT command 
0C5C:  MOVF   3C,W
0C5D:  SUBLW  2B
0C5E:  BTFSS  03.2
0C5F:  GOTO   566
....................          { 
....................             // get the identifier of the received command 
....................             for (int8 i = 1; i < index_rx_msg; i++) 
0C60:  MOVLW  01
0C61:  MOVLB  02
0C62:  MOVWF  2A
0C63:  MOVLB  00
0C64:  MOVF   50,W
0C65:  MOVLB  02
0C66:  SUBWF  2A,W
0C67:  BTFSC  03.0
0C68:  GOTO   4A7
....................             { 
....................                if ( (rx_msg[i] == '=') || (rx_msg[i] == '?') ) 
0C69:  MOVLW  1C
0C6A:  ADDWF  2A,W
0C6B:  MOVWF  04
0C6C:  MOVLW  20
0C6D:  MOVWF  05
0C6E:  BTFSC  03.0
0C6F:  INCF   05,F
0C70:  MOVF   00,W
0C71:  SUBLW  3D
0C72:  BTFSC  03.2
0C73:  GOTO   47F
0C74:  MOVLW  1C
0C75:  ADDWF  2A,W
0C76:  MOVWF  04
0C77:  MOVLW  20
0C78:  MOVWF  05
0C79:  BTFSC  03.0
0C7A:  INCF   05,F
0C7B:  MOVF   00,W
0C7C:  SUBLW  3F
0C7D:  BTFSS  03.2
0C7E:  GOTO   485
....................                { 
....................                   // end of command identifier 
....................                   index_reader = i; 
0C7F:  MOVF   2A,W
0C80:  MOVLB  00
0C81:  MOVWF  5C
....................                   break; 
0C82:  MOVLB  02
0C83:  GOTO   4A7
....................                } 
0C84:  GOTO   4A5
....................                else 
....................                { 
....................                   // read the command identifier 
....................                   identifier_msg[index_identifier_msg] = rx_msg[i]; 
0C85:  MOVLW  31
0C86:  MOVLB  00
0C87:  ADDWF  5B,W
0C88:  MOVWF  78
0C89:  MOVLW  20
0C8A:  MOVWF  7A
0C8B:  BTFSC  03.0
0C8C:  INCF   7A,F
0C8D:  MOVF   78,W
0C8E:  MOVLB  02
0C8F:  MOVWF  2B
0C90:  MOVF   7A,W
0C91:  MOVWF  2C
0C92:  MOVLW  1C
0C93:  ADDWF  2A,W
0C94:  MOVWF  04
0C95:  MOVLW  20
0C96:  MOVWF  05
0C97:  BTFSC  03.0
0C98:  INCF   05,F
0C99:  MOVF   00,W
0C9A:  MOVWF  2D
0C9B:  MOVF   2C,W
0C9C:  MOVWF  05
0C9D:  MOVF   2B,W
0C9E:  MOVWF  04
0C9F:  MOVF   2D,W
0CA0:  MOVWF  00
....................                   index_identifier_msg += 1; 
0CA1:  MOVLW  01
0CA2:  MOVLB  00
0CA3:  ADDWF  5B,F
0CA4:  MOVLB  02
....................                } 
0CA5:  INCF   2A,F
0CA6:  GOTO   463
....................             } 
....................              
....................             // select between commands 
....................             ////// ANOUT Command ////// 
....................             if ( (strcmp(identifier_msg, CMD_1) == 0) || (strcmp(identifier_msg, CMD_1_1) == 0) )  
0CA7:  MOVLW  20
0CA8:  MOVWF  2C
0CA9:  MOVLW  31
0CAA:  MOVWF  2B
0CAB:  MOVLW  20
0CAC:  MOVWF  2E
0CAD:  MOVLW  46
0CAE:  MOVWF  2D
0CAF:  MOVLP  00
0CB0:  MOVLB  00
0CB1:  CALL   372
0CB2:  MOVLP  08
0CB3:  MOVF   78,F
0CB4:  BTFSC  03.2
0CB5:  GOTO   4C6
0CB6:  MOVLW  20
0CB7:  MOVLB  02
0CB8:  MOVWF  2C
0CB9:  MOVLW  31
0CBA:  MOVWF  2B
0CBB:  MOVLW  20
0CBC:  MOVWF  2E
0CBD:  MOVLW  50
0CBE:  MOVWF  2D
0CBF:  MOVLP  00
0CC0:  MOVLB  00
0CC1:  CALL   372
0CC2:  MOVLP  08
0CC3:  MOVF   78,F
0CC4:  BTFSS  03.2
0CC5:  GOTO   4CA
....................             { 
....................                Manage_ANOUT_Command(); 
0CC6:  MOVLP  00
0CC7:  GOTO   4F1
0CC8:  MOVLP  08
....................             } 
0CC9:  GOTO   565
....................              
....................             ////// PWMPERIOD Command ////// 
....................             else if ( (strcmp(identifier_msg, CMD_2) == 0) || (strcmp(identifier_msg, CMD_2_2) == 0) )  
0CCA:  MOVLW  20
0CCB:  MOVLB  02
0CCC:  MOVWF  2C
0CCD:  MOVLW  31
0CCE:  MOVWF  2B
0CCF:  MOVLW  20
0CD0:  MOVWF  2E
0CD1:  MOVLW  5A
0CD2:  MOVWF  2D
0CD3:  MOVLP  00
0CD4:  MOVLB  00
0CD5:  CALL   372
0CD6:  MOVLP  08
0CD7:  MOVF   78,F
0CD8:  BTFSC  03.2
0CD9:  GOTO   4EA
0CDA:  MOVLW  20
0CDB:  MOVLB  02
0CDC:  MOVWF  2C
0CDD:  MOVLW  31
0CDE:  MOVWF  2B
0CDF:  MOVLW  20
0CE0:  MOVWF  2E
0CE1:  MOVLW  64
0CE2:  MOVWF  2D
0CE3:  MOVLP  00
0CE4:  MOVLB  00
0CE5:  CALL   372
0CE6:  MOVLP  08
0CE7:  MOVF   78,F
0CE8:  BTFSS  03.2
0CE9:  GOTO   4EE
....................             { 
....................                Manage_PWMPERIOD_Command(); 
0CEA:  MOVLP  00
0CEB:  GOTO   694
0CEC:  MOVLP  08
....................             } 
0CED:  GOTO   565
....................              
....................             ////// PWMDUTY Command ////// 
....................             else if ( (strcmp(identifier_msg, CMD_3) == 0) || (strcmp(identifier_msg, CMD_3_3) == 0) )  
0CEE:  MOVLW  20
0CEF:  MOVLB  02
0CF0:  MOVWF  2C
0CF1:  MOVLW  31
0CF2:  MOVWF  2B
0CF3:  MOVLW  20
0CF4:  MOVWF  2E
0CF5:  MOVLW  6E
0CF6:  MOVWF  2D
0CF7:  MOVLP  00
0CF8:  MOVLB  00
0CF9:  CALL   372
0CFA:  MOVLP  08
0CFB:  MOVF   78,F
0CFC:  BTFSC  03.2
0CFD:  GOTO   50E
0CFE:  MOVLW  20
0CFF:  MOVLB  02
0D00:  MOVWF  2C
0D01:  MOVLW  31
0D02:  MOVWF  2B
0D03:  MOVLW  20
0D04:  MOVWF  2E
0D05:  MOVLW  78
0D06:  MOVWF  2D
0D07:  MOVLP  00
0D08:  MOVLB  00
0D09:  CALL   372
0D0A:  MOVLP  08
0D0B:  MOVF   78,F
0D0C:  BTFSS  03.2
0D0D:  GOTO   510
....................             { 
....................                Manage_PWMDUTY_Command(); 
0D0E:  GOTO   000
....................             } 
0D0F:  GOTO   565
....................              
....................             ////// ABOUT Command ////// 
....................             else if ( (strcmp(identifier_msg, CMD_4) == 0) || (strcmp(identifier_msg, CMD_4_4) == 0) ) 
0D10:  MOVLW  20
0D11:  MOVLB  02
0D12:  MOVWF  2C
0D13:  MOVLW  31
0D14:  MOVWF  2B
0D15:  MOVLW  20
0D16:  MOVWF  2E
0D17:  MOVLW  82
0D18:  MOVWF  2D
0D19:  MOVLP  00
0D1A:  MOVLB  00
0D1B:  CALL   372
0D1C:  MOVLP  08
0D1D:  MOVF   78,F
0D1E:  BTFSC  03.2
0D1F:  GOTO   530
0D20:  MOVLW  20
0D21:  MOVLB  02
0D22:  MOVWF  2C
0D23:  MOVLW  31
0D24:  MOVWF  2B
0D25:  MOVLW  20
0D26:  MOVWF  2E
0D27:  MOVLW  8C
0D28:  MOVWF  2D
0D29:  MOVLP  00
0D2A:  MOVLB  00
0D2B:  CALL   372
0D2C:  MOVLP  08
0D2D:  MOVF   78,F
0D2E:  BTFSS  03.2
0D2F:  GOTO   534
....................             { 
....................                Manage_ABOUT_Command(); 
0D30:  MOVLP  00
0D31:  GOTO   79C
0D32:  MOVLP  08
....................             } 
0D33:  GOTO   565
....................              
....................             ////// HELP command ////// 
....................             else if ( (strcmp(identifier_msg, CMD_5) == 0) || (strcmp(identifier_msg, CMD_5_5) == 0) )  
0D34:  MOVLW  20
0D35:  MOVLB  02
0D36:  MOVWF  2C
0D37:  MOVLW  31
0D38:  MOVWF  2B
0D39:  MOVLW  20
0D3A:  MOVWF  2E
0D3B:  MOVLW  96
0D3C:  MOVWF  2D
0D3D:  MOVLP  00
0D3E:  MOVLB  00
0D3F:  CALL   372
0D40:  MOVLP  08
0D41:  MOVF   78,F
0D42:  BTFSC  03.2
0D43:  GOTO   554
0D44:  MOVLW  20
0D45:  MOVLB  02
0D46:  MOVWF  2C
0D47:  MOVLW  31
0D48:  MOVWF  2B
0D49:  MOVLW  20
0D4A:  MOVWF  2E
0D4B:  MOVLW  A0
0D4C:  MOVWF  2D
0D4D:  MOVLP  00
0D4E:  MOVLB  00
0D4F:  CALL   372
0D50:  MOVLP  08
0D51:  MOVF   78,F
0D52:  BTFSS  03.2
0D53:  GOTO   556
....................             { 
....................                Manage_HELP_Command(); 
0D54:  GOTO   293
....................             } 
0D55:  GOTO   565
....................              
....................             else 
....................             { 
....................                // the identifier of the command is not recognized 
....................                printf("ERROR\r\n"); 
0D56:  MOVLW  6A
0D57:  MOVLB  03
0D58:  MOVWF  11
0D59:  MOVLW  03
0D5A:  MOVWF  12
0D5B:  MOVLB  00
0D5C:  CLRF   28
0D5D:  BTFSC  0B.7
0D5E:  BSF    28.7
0D5F:  BCF    0B.7
0D60:  MOVLP  00
0D61:  CALL   174
0D62:  MOVLP  08
0D63:  BTFSC  28.7
0D64:  BSF    0B.7
....................             } 
....................              
....................             #ifdef __DEBUG__ 
....................             Print_Buffers(); // to view buffer's info in debugging 
....................             #endif 
....................          } 
0D65:  GOTO   575
....................          else 
....................          { 
....................             // the structure of the command is not correct 
....................             printf("ERROR\r\n"); 
0D66:  MOVLW  6E
0D67:  MOVLB  03
0D68:  MOVWF  11
0D69:  MOVLW  03
0D6A:  MOVWF  12
0D6B:  MOVLB  00
0D6C:  CLRF   28
0D6D:  BTFSC  0B.7
0D6E:  BSF    28.7
0D6F:  BCF    0B.7
0D70:  MOVLP  00
0D71:  CALL   174
0D72:  MOVLP  08
0D73:  BTFSC  28.7
0D74:  BSF    0B.7
....................          } 
....................           
....................          // clear the buffers 
....................          Clear_Buffers(); 
0D75:  GOTO   2FE
....................          // clear the flag 
....................          NEW_MSG_RECEIVED_FLAG = false; 
0D76:  CLRF   70
....................       } 
....................       else 
....................       { 
....................          // do nothing 
....................       } 
0D77:  GOTO   447
....................    } 
.................... } 
0D78:  SLEEP

Configuration Fuses:
   Word  1: 39C2   HS NOWDT PUT MCLR NOPROTECT NOCPD NOBROWNOUT NOCLKOUT IESO FCMEN
   Word  2: 1EFF   NOWRT NOVCAP PLL_SW STVREN BORV19 NODEBUG NOLVP
